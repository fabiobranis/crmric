Static __cSx3Casas

#INCLUDE "PROTHEUS.CH"
#INCLUDE "FATXFUN.CH"
/*/

Ŀ
Funo    FATXFUN    Autor  Eduardo Riera          Data  31.08.2001
Ĵ
Descrio Biblioteca de funcoes das rotinas de vendas                  
                                                                       
Ĵ
Uso       Materiais                                                    
ٱ




Ŀ
Descrio  PLANO DE MELHORIA CONTINUA                                 
Ĵ
ITEM PMC  Responsavel               Data          |BOPS:             
Ĵ
      01                                          |                  
      02  Flavio Luiz Vicco         13/04/2006    |00000096972       
      03                                          |                  
      04                                          |                  
      05                                          |                  
      06                                          |                  
      07                                          |                  
      08                                          |                  
      09                                          |                  
      10  Flavio Luiz Vicco         13/04/2006    |00000096762       
ٱ


/*/
/*/


Ŀ
Funcao    A440Grava  Rev.   Eduardo Riera          Data  10.03.99 
Ĵ
Descrio Gravacao da Liberacao do Pedido via Mata440                 
Ĵ
Retorno   ExpL1: lGravou                                              
Ĵ
ParametrosExpL1: Liberacao Parcial                                    
          ExpL2: Transfere Locais                                     
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
20/07/2006Erike Yuri     Alteracao das ref. de grade para objeto     
ٱ


/*/

Function A440Grava(lLiber,lTransf)

Local lGrade   := MaGrade() .And. MaReadGrd()<>NIL
Local bCampo   := {|n| FieldName(n) }
Local nCntFor  := 0
Local nCntFor2 := 0
Local nMaxFor  := Len(aCols)
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local lLiberOk := .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lItLib   := .F.
Local nPosItem := GDFieldPos("C6_ITEM")
Local nPosProd := GDFieldPos("C6_PRODUTO")

Private lbloqDCF := !Empty(SC9->C9_BLCRED+SC9->C9_BLEST)
Private nValItPed := 0

//Ŀ
// Se Grade estiver ativa, grava Acols conforme AcolsGrade      
// para depois continuar a gravar como um pedido comum          
//
If ( lGrade )
	If "MATA410" $ SuperGetMV("MV_GRDMULT",.F.,"")
		aCols := aGradeCols(oGrade,aCols,aHeader,"C6_PRODUTO","C6_ITEMGRD","C6_QTDVEN","C6_ITEM")
	Else
		Ma410GraGr()
	EndIf
	nMaxFor := Len(aCols)
EndIf
//Ŀ
// Grava arquivo SC5                                       
//
Begin Transaction
dbSelectArea("SC5")
RecLock("SC5")
For nCntFor := 1 To FCount()
	If ( "FILIAL" $ FieldName(nCntFor) )
		SC5->(FieldPut(nCntFor,xFilial("SC5")))
	Else
		SC5->(FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor))))
	EndIf
Next nCntFor
End Transaction
//Ŀ
// Grava arquivo SC6                                                      
//
dbSelectArea("SC6")
dbSetOrder(1)
MsSeek(xFilial("SC6")+M->C5_NUM)
For nCntFor := 1 To nMaxFor
	//Esta alterao foi necessria devido ao ponto de entrada "MA440SC6" permitir que itens sejam exibidos 
	//ou no no momento da liberao do pedido e com isso o aCols vem com uma quantidade menor de itens.
	If SC6->C6_ITEM+SC6->C6_PRODUTO <> aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd]
		MsSeek(xFilial("SC6")+M->C5_NUM+aCols[nCntFor][nPosItem]+aCols[nCntFor][nPosProd])
	EndIf
	Begin Transaction
	RecLock("SC6")
	For nCntFor2 := 1 To Len(aHeader)
		If ( aHeader[nCntFor2][10] <> "V" )
			SC6->(FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2]))
		EndIf
	Next nCntFor2
	//Ŀ
	//Efetua a Liberacao do Pedido por Item de Pedido                         
	//
	If SC6->C6_QTDLIB <> 0 .Or. (MaTesSel(SC6->C6_TES) .And. MaTesLZero()) .Or. Ma440Compl()	
		lItLib := .T.
		If ( SC5->C5_TIPLIB<>"2" )
			nQtdLib := SC6->C6_QTDLIB
			nQtdLib2:= If( Empty( SC6->C6_QTDLIB2 ), NIL, SC6->C6_QTDLIB2 )
			nQtdLib := MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,.T.,.T.,lLiber,lTransf,NIL,NIL,NIL,NIL,NIL,NIL,nQtdLib2)
		EndIf
	EndIf
	//Ŀ
	//Verifica se Todos os Itens foram Liberados                              
	//
	If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If lLiberOk
		//Ŀ
		// PCO - Grava o lancamentos de liberacao do item do pedido de venda 
		//
		PcoDetLan("000103","01","MATA440")
	EndIf
	End Transaction
	dbSelectArea("SC6")
	dbSkip()
Next nCntFor
//Ŀ
//Liberacao por Pedido                                                    
//
Begin Transaction
If ( SC5->C5_TIPLIB=="2" .And. lItLib )
	MaAvLibPed(SC5->C5_NUM,lLiber,lTransf,@lLiberOk)
EndIf
//Ŀ
//Atualiza do C5_LIBEROK                                                  
//
If ( lLiberOk )
	dbSelectArea("SC5")
	RecLock("SC5")
	SC5->C5_LIBEROK := "S"
	MsUnlock()
	//Ŀ
	// PCO - Grava o lancamento de liberacao de pedido de venda 
	//
	PcoDetLan("000103","02","MATA440")
EndIf
//Ŀ
// Ponto de entrada para todos os itens do pedido.     
//
If ( ExistTemplate("MTA410T") )
	ExecTemplate("MTA410T",.f.,.f.)
EndIf
                                                   
If nModulo == 72
	KEXF920()
EndIf

If ( ExistBlock("MTA410T") )
	ExecBlock("MTA410T",.f.,.f.)
EndIf
End Transaction
Return(.T.)

/*/


Ŀ
Funcao    A440VerSb2 Rev.   Eduardo Riera          Data 15.03.99  
Ĵ
Descrio Verifica o Estoque quanto a quantidade liberada             
Ĵ
Retorno   ExpL1: Indica se o estoque foi liberado                     
Ĵ
ParametrosExpN1: Quantidade a ser liberada                            
          ExpL2: Permite Liberacao Parcial                            
          ExpL3: Permite transferencia de Locais automaticamente      
          ExpA4: Array com os locais de transferencia                 
          ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
Ĵ
ObservacaoO SC6 deve estar posicionado                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function A440VerSB2(nQtdLib,lLiber,lTransf,aLocal,aEmpenho,lVerPar)

Local cFiltro  := ""
Local cLocCq   := SuperGetMV('MV_CQ', .F., '98')
Local lRetorno := .F.
Local nSaldo   := 0
Local nDecimal := TamSx3("B2_QATU")[2]
Local nRegEmp  := 0
Local nSldSB2  := 0
Local nQtdJaEmp:= 0
Local cLocCQOri:= ''
Local aSaldoCQ := {}
Local nSaldoCQ := 0
Local nQtd440L := 0
Local nQtdEmp  := 0
Local aEmpBN   := If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})

//Ŀ
//Parametros default                                                      
//
DEFAULT lLiber   := .F.
DEFAULT lTransf  := .F.
DEFAULT aLocal   := {}
DEFAULT lVerPar  := .T.

cLocCQOri := cLocCq //-- Inicializa variavel somente com o Armazem de CQ

If ( ExistBlock("MTA440A") )
	cFiltro := ExecBlock("MTA440A")
	If !Empty(cFiltro) .And. (ValType(cFiltro) == "C")
		cLocCQ += "/"+cFiltro
	EndIf
EndIf
//Ŀ
//Verifica a movimentacao de Estoque.                                     
//
dbSelectArea("SF4")
dbSetOrder(1)
If ( MsSeek(xFilial("SF4")+SC6->C6_TES) )
	If ( SF4->F4_ESTOQUE == "S" )
		If !Empty(aEmpBN)
			//-- Chama funcao para baixar empenho caso haja remessa para terceiros
			nQtdEmp := A410LibBen(1,aEmpBN[1,1],aEmpBN[1,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
		EndIf
		dbSelectArea("SB1")
		dbSetOrder(1)
		MsSeek(xFilial("SB1")+SC6->C6_PRODUTO)
		dbSelectArea("SB2")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) )
			If ( aEmpenho <> Nil )
				nQtdJaEmp := 0
				For nRegEmp := 1 To Len(aEmpenho[2])
					If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
						If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
								aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
							nSaldo -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
							nQtdJaEmp += aEmpenho[2][nRegEmp][2] //B2_RESERVA
						EndIf
					EndIf
				Next nRegEmp
			EndIf
			nQtd440L := If(ExistBlock("MTA440L"),ExecBlock("MTA440L",.F.,.F.),0)
			nSaldo   -= nQtd440L
			If lVerPar
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,SC6->C6_RESERVA,SF4->F4_PODER3<>"N" .Or. (SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3)),(SF4->(FieldPos("F4_SLDNPT"))<>0 .And. SF4->F4_SLDNPT=="1"),SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			Else
				nSaldo   += SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaEmp+IIf(nQtd440L>0,nQtd440L,0),,,,SC6->C6_NUMSERI,SC6->C6_RESERVA,SF4->F4_PODER3<>"N" .Or. (SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3)),(SF4->(FieldPos("F4_SLDNPT"))<>0 .And. SF4->F4_SLDNPT=="1"),SC6->C6_PROJPMS,SC6->C6_TASKPMS,SC6->C6_SERVIC,!Empty(aEmpBN))
			EndIf
			nSaldo   += SC6->C6_QTDRESE
			//Ŀ
			// Para Devolucoes subtrai o saldo do CQ (ainda Nao Liberado e Nao Rejeitado) 
			//
			If SC5->C5_TIPO == 'D' .And. !Empty(SC6->C6_NFORI+SC6->C6_SERIORI) .And. SC6->C6_LOCAL == cLocCQOri
				aSaldoCQ := SaldoRjCQ(SC6->C6_PRODUTO,SC6->C6_NFORI,SC6->C6_SERIORI,SC6->C6_CLI,SC6->C6_LOJA,SC6->C6_NUMLOTE,SC6->C6_ITEMORI,/*dDataAtu*/,SC6->C6_LOCAL)
				nSaldoCQ := aSaldoCQ[1]-aSaldoCQ[2]-aSaldoCQ[3]+aSaldoCQ[4]-aSaldoCQ[5]
				nSaldo   := Min(SaldoSB2(nil,.T.) - nSaldoCQ,nSaldo)
			EndIf
			If ( NoRound(nQtdLib,nDecimal) <= NoRound(nSaldo,nDecimal) )
				lTransf  := .F.
				lRetorno := .T.
			Else
				If ( lLiber .And. nSaldo > 0)
					nQtdLib  := nSaldo
					lTransf  := .F.
					lRetorno := .T.
				EndIf
			EndIf
			//Ŀ
			//Verifica os demais almoxarifados                                        
			//
			If ( lTransf .And. !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO) )
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+SC6->C6_PRODUTO) //posiciona no primeiro local
				While ( !Eof() .And. xFilial("SB2") == SB2->B2_FILIAL .And.;
						SC6->C6_PRODUTO== SB2->B2_COD )
					If ( !SB2->B2_LOCAL $ cLocCq .And.;
					      SB2->B2_LOCAL <> SC6->C6_LOCAL .And.;
					      !BlqInvent(SB2->B2_COD,SB2->B2_LOCAL,,If(!__lPyme .Or. (FindFunction("LocalizS3") .And. LocalizS3()),SB2->B2_LOCALIZ,'')) .And.;
					      !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(SB2->B2_COD,SB2->B2_LOCAL,Nil,.F.)) )
						//Ŀ
						//Trava o SB2 dos Locais a serem Transferidos                             
						//					
						If RecLock("SB2")
							nSldSb2 := SaldoSb2(,Empty(aEmpBN) .And. GetMv("MV_QEMPV"),,SF4->F4_PODER3<>"N" .Or. (SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3)))
							If ( aEmpenho <> Nil )
								For nRegEmp := 1 To Len(aEmpenho[2])
									If aEmpenho[2][nRegEmp][1] == SB2->(RecNo())
										If Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL) .Or.;
												aEmpenho[2][nRegEmp][3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL
											nSldSB2 -= aEmpenho[2][nRegEmp][2] //B2_RESERVA
										EndIf
									EndIf
								Next nRegEmp
							EndIf
							If ( nSldSb2<>0 )
								AAdd(aLocal, { SB2->B2_LOCAL , Min(nSldSb2,nQtdLib-nSaldo) } )
								nSaldo += Min(nSldSb2,aLocal[Len(aLocal),2])
								If ( nQtdLib <= nSaldo .Or. (lliber .And. nSaldo > 0))	
									nQtdLib  := nSaldo
									lRetorno := .T.
									Exit
								EndIf
							EndIf
						EndIf
					EndIf
					dbSelectArea("SB2")
					dbSkip()
				EndDo
			EndIf
		Else
			lRetorno := .F.
		EndIf
		
		If !Empty(aEmpBN) .And. nSaldo < If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN)
			A410LibBen(2,aEmpBN[1,1],aEmpBN[1,2],If(nQtdEmp < SC6->C6_QTDVEN,nQtdEmp,SC6->C6_QTDVEN) - If(lLiber,nSaldo,0))
		EndIf
	Else
		lRetorno := .T.
	EndIf
EndIf

Return(lRetorno)

/*/

Ŀ
Funo     A440Qtdl  Autor  Claudinei M. Benzi     Data  22.01.92 
Ĵ
Descrio  Consiste qtde liberada se maior que qtde vendida           
Ĵ
 Uso       Mata440                                                    
ٱ


/*/
Function A440Qtdl(nQuant)

Local aTam      := TamSX3("C6_QTDVEN")

Local cLote     := ""
Local cProduto  := ""
Local cLocal    := ""
Local cItem     := ""
Local cSeek     := ""
Local cAlias    := Alias()
Local cGrade    := ""
Local cReserv   := ""
Local cLoteCtl  := ""
Local cLocaliza := ""
Local cNumSerie := ""
Local cProjeto  := ""
Local cTarefa   := ""
Local cServico  := ''

Local nSaldo    := 0
Local nQtdRese  := 0
Local nQtdEnt   := 0
Local nx        := 0
Local nQtdLib   := 0
Local nQtdVen   := 0

Local lRsDoFAt  := IIF(SuperGetMv("MV_RSDOFAT") == "S",.F.,.T.)
Local lBloq     := .F.
Local lGrade    := MaGrade()
Local lMata410  := AtIsRotina("MATA410")

nQtdLib := IF(nQuant == NIL .Or. ValType(nQuant) # "N",&(ReadVar()),nQuant)

For nx=1 to Len(aHeader)
	If Trim(aHeader[nX][2]) == "C6_ITEM"
		cItem := aCols[n][nx]
	ElseIf Trim(aHeader[nx][2]) == "C6_BLQ"
		If ( AllTrim(acols[n][nx]) $ "RS" )
			lBloq := .T.
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_PRODUTO"
		cProduto := aCols[n][nx]
		//Ŀ
		// Verifica se a grade esta ativa, e se o produto digitado e'   
		// uma referencia                                               
		//
		If lGrade
			MatGrdPrrf(@cProduto)
		Endif
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCAL"
		cLocal := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMLOTE"
		cLote := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOTECTL"
		cLoteCtl := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_LOCALIZ"
		cLocaliza := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_NUMSERI"
		cNumSerie := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDVEN"
		nQtdVen := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_QTDENT"
		nQtdEnt := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_GRADE"
		cGrade := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TES"
		cTes := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_RESERVA"
		cReserv := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_PROJPMS"
		cProjeto := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_TASKPMS"
		cTarefa := aCols[n][nx]
	ElseIf Trim(aHeader[nX][2]) == "C6_SERVIC"
		cServico:= aCols[n][nx]
	EndIf
Next nX

If ( lBloq .And. lRsDoFat .and. nQtdLib > 0  )
	Help(" ",1,"A410ELIM")
	Return .F.
Endif

If SuperGetMv("MV_LIBACIM") .And. nQtdLib > 0
	If ( INCLUI )
		If Round(nQtdLib,aTam[2]) > Round(nQtdVen,aTam[2])
			HELP(" ",1,"A440QTDL")
			Return .F.
		EndIf
	Else
		If !lGrade  .Or. cGrade <> "S"
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+M->C5_NUM+cItem)
			If !lMata410
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(C6_QTDVEN - (C6_QTDEMP+C6_QTDENT),aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Else
				If Found() .And. Round(nQtdLib,aTam[2]) > Round(nQtdVen - C6_QTDENT,aTam[2])
					HELP(" ",1,"A440QTDL")
					Return .F.
				Endif
			Endif
		Endif
	EndIf
Endif
//Ŀ
//Caso movimente Estoque em Quantidade                                    
//
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+cTes)
If ( SF4->F4_ESTOQUE == "S" .And. !(M->C5_TIPO$"CIP") .And. !Empty(cReserv) )
	//Ŀ
	//Validacao para Reserva                                   
	//
	If ( INCLUI )
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
			nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
		EndIf
	Else
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			If ( cReserv == SC6->C6_RESERVA )
				nQtdRese := Min(SC6->C6_QTDRESE,nQtdLib)
			Else
				dbSelectArea("SC0")
				dbSetOrder(1)
				If ( MsSeek(xFilial("SC0")+cReserv+cProduto+cLocal) )
					nQtdRese := Min(SC0->C0_QUANT,nQtdVen)
				EndIf
			EndIf
		EndIf
	EndIf
	If ( NoRound(nQtdLib,aTam[2]) > NoRound(nQtdRese,aTam[2]) )
		Help(" ",1,"A440RESE01",,Str(nQtdRese),03,20)
		Return(.F.)
	EndIf
Else
	If ((Rastro(cProduto) .Or. Localiza(cProduto)) .And. !(M->C5_TIPO $ "CIP") .And. SF4->F4_ESTOQUE == "S" ) .And. SuperGetMv("MV_GERABLQ")=="N"
		nSaldo := SldAtuEst(cProduto,cLocal,nQtdLib,cLoteCtl,cLote,cLocaliza,cNumSerie,cReserv,SF4->F4_PODER3<>"N" .Or. (SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3)),NIL,cProjeto,cTarefa,cServico)
		dbSelectArea("SC6")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC6")+M->C5_NUM+cItem+cProduto,.F.) )
			nSaldo += SC6->C6_QTDEMP
		EndIf
		If ( nSaldo < nQtdLib )
			If ( Localiza(cProduto) )
				Help(" ",1,"SALDOLOCLZ")
				Return(.F.)
			EndIf
			If ( Rastro(cProduto) )
				Help(" ",1,"A440ACILOT")
				Return(.F.)
			EndIf
		EndIf
	EndIf
EndIf
//Ŀ
// S permitir alterar a quantidade quando esta for maior que a 
// quantidade entregue, somente para outros paises...           
//Lucas
If cPaisLoc <> "BRA"
	If nQtdLib < nQtdEnt
		Help(" ",1,"CANTRESERV")
		Return(.F.)
	EndIf
EndIf
dbSelectArea(cAlias)
Return( .T. )

/*

Ŀ
Funo    A440GeraD3 Autor Rodrigo de A. Sartorio  Data  29/12/97 
Ĵ
Descrio  Gera o registro de producao                                
Ĵ
 Uso       MATA440                                                    
ٱ


*/
Function A440GeraD3(cIdent)
Local cTm := SuperGetMv("MV_TMPAD")
cIdent:=IIf(cIdent == NIL,Criavar("D3_IDENT"),cIdent)
dbSelectArea("SB1")
MsSeek(xFilial("SB1")+SC2->C2_PRODUTO)
RecLock("SD3",.T.)
Replace D3_FILIAL    With xFilial("SD3")
Replace D3_TM        With cTm
Replace D3_OP        With SC2->C2_NUM+SC2->C2_ITEM+SC2->C2_SEQUEN+SC2->C2_ITEMGRD
Replace D3_COD       With SC2->C2_PRODUTO
Replace D3_QUANT     With SC2->C2_QUANT
Replace D3_QTSEGUM   With ConvUM(SD3->D3_COD, SC2->C2_QUANT, 0, 2)
Replace D3_PERDA     With 0
Replace D3_UM        With SC2->C2_UM
Replace D3_PARCTOT   With "T"
Replace D3_LOCAL     With SC2->C2_LOCAL
Replace D3_CC        With SC2->C2_CC
Replace D3_CONTA     With SB1->B1_CONTA
Replace D3_EMISSAO   With dDataBase
Replace D3_DOC       With SC2->C2_NUM
Replace D3_NIVEL     With SC2->C2_NIVEL
Replace D3_IDENT     With cIdent
If Rastro(SD3->D3_COD)
	If Rastro(SD3->D3_COD,"S")
		Replace D3_NUMLOTE With NextLote(SD3->D3_COD,"S")
	EndIf
	If Rastro(SD3->D3_COD,"S")
		Replace D3_LOTECTL With "AUTO"+D3_NUMLOTE
	Else
		Replace D3_LOTECTL With NextLote(SD3->D3_COD,"S")
	EndIf
EndIf
MsUnlock()
Return

/*


Ŀ
Funo     A460Especie Autor  Juan Jose Pereira    Data  14/10/96 
Ĵ
Descrio  Busca tipo de documento fiscal utilizado para gerar nota   
Ĵ
 Uso       MATA460                                                    
ٱ


*/
Function A460Especie(cSerie)
Local cSvAlias:=Alias(), cTiposDoc:=Alltrim(SuperGetMv('MV_ESPECIE')),;
	cEspecie:=Space(5),nLinhas:=0,nL:=0,nPosSign:=0

If cTiposDoc<>NIL
	cTiposDoc:=StrTran(cTiposDoc,";",chr(13)+chr(10))
	nLinhas:=MLCount(cTiposDoc)
	For nL:=1 to nLinhas
		cEspecie:=Alltrim(StrTran(MemoLine(cTiposDoc,,nL),Chr(13),Chr(10)))
		nPosSign:=Rat("=",cEspecie)
		If nPosSign>0 .and. Alltrim(cSerie)==Alltrim(Substr(cEspecie,1,nPosSign-1)) // Heverson
			cEspecie:=Substr(cEspecie,nPosSign+1)
			SX5->(MsSeek(xFilial("SX5")+"42"+cEspecie))
			If SX5->(!Found())
				cEspecie:=Space(5)
			Endif
			Exit
		Else
			cEspecie:=Space(5)
		Endif
	Next
Endif
dbSelectArea(cSvAlias)
Return(cEspecie)
/*


Ŀ
Funo     A460EspVol  Autor  Juan Jose Pereira    Data  23/01/97 
Ĵ
Descrio  Cria uma pilha com Especies e Volumes dos Pedidos de Venda 
Ĵ
 Uso       MATA460                                                    
ٱ


*/
Function A460EspVol()
Local cAlias:=Alias(),i,cEspecie,nVolumes,cCampo,nPosVol,nPosEsp

If aEspVol==NIL
	aEspVol:={}
Endif

dbSelectArea("SC5")
For i:=1 to FCount()
	cCampo:=FieldName(i)
	If Substr(cCampo,1,9)=="C5_ESPECI".and.IsDigit(Substr(cCampo,10,1))
		cEspecie:=FieldGet(i)
		If Empty(cEspecie)
			Loop
		Endif
	Else
		Loop
	Endif
	nPosVol:=FieldPos("C5_VOLUME"+Substr(cCampo,10,1))
	If nPosVol>0
		nVolumes:=FieldGet(nPosVol)
	Else
		nVolumes:=0
	Endif
	nPosEsp:=Ascan(aEspVol,{|x|x[1]==Upper(cEspecie)})
	If nPosEsp==0
		AAdd(aEspVol,{Upper(cEspecie),nVolumes})
	Else
		aEspVol[nPosEsp,2]+=nVolumes
	Endif
Next i
dbSelectArea(cAlias)
Return
/*


Ŀ
Funo    A460GrvEspVolAutor  Juan Jose Pereira    Data  24/01/97 
Ĵ
Descrio Grava pilha com Especies e Volumes dos Pedidos              
Ĵ
 Uso       MATA460                                                    
ٱ


*/
Function A460GravaEspVol(aEspVol)
Local i
For i:=1 to Len(aEspVol)
	cCpoEspF2:="F2_ESPECI"+Alltrim(Str(i))
	cCpoVolF2:="F2_VOLUME"+Alltrim(Str(i))
	If FieldPos(cCpoEspF2)==0.or.FieldPos(cCpoVolF2)==0
		Loop
	Endif
	FieldPut(FieldPos(cCpoEspF2),aEspVol[i,1])
	FieldPut(FieldPos(cCpoVolF2),aEspVol[i,2])
Next
Return

/*


Ŀ
Funo     A460Rateio  Autor  Ben-Hur M Castilho   Data  26/11/96 
Ĵ
Descrio  Ajuste dos Centavos dos Valores de Rateio                  
Ĵ
 Uso       MATA460                                                    
ٱ


*/
Function A460Rateio( aVetor,xValor,xAliq )
Local nAux01 := 0,;
	nAux02 := 0,;
	nCnt01 := 0

xAliq:=If(xAliq==NIL,100,xAliq)

If (ValType( xValor ) == "A")
	If Valtype(xAliq)=="A"
		For nCnt01:=1 To Len(xValor)
			nAux01+=(xValor[nCnt01]*xAliq[nCnt01]/100)
		Next
	Else
		For nCnt01 := 1 To Len( xValor )
			nAux01 += xValor[nCnt01]*xAliq/100
		Next
	Endif
Else
	Aeval(aVetor,{|x|nAux01+=x})
EndIf
Aeval(aVetor,{|x|nAux02+=Noround(x,2)})
Return( Noround(aTail( aVetor ),2)+(nAux01-nAux02) )

/*


Ŀ
Funo    A460UltElem  Autor  Juan Jose Pereira    Data  13/05/97 
Ĵ
Descrio Verifica qual o ultimo elemento do aTots que e' mercadoria  
Ĵ
 Uso       MATA460                                                    
ٱ


*/
FUNCTION A460UltElem(aTots)
Local i:=0, lExiste:=.F.

For i:=Len(aTots) to 1 step -1
	If !aTots[i,13]=="S" // Se item nao e' de servico
		lExiste:=.T.
		Exit
	Endif
Next i

If !lExiste
	i:=0
Endif

Return (i)
/*


Ŀ
Funo     A460Marca Autor  Rodrigo de A. Sartorio  Data  29/07/97 
Ĵ
Descrio  Monta regua para indicar que os Pedidos estao sendo marcados
Ĵ
Uso        MATA460                                                     
ٱ


*/
Function A460Marca(cMarca)
ProcRegua(RecCount())
Do While !Eof()
	RecLock("SC9",.F.)
	Replace C9_OK With cMarca
	MsUnlock()
	dbSkip()
	IncProc()
EndDo
Return

/*/


Ŀ
Funcao    a460Estorn Autor Eduardo Riera           Data 31.03.99  
Ĵ
Descrio Efetua o estorno da liberacao do pedido de venda            
Ĵ
Retorno   ExpL1: Indica se houve o estorno                            
Ĵ
ParametrosExpL1: Indica se o programa chamador eh o MATA410           
			 ExpL2: Indica se Atualizar Empenhos				          
          ExpN3: Valor a ser adicionado ao limite de credito          
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
16/05/2007Norbert Waage  Bops 125161 - Atualizacao do status do orca-
                         mento no Televendas (SIGATMK) apos estorno. 
ٱ


/*/
Function A460Estorna(lMata410,lAtuEmp,nVlrCred)

Local aArea       := GetArea()
Local aAux        := {}
Local lContinua   := .T.
Local lDeletaDCF  := .F.
Local lIntACD 	  := SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local aEmpBN	  := If(FindFunction("A410CarBen"),A410CarBen(SC9->C9_PEDIDO,SC9->C9_ITEM),{})

//- Status dos Bloqueios do pedido de venda. Se .T. DCF gerado, tem que estornar.
If Type("lbloqDCF") <> "L"
	lbloqDCF := .F.
EndIf

//Ŀ
//Verifica os parametros defaults                                         
//
lMata410 := If(lMata410==Nil,.F.,lMata410)
//Ŀ
// Integracao com o  ACD - Faz validacao do estorno da liberacao dos PV's  	  
//
If lContinua .And. lIntACD .And. FindFunction("CBMT460EST")
	lContinua := CBMT460EST()
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
//Ŀ
//Pontos de Entrada                                                       
//
ElseIf lContinua .And. (ExistTemplate("MT460EST",.F.,.F.))
	lContinua := ExecTemplate("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//Ŀ
//Pontos de Entrada                                                       
//
If lContinua .And. ( ExistBlock("MT460EST",.F.,.F.) )
	lContinua := ExecBlock("MT460EST",.F.,.F.)
	If ValType(lContinua) # "L"
		lContinua:=.T.
	EndIf
EndIf

//Ŀ
//Atualiza o orcamento do Televendas, se foi originado a partir
//dele no modulo Call Center (SIGATMK)                         
//
If lContinua
	TkAtuTlv(SC9->C9_PEDIDO,1,,,,.T.)
EndIf

//Ŀ
//Posiciona Registros e trava registros                                   
//
dbSelectArea("SC9")
lContinua := lContinua .And. RecLock("SC9")
If ( lContinua )
	lDeletaDCF := .F.
	//Ŀ
	//Restaura empenhos relacionados a remessa para beneficiamento 
	//
	If !Empty(aEmpBN) .And. Empty(SC9->C9_BLEST)
		A410LibBen(2,aEmpBN[1,1],aEmpBN[1,2],SC9->C9_QTDLIB,SC9->C9_QTDLIB2)
	EndIf
	FatAtuEmpN("-",,,.T.)
	// --- 2.Estorno do SC9 / Estorno da Liberacao de 6.Estoque/4.Credito do SC9 / WMS
	MaAvalSC9("SC9",2,,,,,lAtuEmp,,@nVlrCred,,lDeletaDCF)
	// --- 8.Estorno Mont.Carga
	lDeletaDCF := .T.
	If	lbloqDCF
		lDeletaDCF := .F.
	EndIf
	MaAvalSC9("SC9",8,,,,,,,,,lDeletaDCF)
	//Ŀ
	//Deleta o Registro no SC9                                                
	//
	dbSelectArea("SC9")
	RecLock("SC9")
	SC9->C9_BLCRED := If(SC9->C9_BLCRED=="05","",SC9->C9_BLCRED)
	dbDelete()
	//Ŀ
	//Executa o ExecBlock                                                     
	//
	dbSelectArea("SC9")
	If ( !lMata410 )
		If (ExistBlock("M460DEL"))
			ExecBlock("M460DEL",.f.,.f.)
		EndIf
	EndIf

	//Ŀ
	// O SC6 eh posicionado na funcao maavalsc9                               
	//
	If SuperGetMv("MV_DELRES") .And. !Empty(SC6->C6_RESERVA) .And. SC6->C6_QTDEMP == 0
		dbSelectArea("SC0")
		dbSetOrder(1)
		If ( MsSeek(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL,.F.) )
			MaAvalSC6("SC6",2,"SC5")

			aAux := {SC6->C6_NUMLOTE,SC6->C6_LOTECTL,SC6->C6_LOCALIZ,SC6->C6_NUMSERI}
			If GetNewPar("MV_DELRES2",.F.)
				RecLock("SC6")
				SC6->C6_NUMLOTE := ""
				SC6->C6_LOTECTL := ""
				SC6->C6_LOCALIZ := ""
				SC6->C6_NUMSERI := ""
			EndIf

			MaAvalSC6("SC6",1,"SC5")

			If GetNewPar("MV_DELRES2",.F.)
				RecLock("SC6")
				SC6->C6_NUMLOTE := aAux[1]
				SC6->C6_LOTECTL := aAux[2]
				SC6->C6_LOCALIZ := aAux[3]
				SC6->C6_NUMSERI := aAux[4]
			EndIf

		Else
			//Ŀ
			//Caso a Reserva foi depurada       
			//
			dbSelectArea("SB2")
			RecLock("SB2")
			SB2->B2_RESERVA -= SC6->C6_QTDRESE
			SB2->B2_RESERV2 -= ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			SB2->B2_QPEDVEN += SC6->C6_QTDRESE
			SB2->B2_QPEDVE2 += ConvUM(SB2->B2_COD, SC6->C6_QTDRESE, 0, 2)
			dbSelectArea("SC6")
			RecLock("SC6")
			SC6->C6_QTDRESE := 0
			SC6->C6_RESERVA := ""
		EndIf
	ElseIf !lMata410  
		//Ŀ
		// Se nao existir controle de reserva e o estorno da liberacao estiver sendo 
		// feito pela rotina MATA461, verifica se houve transferencia entre almoxari-
		// fados e executa o estorno da transferencia.    							  
		//
	 	MaTrfLocal(SC6->C6_PRODUTO, , , ,SC6->C6_NUM,.T.)	
	EndIf
	FatAtuEmpN("+")
EndIf
RestArea(aArea)
Return(lContinua)

/*/


Ŀ
Funcao    AtTrfEqpto Autor  Eduardo Riera          Data 05.01.98  
Ĵ
Descrio  Transferencia de Cliente x Equipamento                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros cCodFab: Codigo do Fabricante                              
           cLojaFa: Loja do Fabricante                                
           cCodPro: Codigo do Produto                                 
           cNumSer: Numero de Serie                                   
           cCodCli: Codigo do Cliente                                 
           cLoja  : Loja do Cliente                                   
           aHeadA4: aHeader do AA4 (Somente Inclusao)                 
           aColsA4: aCols do AA4 ( Somente Inclusao )                 
           aEnchoi: Vetor com os campos a serem atualizados           
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function AtTrfEqpto(cCodFab,cLojaFa,cCodPro,cNumSer,cCodCli,cLoja,aHeadAA4,aColsAA4,aEnchoice)

Local aArea       := GetArea()
Local nOpcao      := 0
Local aSavaHead   := If(Type("aHeader")=="U",{},aHeader)
Local aSavaCols   := If(Type("aCols")=="U",{},aCols)
Local aSavN       := If(Type("N")=="U",1,N)
Local nCntFor     := 0
Private aHeader   := {}
Private aCols     := {}
Private uCampo    := ""

aEnchoice := If(aEnchoice==Nil,{},aEnchoice)

dbSelectArea("AA3")
dbSetOrder(4)
If ( MsSeek(xFilial("AA3")+cCodFab+cLojaFa+cCodPro+cNumSer) )
	nOpcao := 4
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		If ( SX3->X3_CONTEXT=="V" )
			M->&(uCampo) := CriaVar(SX3->X3_CAMPO,.F.)
		Else
			M->&(uCampo) := AA3->(FieldGet(FieldPos(SX3->X3_CAMPO)))
		EndIf
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
Else
	//Ŀ
	//Verifica se ha componentes a serem considerados                         
	//
	If ( aColsAA4 <> Nil .And. aHeadAA4 <> Nil )
		aCols   := aClone(aColsAA4)
		aHeader := aClone(aHeadAA4)
	EndIf
	nOpcao := 1
	//Ŀ
	//Inicializa as Variaveis necessarias a gravacao                          
	//
	dbSelectArea("SX3")
	dbSetOrder(1)
	MsSeek("AA3")
	While ( !Eof() .And. (SX3->X3_ARQUIVO == "AA3") )
		uCampo := SX3->X3_CAMPO
		M->&(uCampo) := CriaVar(SX3->X3_CAMPO,If(SX3->X3_CONTEXT=="V",.F.,.T.))
		dbSelectArea("SX3")
		dbSkip()
	EndDo
	//Ŀ
	//Preenche as Variaveis Necessarias                                       
	//
	M->AA3_CODCLI  := cCodCli
	M->AA3_LOJA    := cLoja
	M->AA3_CODPRO  := cCodPro
	M->AA3_NUMSER  := cNumSer
	M->AA3_DTVEND  := SD2->D2_EMISSAO
	M->AA3_CODFAB  := cCodFab
	M->AA3_LOJAFA  := cLojaFa
	M->AA3_NFVEND  := SD2->D2_DOC
	M->AA3_CONTRT  := ""
	M->AA3_DTGAR   := &(SuperGetMv("MV_FORMGAR"))
	For nCntFor := 1 To Len(aEnchoice)
		uCampo := aEnchoice[nCntFor][1]
		M->&(uCampo) := aEnchoice[nCntFor][2]
	Next nCntFor
	At040Grava(nOpcao,cCodCli,cLoja)
EndIf
//Ŀ
//Retorna as condicoes de entrada                                         
//
aCols   := aSavACols
aHeader := aSavAhead
N       := aSavN
RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funo    At040Grava Autor  Eduardo Riera          Data  16/09/98 
Ĵ
Descrio  Programa de Gravacao  amarrao Cliente x Equipamento      
Ĵ
Sintaxe    Void At040Grava()                                          
Ĵ
Parametros ExpN1 = 1 - Inclui, 2 - Altera , 3 - Exclui                
Ĵ
 Uso       TECA040                                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
25/08/05  Henry F        Bops 85869 - Tratamento da gravacao do      
                         cliente anterior no campo AAF_LOGINI        
Ĵ
02/10/0600Conrado Q.     Bops 107368 - Localizacao dos acessorios do 
                         produto quando AA4 trabalha em modo exclu.  
ٱ


/*/
Function At040Grava(nOpcao,cCodCli,cLoja)

Local nCntFor		:= 0                      							//Variavel para For - Next
Local nCntFor2		:= 0												//Variavel para For - Next
Local nUsado		:= Len(aHeader)										//Tamanho do aHeader
Local aRecAA4		:= {}												//Array de registros da tabela AA4	
Local nPosProd		:= Ascan(aHeader,{|x| Trim(x[2])=="AA4_PRODAC" })	//Posicao do campo Produro no aHeader
Local bCampo		:= {|x| FieldName(x) }								//Bloco de codigo para pegar o nome do campo na gravacao			
Local nRegAA3		:= AA3->(RecNo())									//Array de registros da tabela AA3	
Local cPlano		:= ""												//Armazena codigo do plano de manutencao do parametr MV_ATPLANO
Local cCodCliAnt	:= ""												//Codigo do cliente anterior a alteracao do historico
Local cLojaCliAnt	:= ""												//Loja do cliente anterior a alteracao do historico

Local lGravou   := .T.

dbSelectArea("AA4")
dbSetOrder(1)
MsSeek(xFilial("AA4")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER)

While ( !Eof() .And. AA4->AA4_FILIAL==xFilial("AA4") .And.;
		AA4->AA4_CODCLI==M->AA3_CODCLI .And.;
		AA4->AA4_LOJA  ==M->AA3_LOJA   .And.;
		AA4->AA4_CODPRO==M->AA3_CODPRO .And.;
		AA4->AA4_NUMSER==M->AA3_NUMSER )
	AAdd(aRecAA4,RecNo())
	dbSelectArea("AA4")
	dbSkip()
EndDo
//Ŀ
//Bloco de Inclusao / Alteracao                                           
//
Do Case
Case ( nOpcao < 3 )
	//Ŀ
	// Grava arquivo AA3 (Cabecalho da Amarracao             
	//
	dbSelectArea("AA3")
	dbSetOrder(1)
	MsSeek(xFilial("AA3")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER)
	RecLock("AA3",!Found())
	For nCntFor := 1 To FCount()
		If ( "FILIAL"$Field(nCntFor) )
			FieldPut(nCntFor,xFilial("AA3"))
		Else
			FieldPut(nCntFor,M->&(EVAL(bCampo,nCntFor)))
		EndIf
	Next nCntFor
	//Ŀ
	//Grava os campos memos                                                   
	//
	MSMM(M->AA3_CODMEM,,,M->AA3_OBS,1,,,"AA3","AA3_CODMEM")
	AA3->( MsUnlock() )
	AA3->(FKCommit())
	//Ŀ
	// Grava Historico de Equipamento                      
	//
	dbSelectarea("AAF")
	dbSetOrder(1)
	If !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+M->AA3_CODPRO+M->AA3_NUMSER)
		Reclock("AAF",.T.)
		AAF->AAF_FILIAL := xFilial("AAF")
		AAF->AAF_CODCLI := M->AA3_CODCLI
		AAF->AAF_LOJA   := M->AA3_LOJA
		AAF->AAF_CODPRO := M->AA3_CODPRO
		AAF->AAF_NUMSER := M->AA3_NUMSER
		AAF->AAF_PRODAC := M->AA3_CODPRO
		AAF->AAF_NSERAC := M->AA3_NUMSER
		AAF->AAF_CODFAB := M->AA3_CODFAB
		AAF->AAF_LOJAFA := M->AA3_LOJAFA		
		AAF->AAF_DTINI  := dDataBase
		AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
		MsUnlock()
		AAF->(FKCommit())
	EndIf
	//Ŀ
	// Grava arquivo AA4 (itens da amarracao)              
	//
	dbSelectArea("AA4")
	For nCntFor := 1 To Len(aCols)
		If ( !aCols[nCntFor][nUsado+1] .And. !Empty(aCols[nCntFor][nPosProd]) )
			If ( nCntFor > Len(aRecAA4) )
				RecLock("AA4",.T.)
			Else
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
			EndIf
			For nCntFor2 := 1 To nUsado
				If ( aHeader[nCntFor2][10] <> "V" )
					FieldPut(FieldPos(aHeader[nCntFor2][2]),aCols[nCntFor][nCntFor2])
				EndIf
			Next nCntFor2
			AA4->AA4_FILIAL:= xFilial("AA4")
			AA4->AA4_CODCLI:= M->AA3_CODCLI
			AA4->AA4_LOJA  := M->AA3_LOJA
			AA4->AA4_CODPRO:= M->AA3_CODPRO
			AA4->AA4_NUMSER:= M->AA3_NUMSER
			//Ŀ
			// Atualiza historico dos acessorios                                   
			//
			dbSelectArea("AAF")
			dbSetOrder(1)
			If ( !MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
				Reclock("AAF",.T.)
				AAF->AAF_FILIAL := xFilial("AAF")
				AAF->AAF_CODCLI := M->AA3_CODCLI
				AAF->AAF_LOJA   := M->AA3_LOJA
				AAF->AAF_CODPRO := M->AA3_CODPRO
				AAF->AAF_NUMSER := M->AA3_NUMSER
				AAF->AAF_PRODAC := AA4->AA4_PRODAC
				AAF->AAF_NSERAC := AA4->AA4_NSERAC
				AAF->AAF_DTINI  := dDataBase
				AAF->AAF_CODFAB := M->AA3_CODFAB
				AAF->AAF_LOJAFA := M->AA3_LOJAFA
				AAF->AAF_LOGINI := STR0001 // # "CADASTRO AMARRACAO CLIENTE X EQPTO"
				MsUnlock()
			EndIf
		Else
			If ( nCntFor <= Len(aRecAA4) )
				AA4->(MsGoto(aRecAA4[nCntFor]))
				RecLock("AA4",.F.)
				dbDelete()
				dbSelectArea("AAF")
				dbSetOrder(1)
				If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
					Reclock("AAF",.F.)
					AAF->AAF_DTFIM  := dDataBase
					AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
				EndIf
			EndIf
		EndIf
	Next nCntFor
	AA4->(FKCommit())	
	AAF->(FKCommit())	

	//Ŀ
	//Altera o Status da equipamento                                          
	//
	AtEqStatus(FunName())
	//Ŀ
	//Expande o Plano de Manutencao quando for inclusao                       
	//
	If ( nOpcao == 1 )
		cPlano := &(SuperGetMv("MV_ATPLANO"))
		If ( !Empty(cPlano) )
			AtExpPlano( cPlano )
		EndIf
	EndIf

Case nOpcao == 3
	//Ŀ
	//Bloco de Exclusao                                                       
	//
	For nCntFor := 1 To Len(aRecAA4)
		dbSelectArea("AA4")
		MsGoto(aRecAA4[nCntFor])
		//Ŀ
		//Atualiza historico dos acessorios                                  
		//
		dbSelectarea("AAF")
		dbSetOrder(1)
		If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER+AA4->AA4_PRODAC+AA4->AA4_NSERAC) )
			Reclock("AAF",.F.)
			AAF->AAF_DTFIM  := dDataBase
			AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
		EndIf
		dbSelectArea("AA4")
		RecLock("AA4")
		dbDelete()
	Next nCntFor
	AAF->(FKCommit())	
	AA4->(FKCommit())	
	//Ŀ
	// Deleta o cabecalho do contrato (amarracao).                  
	//
	dbSelectarea("AAF")
	dbSetOrder(1)
	If ( MsSeek(xFilial("AAF")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER) )
		Reclock("AAF",.F.)
		AAF->AAF_DTFIM  := dDataBase
		AAF->AAF_LOGFIM := STR0002 // # "EXCLUIDO PELA AMARRACAO"
	EndIf
	//Ŀ
	// Deleta localizacao fisica 
	//
	If AliasInDic("AGW")
		AGW->(dbSetOrder(3))
		If AGW->(dbSeek(xFilial("AGW")+M->AA3_CODCLI+M->AA3_LOJA+M->AA3_CODPRO+M->AA3_NUMSER))
			RecLock("AGW",.F.)
			AGW->(dbDelete())
			AGW->(MsUnLock())
		EndIf
	EndIf
	MSMM(M->AA3_CODMEM,,,,2)
	dbSelectArea("AA3")
	RecLock("AA3",.F.,.T.)
	dbDelete()
	AA3->(FKCommit())	

Case ( nOpcao == 4 )
	lGravou := .F.

	dbSelectArea("SA1")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
		dbSelectArea("AA3")
		dbSetOrder(1)
		If ( !MsSeek(xFilial("AA3")+cCodCli+cLoja+AA3->AA3_CODPRO+AA3->AA3_NUMSER) )
			MsGoto(nRegAA3)

			//Ŀ
			//Armazena codigo do cliente e loja antes de gravar o AA3
			//
			cCodCliAnt	:= AA3->AA3_CODCLI
			cLojaCliAnt	:= AA3->AA3_LOJA

			//Ŀ
			// Atualiza a base instalada                                         
			//
			dbSelectArea("AA3")
			RecLock("AA3",.F.)
			AA3->AA3_CODCLI := cCodCli
			AA3->AA3_LOJA   := cLoja
			AA3->AA3_CONTRT := ""
			AA3->AA3_CTAPRE := ""
			AA3->AA3_DTCTAM := Ctod("")

			//Ŀ
			//Bloco de Transferencia                                                  
			//
			For nCntFor := 1 To Len(aRecAA4)
				dbSelectArea("AA4")
				MsGoto(aRecAA4[nCntFor])
				//Ŀ
				//Atualiza historico dos acessorios                                  
				//
				dbSelectArea("AA4")
				RecLock("AA4")
				AA4->AA4_CODCLI := cCodCli
				AA4->AA4_LOJA   := cLoja
			Next nCntFor

			//Ŀ
			// Atualiza o historico do equipamento                               
			//
			Reclock("AAF",.T.)
			AAF->AAF_FILIAL := xFilial("AAF")
			AAF->AAF_CODCLI := cCodCli
			AAF->AAF_LOJA   := cLoja
			AAF->AAF_CODPRO := AA3->AA3_CODPRO
			AAF->AAF_NUMSER := AA3->AA3_NUMSER
			AAF->AAF_PRODAC := AA3->AA3_CODPRO
			AAF->AAF_NSERAC := AA3->AA3_NUMSER
			AAF->AAF_DTINI  := dDataBase
			AAF->AAF_CODFAB := AA3->AA3_CODFAB
			AAF->AAF_LOJAFA := AA3->AA3_LOJAFA
			AAF->AAF_LOGINI := Left( STR0003 + cCodCliAnt + "/" + ;
								cLojaCliAnt + STR0004 + cCodCli + "/" + cLoja, Len( AAF->AAF_LOGINI ) ) // # "TRANSFERENCIA DE CLIENTE/LOJA " ## " PARA "
			AAF->( MsUnlock() )

			lGravou := .T.

		Else
			If ( nModulo == 28 ) // Variavel Public
				Help(" ",1,"AT040INC01")
			EndIf
			lGravou := .F.
		EndIf
	Else
		If ( nModulo == 28 ) // Variavel Public
			Help(" ",1,"RECNOIS")
		EndIf
		lGravou := .F.
	EndIf
	//Ŀ
	//Altera o Status do equipamento                                          
	//
	AtEqStatus(FunName())
EndCase
//Ŀ
// Limpa variaveis de campos virtuais                  
//
M->AA3_DESPRO := ""
M->AA3_NOMCLI := ""
M->AA3_NOMTEC := ""

AA3->( MsUnlock() )

//Ŀ
// Executa o ponto de entrada                          
//
If lGravou
	If ExistBlock( "AT040GRV" )
		ExecBlock( "AT040GRV", .F., .F., { nOpcao } )
	EndIf
EndIf

Return .T.

/*/


Ŀ
Funcao    SldAtuEst  Autor  Eduardo Riera          Data  01.02.99 
Ĵ
Descrio Avalia os saldo por Almoxarifado, Lote e Localizacao,       
          ate a quantidade informada no parametro (3).                
Ĵ
Retorno   ExpN1: Quantidade em estoque disponivel                     
Ĵ
ParametrosExpC1: Codigo do Produto         - Obrigatorio              
          ExpC2: Local                     - Obrigatorio              
          ExpC3: Quantidade                - Obrigatorio              
          ExpC4: Lote de Controle          - Obrig. se Inf. Sub-Lote  
          ExpC5: Sub-Lote                                             
          ExpC6: Localizacao               - Obrig. se inf. Nr.Serie  
          ExpC7: Numero de Serie                                      
          ExpC8: Reserva                                              
          ExpL9: Indica se considera poder de terceiro                
          ExpLA: Indica se considera poder em terceiro                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function SldAtuEst(cCodPro,cLocal,nQtd,cLoteCtl,cNumLote,cLocaliz,cNumSer,cReserva,lConsTerc,lConsQNPt,cProjeto,cTarefa,cServico,lPrdBn)

Local cLoteSb8  := ""
Local cNumLSb8  := ""

Local cAliasSB8 := "SB8"
Local cAliasSBF := "SBF"

Local nSaldo    := 0
Local nEmpenho  := 0

Local nQtdSB8   := 0
Local nReserva  := 0
Local nReservaSB8:= 0
Local lContSB8  := .T.
Local lContSBF  := .T.
Local lUsaVenc  := .F.
Local lQuery    := .F.
Local lLocaliza := Localiza(cCodPro)
Local nRecSb8   := 0
Local lEmpPrev  := If(SuperGetMV("MV_QTDPREV")== "S",.T.,.F.)
Local lQEmpNF	:= GetNewPar("MV_QEMPNF",.F.)	//Considera o campo B2_QEMPN no calculo do Saldo
Local lAtuSGJ   := SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")

#IFDEF TOP
	Local aStruSB8  := {}
	Local aStruSBF  := {}
	Local cQuery    := ""
	Local nX        := 0
#ENDIF

DEFAULT lConsQNPT := .F.
DEFAULT cProjeto	:= ""
DEFAULT cTarefa		:= ""
DEFAULT cServico    := ""
DEFAULT lPrdBn		:= .F.

If lAtuSGJ
	lQEmpNF	:= .F.
Endif

//Ŀ
//Analisa os dados de entrada da funcao                                   
//
cLoteCtl  := If(cLoteCtl == NIL .Or. Empty(cLoteCtl),"",cLoteCtl)
cNumLote  := If(cNumLote == NIL .Or. Empty(cNumLote) .Or. Rastro(cCodPro,"L"),"",cNumLote)
cLocaliz  := If(cLocaliz == NIL .Or. Empty(cLocaliz),If(!Empty(cNumSer),Space(Len(SBF->BF_LOCALIZ)),""),cLocaliz)
cNumSer   := If(cNumSer  == NIL .Or. Empty(cNumSer) ,"",cNumSer)
lUsaVenc  := If(!Empty(cLoteCtl+cNumLote),.T.,(SuperGetMv('MV_LOTVENC')=='S'))

If !BlqInvent(cCodPro,cLocal,,If(!__lPyme .Or. (FindFunction("LocalizS3") .And. LocalizS3()),cLocaliz,'')) .And. !(FindFunction('AvalBlqLoc') .And. AvalBlqLoc(cCodPro,cLocal,Nil,.F.))
	If ( Empty(cReserva) )
		//Ŀ
		//Verifica os Saldos por Lote / Sub-Lote / Localizacao                    
		//
		If ( Rastro(cCodPro) ) .And. Empty(cServico)
			dbSelectArea("SB8")
			dbSetOrder(3)
			#IFDEF TOP
				SB8->(dbCommit())

				lQuery    := .T.
				cAliasSB8 := "SLDATUEST"
				aStruSB8  := SB8->(dbStruct())

				For nX := 1 To Len(aStruSB8)
					cQuery += ",SB8."+aStruSB8[nX][1]
				Next nX
				If lLocaliza
					SBF->(dbCommit())
					cAliasSBF := "SLDATUEST"
					aStruSBF  := SBF->(dbStruct())
					For nX := 1 To Len(aStruSBF)
						cQuery += ",SBF."+aStruSBF[nX][1]
					Next nX
				EndIf

				cQuery    := "SELECT "+SubStr(cQuery,2)+" "
				cQuery    += ",SB8.R_E_C_N_O_ SB8RECNO "
				cQuery    += "FROM "+RetSqlName("SB8")+" SB8 "
				If lLocaliza
					cQuery += ","+RetSqlName("SBF")+" SBF "
				EndIf
				cQuery    += "WHERE SB8.B8_FILIAL='"+xFilial("SB8")+"' AND "
				cQuery    += "SB8.B8_PRODUTO='"+cCodPro+"' AND "
				cQuery    += "SB8.B8_LOCAL='"+cLocal+"' AND "
				If !Empty(cLoteCtl)
					cQuery    += "SB8.B8_LOTECTL='"+cLoteCtl+"' AND "
				EndIf
				If !Empty(cNumLote)
					cQuery    += "SB8.B8_NUMLOTE='"+cNumLote+"' AND "
				EndIf

				cQuery    += "SB8.B8_SALDO > 0 AND SB8.D_E_L_E_T_ = ' ' "
				If lLocaliza
					cQuery    += " AND SBF.BF_FILIAL='"+xFilial("SBF")+"' AND "
					cQuery    += "SBF.BF_PRODUTO='"+cCodPro+"' AND "
					cQuery    += "SBF.BF_LOCAL='"+cLocal+"' AND "
					cQuery    += "SBF.BF_LOTECTL=SB8.B8_LOTECTL AND "
					If !Empty(cNumLote)
						cQuery    += "SBF.BF_NUMLOTE=SB8.B8_NUMLOTE AND "
					EndIf
					cQuery    += "SBF.D_E_L_E_T_=' ' "
					cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))+","+SqlOrder(SBF->(IndexKey()))
				Else
					cQuery    += "ORDER BY "+SqlOrder(SB8->(IndexKey()))
				EndIf

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB8,.T.,.T.)
				For nX := 1 To Len(aStruSB8)
					If aStruSB8[nX][2]<>"C"
						TcSetField(cAliasSB8,aStruSB8[nX][1],aStruSB8[nX][2],aStruSB8[nX][3],aStruSB8[nX][4])
					EndIf
				Next nX
				If lLocaliza
					For nX := 1 To Len(aStruSBF)
						If aStruSBF[nX][2]<>"C"
							TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
						EndIf
					Next nX
				EndIf
			#ELSE
				MsSeek(xFilial("SB8")+cCodPro+cLocal+cLoteCtl+cNumLote)
			#ENDIF
			While ( !Eof() .And. xFilial("SB8") == (cAliasSB8)->B8_FILIAL .And.;
					cCodPro        == (cAliasSB8)->B8_PRODUTO .And.;
					cLocal         == (cAliasSB8)->B8_LOCAL   .And.;
					(cLoteCtl      == (cAliasSB8)->B8_LOTECTL.Or.Empty(cLoteCtl)).And.;
					(cNumLote      == (cAliasSB8)->B8_NUMLOTE.Or.Empty(cNumLote)).And.;
					lContSB8 )
				//Ŀ
				//Avalia os Saldos por Lote e Sub-Lote                                    
				//
				nReservaSB8:=0
				lContSBF := .T.
				If lQuery
					nRecSB8:=(cAliasSB8)->SB8RECNO
				EndIf
				nQtdSB8:=Min(nQtd-nReserva,SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase))
				If nQtdSB8 > 0 .And. If(lUsaVenc, .T., ((cAliasSB8)->B8_DTVALID >= dDataBase .Or.Empty((cAliasSB8)->B8_DTVALID)))
					//Ŀ
					//Avalia os saldos por Localizacao e Nr.Serie                             
					//
					If ( lLocaliza )
						cNumLSb8 := If(Rastro(cCodPro,"S"),(cAliasSB8)->B8_NUMLOTE,Space(Len(SB8->B8_NUMLOTE)))
						cLoteSb8 := (cAliasSB8)->B8_LOTECTL		
						If !lQuery
							dbSelectArea("SBF")
							dbSetOrder(2)
							MsSeek(xFilial("SBF")+cCodPro+cLocal+cLoteSb8+cNumLSb8)
						EndIf
						While ( !Eof() .And. xFilial("SBF") == (cAliasSBF)->BF_FILIAL .And.;
								cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
								cLocal         == (cAliasSBF)->BF_LOCAL  .And.;
								cLoteSb8       == (cAliasSBF)->BF_LOTECTL .And.;
								lContSBF)
							If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
									Empty(cLocaliz) ) .And.;
									((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
									Empty(cNumSer)) .And.;
									(cNumLSb8 == (cAliasSBF)->BF_NUMLOTE .Or.;
									Empty(cNumLSb8)) )
								If ( SBFSaldo(,cAliasSBF) > 0 )
									nEmpenho := nQtdSB8 - nReservaSB8
									nEmpenho := Min(SBFSaldo(,cAliasSBF),nEmpenho)
									nSaldo   += nEmpenho
									nReserva += nEmpenho
									nReservaSB8 += nEmpenho
								EndIf
							EndIf
							If (nReservaSB8 >= nQtdSB8)
								lContSBF := .F.
							EndIf
							dbSelectArea(cAliasSBF)
							dbSkip()
						EndDo
					Else
						nEmpenho := nQtdSB8 - nReservaSB8
						nEmpenho := Min(SB8Saldo(NIL,lUsaVenc,NIL,NIL,cAliasSB8,lEmpPrev,NIL,dDataBase),nEmpenho)
						nSaldo   += nEmpenho
						nReserva += nEmpenho
						nReservaSB8 += nEmpenho
					EndIf
				EndIf
				If (nReserva >= nQtd)
					lContSB8 := .F.
				EndIf
				dbSelectArea(cAliasSB8)
				If lQuery
					While !Eof() .And. (cAliasSB8)->SB8RECNO == nRecSB8
						dbSkip()
					End
				Else
					dbSkip()
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSB8)
				dbCloseArea()
				dbSelectArea("SB8")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+cCodPro+cLocal)			
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))			
		EndIf
		//Ŀ
		//Verifica os saldo por Localizacao quando nao ha rastro                  
		//
		If ( !Rastro(cCodPro) .And. lLocaliza .And. nSaldo == 0 ) .And. Empty(cServico)
			dbSelectArea("SBF")
			dbSetOrder(2)
			#IFDEF TOP
				SBF->(dbCommit())
				lQuery := .T.
				aStruSBF  := SBF->(dbStruct())
				cAliasSBF := "SLDATUESTSBF"

				cQuery    := "SELECT * "
				cQuery    += "FROM "+RetSqlName("SBF")+" SBF "
				cQuery    += "WHERE SBF.BF_FILIAL='"+xFilial("SBF")+"' AND "
				cQuery    += "SBF.BF_PRODUTO='"+cCodPro+"' AND "
				cQuery    += "SBF.BF_LOCAL='"+cLocal+"' AND "
				cQuery    += "SBF.D_E_L_E_T_=' ' "
				cQuery    += "ORDER BY "+SqlOrder(SBF->(IndexKey()))

				cQuery    := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSBF,.T.,.T.)
				For nX := 1 To Len(aStruSBF)
					If aStruSBF[nX][2]<>"C"
						TcSetField(cAliasSBF,aStruSBF[nX][1],aStruSBF[nX][2],aStruSBF[nX][3],aStruSBF[nX][4])
					EndIf
				Next nX
			#ELSE
				MsSeek(xFilial("SBF")+cCodPro+cLocal)
			#ENDIF
			While ( !Eof() .And. xFilial("SBF") == (cAliasSBF)->BF_FILIAL .And.;
					cCodPro        == (cAliasSBF)->BF_PRODUTO .And.;
					cLocal         == (cAliasSBF)->BF_LOCAL .And.;
					lContSBF)
				If ( ((cAliasSBF)->BF_LOCALIZ == cLocaliz .Or.;
						Empty(cLocaliz) ) .And.;
						((cAliasSBF)->BF_NUMSERI == cNumSer  .Or.;
						Empty(cNumSer)) )
					If ( SBFSaldo(,cAliasSBF) > 0 )
						nEmpenho := nQtd - nReserva
						nEmpenho := Min(SBFSaldo(,cAliasSBF),nEmpenho)
						nReserva += nEmpenho
						nSaldo   += nEmpenho
					EndIf
				EndIf
				dbSelectArea(cAliasSBF)
				dbSkip()
				If ( nReserva >= nQtd )
					lContSBF:= .F.
				EndIf
			EndDo
			If lQuery
				dbSelectArea(cAliasSBF)
				dbCloseArea()
				dbSelectArea("SBF")
			EndIf
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+cCodPro+cLocal)			
			nSaldo := Min(nSaldo,SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT))
		EndIf
		//Ŀ
		//Verifica SB2 quando nao ha rastro nem localizacao ou qdo se usa o WMS   
		//
		If (!Rastro(cCodPro) .And. !Localiza(cCodPro)) .Or. !Empty(cServico)
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+cCodPro+cLocal)
			nSaldo	:= SaldoSb2(,If(!Empty(cServico),.T.,!lPrdBn .And. GetNewPar("MV_QEMPV",.F.)),,lConsTerc,lConsQNPT)
			If !Empty(cProjeto) .And. !Empty(cTarefa)
				nSaldo := MAX(nSaldo,0)
				dbSelectArea("AFJ")
				dbSetOrder(1)
				MsSeek(xFilial("AFJ")+cProjeto+cTarefa)
				While !Eof() .And.xFilial("AFJ")+cProjeto+cTarefa==AFJ_FILIAL+AFJ_PROJET+AFJ_TAREFA
					nSaldo += Max(AFJ_QEMP-AFJ_QATU,0)
					dbSkip()
				End
			EndIf
			nSaldo := Min(nQtd,nSaldo)
		Else
			If lConsQNPT
				dbSelectArea("SB2")
				dbSetOrder(1)
				MsSeek(xFilial("SB2")+cCodPro+cLocal)
				nSaldo += SB2->B2_QNPT
			EndIf
		EndIf
	Else
		dbSelectArea("SC0")
		dbSetOrder(1)
		MsSeek(xFilial("SC0")+cReserva+cCodPro+cLocal)
		nSaldo := Min(SC0->C0_QUANT,nQtd)
	EndIf
EndIf
//Ŀ
//Soma ao Saldo o Valor Empenhado na B2_QEMPN para este Pedido            
//
If lQEmpNF
	If !Empty(SC6->C6_NUMOP) .Or. !Empty(SC6->C6_NUMSC) .Or. SC6->C6_OP = "05"
		nSaldo += SC6->C6_QTDVEN - If(FindFunction("A650QLibPV"),A650QLibPV(),0)
	EndIf
Endif
Return(nSaldo)

/*/


Ŀ
Funcao    AtIsRotina Autor  Eduardo Riera          Data  29.01.99 
Ĵ
Descrio Verifica qual eh a rotina chamadora.                        
Ĵ
Retorno   ExpL1: Logico                                               
Ĵ
ParametrosExpC1: Descricao da Rotina Chamadora para Teste.            
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function AtIsRotina(cRotina)

Local lRetorno := .F.
Local nContador:= 1
//Ŀ
//Verifica qual a rotina chamadora                                        
//
While ( !lRetorno .And. !Empty(ProcName(nContador)) )
	If ( Upper(ProcName(nContador))==cRotina )
		lRetorno := .T.
	EndIf
	nContador++
EndDo
Return(lRetorno)

/*/


Ŀ
Funcao    MaAvalCred Autor  Eduardo Riera          Data  10.03.99 
Ĵ
Descrio Funcao Generica de Avaliacao de Credito de Clientes         
Ĵ
Retorno   ExpL1: Credito (Sim/Nao)                                    
Ĵ
ParametrosExpC1: Codigo do Cliente                                    
          ExpC2: Loja do Cliente                                      
          ExpN3: Valor a ser avaliado                                 
          ExpN4: Moeda do valor a ser avaliado                        
          ExpL5: Considera acumulados de Pedido de Venda do SA1       
          ExpC6: Codigo do Bloqueio.                                  
          ExpC7: aEmpenho                                             
          ExpN8: Valor a ser adicionado ao limite de credito          
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaAvalCred(cCodCli,cLoja,nValor,nMoeda,lPedido,cCodigo,aEmpenho,nVlrCred)
Local aArea    := GetArea()
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSE1 := SE1->(GetArea())
Local aStruSA1 := {}
Local cTipoLim := SuperGetMv("MV_CREDCLI")
Local cQuery   := ""
Local cAliasSE1:= "SE1"
Local cAliasSA1:= "SA1"
Local cAliasQry:= ""
Local nLimCred := 0
Local nLimCredFin := 0
Local nVlrReal := xMoeda(nValor,nMoeda,1,dDataBase,2)
Local nVlrFin  := 0
Local nVlrPed  := nVlrReal
Local nLiminCr := SuperGetMv("MV_LIMINCR")  //Limite Minimo de Credito
Local nPerMax  := SuperGetMv("MV_PERMAX")   //Percentual Maximo comprometido com o Limite de Credito
Local nFaixaA  := SuperGetMv("MV_PEDIDOA")  //Limite de Credito para a Faixa A
Local nFaixaB  := SuperGetMv("MV_PEDIDOB")  //Limite de Credito para a Faixa B
Local nFaixaC  := SuperGetMv("MV_PEDIDOC")  //Limite de Credito para a Faixa C
Local nNumDias := 0
Local nRegEmp  := 0
Local nMCusto  := 0
Local nX       := 0
Local lMaAvCred:= ExistBlock("MAAVCRED")
Local lMaAvCrPr:= ExistBlock("MAAVCRPR")
Local lQuery   := .F.
Local lRetorno := .T.
Local xRetorno := ""

#IFDEF TOP 
	Local cSepNeg   := If("|"$MV_CRNEG,"|",",")
	Local cSepProv  := If("|"$MVPROVIS,"|",",")
	Local cSepRec   := If("|"$MVRECANT,"|",",")
#ENDIF

DEFAULT nVlrCred := 0

dbSelectArea("SA1")
dbSetOrder(1)
If ( SuperGetMv("MV_BLOQUEI" ) .And. !lMaAvCred )
	Do Case
		//Ŀ
		//Aqui e Verificado o Cliente Por Codigo + Loja                           
		//
	Case ( cTipoLim=="L" )
		If ( MsSeek(xFilial("SA1")+cCodCli+cLoja) )
			If ( SA1->A1_RISCO == "A" )
				lRetorno := .T.
			EndIf
			If ( SA1->A1_RISCO == "E" .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
			EndIf
			If ( SA1->A1_RISCO == "Z" .And. nVlrCred<=0)
				SerSolLbCR()
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
			Else
				If SerSolLbCR()
					cCodigo  := "04" //Vencimento do Limite de Credito
					lRetorno := .F.
				EndIf
			EndIf
			//Ŀ
			//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
			//
			If ( !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase ) .And. nVlrCred <= 0
				cCodigo  := "04" //Vencimento do Limite de Credito
				lRetorno := .F.
			EndIf
			If ( SA1->A1_RISCO <> "A" .And. !(SA1->A1_RISCO $ "E,Z" .And. nVlrCred<=0) .And. lRetorno)
				//Ŀ
				//Aqui e verificado o Limite de Credito do Cliente + Loja                 
				//
				//Ŀ
				//O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao 
				//em na moeda corrente.                                                   
				//
				nMCusto	 := IIf(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				If SA1->A1_RISCO$"E,Z"
					nLimCred := 0
				Else
					nLimCred := xMoeda(SA1->A1_LC,nMCusto,1,dDataBase,2)
				EndIf
				//Ŀ
				//Verifica se o Valor nao eh maior que o Limite de Credito                
				//
				If ( lPedido )
					If nVlrCred < nVlrReal
						nVlrReal += SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
					Else
						nVlrReal -= nVlrCred
						nLimCred -= SA1->A1_SALDUP + xMoeda(SA1->A1_SALPEDL,nMCusto,1,dDatabase,2)
					EndIf
					If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
						nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
						If ( nRegEmp <> 0 )
							nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
						EndIf
					EndIf
				EndIf
				If ( nVlrReal > nLimCred .And. nVlrReal > 0)
					cCodigo  := "01" // Limite de Credito
					lRetorno := .F.
				EndIf
				//Ŀ
				//Controle de limite de credito secundario                                
				//
				If SA1->A1_RISCO $ "E,Z"
					nLimCredFin	:= xMoeda(SA1->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
				Else
					nLimCredFin := 0
				EndIf
				If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
					nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
					If ( nRegEmp <> 0 )
						nLimCredFin -= aEmpenho[1][nRegEmp][3]
					EndIf
				EndIf				
				If SA1->A1_SALFIN > nLimCredFin .And. SA1->A1_LCFIN > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
				EndIf
				//Ŀ
				//Verifica as Classes de Cliente                                          
				//
				If nVlrReal > 0
					Do Case
					Case ( nVlrReal <= nLiMinCr )
						lRetorno := .T.
						cCodigo  := ""
					Case ( nVlrReal > ((nPerMax * nLimCred) / 100) )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					Case ( SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					Case ( SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					Case ( SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					EndCase
					//Ŀ
					//Aqui e verificado o Grau de Risco do Cliente + Loja                     
					//
					If ( lRetorno .And. !Empty(SA1->A1_RISCO) .And. !SA1->A1_RISCO$"E,Z")
						nNumDias := SuperGetMv("MV_RISCO"+SA1->A1_RISCO)
						dbSelectArea("SE1")
						dbSetOrder(8)
						#IFDEF TOP
							lQuery    := .T.
							cAliasSE1 := "MAAVALCRED"

							cQuery    := "SELECT MIN(E1_VENCREA) VENCREAL "
							cQuery    += "FROM "+RetSqlName("SE1")+" SE1 "
							cQuery    += "WHERE SE1.E1_FILIAL='"+xFilial("SE1")+"' AND "
							cQuery    += "SE1.E1_CLIENTE='"+cCodCli+"' AND "
							cQuery    += "SE1.E1_LOJA='"+cLoja+"' AND "
							cQuery    += "SE1.E1_STATUS='A' AND "												
							cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVABATIM,"|") + " AND "	                    
							cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MV_CRNEG,cSepNeg)  + " AND "
							cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVPROVIS,cSepProv) + " AND "
							cQuery    += "SE1.E1_TIPO NOT IN " + FormatIn(MVRECANT,cSepRec)  + " AND "							
							cQuery    += "SE1.D_E_L_E_T_=' ' "


							cQuery := ChangeQuery(cQuery)

							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSE1,.T.,.T.)

							TcSetField(cAliasSE1,"VENCREAL","D",8,0)
							
							If (cAliasSE1)->(!Eof()) .And. !Empty((cAliasSE1)->VENCREAL) .And. (dDataBase - (cAliasSE1)->VENCREAL) >= nNumDias
								lRetorno := .F.
								cCodigo  := "01" // Limite de Credito
							EndIf

							dbSelectArea(cAliasSE1)
							dbCloseArea()
							dbSelectArea("SE1")
							
						#ELSE
							MsSeek(xFilial("SE1")+cCodCli+cLoja+"A")


							While ( !Eof() .And. (cAliasSE1)->E1_FILIAL == xFilial("SE1") .And.;
									(cAliasSE1)->E1_CLIENTE == cCodCli .And.;
									(cAliasSE1)->E1_LOJA  == cLoja .And.;
									(cAliasSE1)->E1_STATUS == "A" )
								If ( !(cAliasSE1)->E1_TIPO$MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG .And. !(cAliasSE1)->E1_TIPO$MVABATIM )
									If ( ( dDataBase - (cAliasSE1)->E1_VENCREA ) >= nNumDias )
										lRetorno := .F.
										cCodigo  := "01" // Limite de Credito
									EndIf
									//Ŀ
									//Aqui o Loop eh abortado pois esta em ordem de vencto Real 
									//
									Exit
								EndIf
								dbSelectArea(cAliasSE1)
								dbSkip()
							EndDo





						#ENDIF									
					EndIf
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Aqui e verificado apenas o Codigo ( Matriz )                            
		//
	Case ( cTipoLim == "C" )
		If ( MsSeek(xFilial("SA1")+cCodCli) )
			//Ŀ
			// O Grau de Risco deve ser Avaliado da Matriz                   
			//
			If ( SA1->A1_RISCO == "A" )
				lRetorno := .T.
				cCodigo  := ""
			EndIf
			If ( SA1->A1_RISCO == "E"  .And. nVlrCred<=0)
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
			EndIf
			If ( SA1->A1_RISCO == "Z" .And. nVlrCred<=0)
				SerSolLbCR()			
				lRetorno := .F.
				cCodigo  := "01" // Limite de Credito
			Else
				SerSolLbCR()
			EndIf
			//Ŀ
			//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
			//
			If ( !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase )
				lRetorno := .F.
				cCodigo  := "04" // Vencimento do Limite de Credito
			EndIf
			//Ŀ
			//Aqui e verificado o Limite de Credito do Cliente                        
			//
			//Ŀ
			//O Limite de Credito sempre esta na Moeda MV_MCUSTO, mas os calculos sao 
			//em na moeda corrente.                                                   
			//
			If ( SA1->A1_RISCO <> "A" .And. !(SA1->A1_RISCO $ "E,Z" .And. nVlrCred<=0) .And. lRetorno )
				nLimCred := 0
				nLimCredFin	:= 0	
				dbSelectArea("SA1")
				dbSetOrder(1)				
				#IFDEF TOP
					cAliasSA1 := "QRYSA1"
					lQuery    := .T.

					aStruSa1  := SA1->(dbStruct())

					cQuery := "SELECT A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC,A1_RISCO,R_E_C_N_O_ RECSA1 "
					cQuery += " FROM "+RetSqlName("SA1")+" SA1 "
					cQuery += "WHERE "
					cQuery += "A1_FILIAL = '"+xFilial("SA1")+"' AND "
					cQuery += "A1_COD = '"+cCodCli+"' AND "
					cQuery += "SA1.D_E_L_E_T_ = ' ' "
					cQuery += "ORDER BY "+SqlOrder(SA1->(IndexKey()))					

					cQuery := ChangeQuery(cQuery)

					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSA1,.T.,.T.)

					For nX := 1 To Len(aStruSA1)
						If aStruSA1[nX,1]$"A1_FILIAL,A1_COD,A1_MOEDALC,A1_LC,A1_LCFIN,A1_SALFIN,A1_SALDUP,A1_SALPEDL,A1_VENCLC"						
							If aStruSA1[nX,2] <> "C" .And. FieldPos(aStruSA1[nX,1])<>0
								TcSetField(cAliasSA1,aStruSA1[nX,1],aStruSA1[nX,2],aStruSA1[nX,3],aStruSA1[nX,4])
							EndIf						
						EndIf
					Next nX

				#ELSE
					MsSeek(xFilial("SA1")+cCodCli)
				#ENDIF
				nMCusto	:= IIf((cAliasSA1)->A1_MOEDALC > 0,(cAliasSA1)->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
				nVlrCred := xMoeda(nVlrCred,nMoeda,1,dDataBase,2)
				nLimCred := 0
				While ( !Eof() .And. xFilial("SA1") == (cAliasSA1)->A1_FILIAL .And.;
						cCodCli == (cAliasSA1)->A1_COD    .And.;
						lRetorno)
					If !(cAliasSA1)->A1_RISCO$"E,Z"
						nLimCred += xMoeda((cAliasSA1)->A1_LC,nMCusto,1,dDataBase,2)
					Else
						nLimCred := 0
					EndIf
					If (cAliasSA1)->A1_LCFIN >= 0
						nLimCredFin	+= xMoeda((cAliasSA1)->A1_LCFIN,nMCusto,1,dDataBase,MsDecimais(1))
						nVlrFin 	+= (cAliasSA1)->A1_SALFIN
					EndIf	
					If ( lPedido )
						If nVlrCred < nVlrReal
							nVlrReal += (cAliasSA1)->A1_SALDUP + xMoeda((cAliasSA1)->A1_SALPEDL,nMCusto,1,dDatabase,2)
						Else
							nVlrReal -= nVlrCred
							nLimCred -= (cAliasSA1)->A1_SALDUP + xMoeda((cAliasSA1)->A1_SALPEDL,nMCusto,1,dDatabase,2)
						EndIf
						If ( aEmpenho <> Nil ) .And. ( !Empty(aEmpenho) )
							nRegEmp  := aScan(aEmpenho[1],{|x| x[1]==IIf(lQuery,(cAliasSA1)->RECSA1,SA1->(RecNo())) })
							If ( nRegEmp <> 0 )
								nVlrReal += xMoeda(aEmpenho[1][nRegEmp][2],nMCusto,1,dDatabase,2)
							EndIf
							If ( nRegEmp <> 0 )
								nVlrFin += aEmpenho[1][nRegEmp][3]
							EndIf
						EndIf
					EndIf
					//Ŀ
					//Aqui e avaliado o Vencimento do Limite de Credito do Cliente            
					//
					If ( !Empty((cAliasSA1)->A1_VENCLC) .And. (cAliasSA1)->A1_VENCLC < dDataBase ) .And. nVlrCred <= 0
						lRetorno := .F.
						cCodigo  := "04" // Vencimento do Limite de Credito
					EndIf
					dbSelectArea(cAliasSA1)
					dbSkip()
				EndDo
				If lQuery
					dbSelectArea(cAliasSA1)
					dbCloseArea()
					dbSelectArea("SA1")
				Endif
				//Ŀ
				//Verifica se o Valor nao eh maior que o Limite de Credito                
				//
				If ( lRetorno .And. nVlrReal > nLimCred .And. nVlrReal > 0)
					lRetorno := .F.
					cCodigo  := "01" // Limite de Credito
				EndIf
				//Ŀ
				//Controle de limite de credito secundario                                
				//
				If lRetorno .And. nVlrFin > nLimCredFin .And. nLimCredFin > 0
					cCodigo 	:= "01" // Limite de Credito
					lRetorno := .F.
				EndIf
				//Ŀ
				//Verifica as Classes de Cliente                                          
				//
				If nVlrReal > 0
					dbSelectArea("SA1")
					dbSetOrder(1)
					MsSeek(xFilial("SA1")+cCodCli)
					Do Case
					Case ( lRetorno .And. nVlrReal <= nLiMinCr )
						lRetorno := .T.
						cCodigo  := ""
					Case ( lRetorno .And. nVlrReal > ((nPerMax * nLimCred) / 100) )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito.
					Case ( lRetorno .And. SA1->A1_CLASSE == "A" .And. nVlrPed > nfaixaA .And. nFaixaA <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					Case ( lRetorno .And. SA1->A1_CLASSE == "B" .And. nVlrPed > nfaixaB .And. nFaixaB <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					Case ( lRetorno .And. SA1->A1_CLASSE == "C" .And. nVlrPed > nfaixaC .And. nFaixaC <> 0 )
						lRetorno := .F.
						cCodigo  := "01" // Limite de Credito
					EndCase
					//Ŀ
					// Aqui e avaliado o risco do Cliente - ( Matriz + Filiais )   
					//
					If ( lRetorno .And. !Empty(SA1->A1_RISCO) .And. !SA1->A1_RISCO$"E,Z" )						
						#IFDEF TOP
							dbSelectArea("SE1")
							dbSetOrder(8)

							cAliasQry  := "QRYAVALCRD"
							lQuery     := .T.

							cQuery := "SELECT A1_FILIAL,A1_COD,A1_LOJA,A1_RISCO,E1_FILIAL,E1_CLIENTE,E1_LOJA,E1_TIPO,E1_VENCREA"
							cQuery += " FROM "+RetSqlName("SA1")+" SA1, "
							cQuery += RetSqlName("SE1")+" SE1 "
							cQuery += "WHERE "
							cQuery += "A1_FILIAL ='"+xFilial("SA1")+"' AND "
							cQuery += "A1_COD = '"+cCodCli+"' AND "
							cQuery += "SA1.D_E_L_E_T_ = ' ' AND "												
							cQuery += "E1_FILIAL = '"+xFilial("SE1")+"' AND "
							cQuery += "E1_CLIENTE = A1_COD AND "
							cQuery += "E1_LOJA = A1_LOJA AND "
							cQuery += "E1_STATUS = 'A' AND "
							cQuery += "SE1.D_E_L_E_T_ = ' ' "
							cQuery += "ORDER BY "+SqlOrder(StrTran(SE1->(IndexKey()),"E1_LOJA+",""))

							cQuery := ChangeQuery(cQuery)

							dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)

							TcSetField(cAliasQry,"E1_VENCREA","D",8,0)

							While (cAliasQry)->(!Eof()) .And. lRetorno
								nNumDias := SuperGetMv("MV_RISCO"+(cAliasQry)->A1_RISCO)
								If ( !(cAliasQry)->E1_TIPO$MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG .And. !(cAliasQry)->E1_TIPO $ MVABATIM)
									If ( ( dDataBase - (cAliasQry)->E1_VENCREA ) >= nNumDias )
										lRetorno := .F.
										cCodigo  := "01" // Limite de Credito
									EndIf
									Exit
								EndIf

								dbSelectArea(cAliasQry)
								dbSkip()

							EndDo
							If lQuery
								dbSelectArea(cAliasQry)
								dbCloseArea()
								dbSelectArea("SA1")
							EndIf
						#ELSE
							dbSelectArea("SA1")
							dbSetOrder(1)
							MsSeek(xFilial("SA1")+cCodCli)
							While ( !Eof() .And. xFilial("SA1") == SA1->A1_FILIAL .And.;
									cCodCli        == SA1->A1_COD )
								nNumDias := SuperGetMv("MV_RISCO"+SA1->A1_RISCO)
								dbSelectArea("SE1")
								dbSetOrder(8)
								MsSeek(xFilial("SE1")+SA1->A1_COD+SA1->A1_LOJA+"A")
								While ( !Eof() .And. SE1->E1_FILIAL == xFilial("SE1") .And.;
										SE1->E1_CLIENTE== SA1->A1_COD .And.;
										SE1->E1_LOJA   == SA1->A1_LOJA .And.;
										SE1->E1_STATUS == "A" )
									If ( !SE1->E1_TIPO$MVRECANT+"/"+MVPROVIS+"/"+MV_CRNEG .And. !SE1->E1_TIPO $ MVABATIM)
										If ( ( dDataBase - SE1->E1_VENCREA ) >= nNumDias )
											lRetorno := .F.
											cCodigo  := "01" // Limite de Credito
										EndIf
										Exit
									EndIf
									dbSelectArea("SE1")
									dbSkip()
								EndDo
								If ( !lRetorno )
									Exit
								EndIf
								dbSelectArea("SA1")
								dbSkip()
							EndDo
						#ENDIF			
					EndIf
				EndIf
			EndIf
		EndIf
	EndCase

	If ( lMaAvCrPr )
		lRetorno := ExecBlock("MAAVCRPR",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido,cTipoLim,lRetorno,cCodigo})
		If !lRetorno .And. Empty(cCodigo)
			cCodigo := "01"
		EndIf
		If lRetorno .And. !Empty(cCodigo)
			cCodigo := ""
		EndIf
	Endif

Else
	If ( lMaAvCred )
		xRetorno := ExecBlock("MAAVCRED",.F.,.F.,{cCodCli,cLoja,nValor,nMoeda,lPedido})
		If ValType(xRetorno)=="C"
			lRetorno := Empty(xRetorno)
			cCodigo  := xRetorno
		Else
			If !xRetorno
				cCodigo := "01"
				lRetorno := .F.
			Else
				lRetorno := .T.
			EndIf
		Endif
	EndIf
EndIf
//Ŀ
//Restaura a Entrada da Rotina                                            
//
RestArea(aAreaSA1)
RestArea(aAreaSE1)
RestArea(aArea)
Return( lRetorno )

/*/


Ŀ
Funcao    MaIniLiber Autor Eduardo Riera           Data 22.02.99  
Ĵ
Descrio Inicializa a Quantidade Liberada.                           
          Esta funcao necessita do acols, aheader do SC6 e Enchoice   
          do SC5 preenchidos.                                         
Ĵ
Retorno   Sempre .T.                                                  
Ĵ
ParametrosExpN1: Numero do Pedido.                                    
          ExpN2: Quantidade Vendida.                                  
          ExpN3: Linha da GetDados.                                   
          ExpL4: Codigo de Barras.                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaIniLiber(cPedido,nQtdaLib,nLinha,lCb)

Local aArea       := GetArea()
Local aAreaSC6    := SC6->(GetArea())
Local nCntFor     := 0
Local cItem       := ""
Local cProduto    := ""
Local cLocal      := ""
Local cNumLote    := ""
Local cLoteCtl    := ""
Local cLocaliz    := ""
Local cNumSer     := ""
Local cTes        := ""
Local cBlq        := ""
Local cBloquei    := ""
Local nQtdLib     := 0
Local nPQtdLib    := 0
Local cReserva    := ""
Local nColGr      := 0
Local nLinGr      := 0
Local cProdRef    := ""
Local nQtdLibGr   := 0
Local nQtdVen     := 0
Local nPosQtdVen  := 0
Local nPosQtdLib  := 0
Local nPosQtdEnt  := 0
Local lMata410 := AtIsRotina("MATA410")

DEFAULT lCb       := .F.

If ( lCB )
	//Ŀ
	// Cria variaveis ja existentes na validacao do Produto na      
	// GetDados para compatibilizar as duas validacoes.             
	//
	nLinha := Len(aCols)
EndIf
//Ŀ
// Caso o item do pedido tenha sido bloqueado pelo usuario      
// nao deve sugerir a quantidade liberada                       
//
For nCntFor := 1 To Len(aHeader)
	Do Case
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_ITEM" )
		cItem    := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
		cProduto := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCAL" )
		cLocal   := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_TES" )
		cTes     := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDLIB" )
		nPQtdLib := nCntFor
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLQ" )
		cBlq     := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_BLOQUEI" )
		cBloquei := AllTrim(aCols[nLinha][nCntFor])
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMLOTE" )
		cNumLote := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOTECTL")
		cLoteCtl := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_LOCALIZ" )
		cLocaliz := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_NUMSER")
		cNumSer  := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_RESERVA")
		cReserva := aCols[nLinha][nCntFor]
	Case ( AllTrim(aHeader[nCntFor][2]) == "C6_QTDVEN")
		nQtdVen  := aCols[nLinha][nCntFor]
		If ( M->(Type("C6_QTDVEN"))=="N" )
			nQtdVen := M->C6_QTDVEN
		EndIf
	EndCase
Next nCntFor

If !(xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+cPedido+cItem)
EndIf
If ( xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM .And. !Empty(cReserva) )
	nQtdLib := Min(SC6->C6_QTDRESE,nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT)
Else
	If ( nQtdALib > ( nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT ) .And. xFilial("SC6") == SC6->C6_FILIAL .And. cPedido == SC6->C6_NUM .And. cItem == SC6->C6_ITEM )
		nQtdALib := nQtdVen - If(ALTERA.And.lMata410,0,SC6->C6_QTDEMP) - SC6->C6_QTDENT
	  	nQtdALib := Iif(nQtdALib<0.And.INCLUI.And.lMata410,nQtdVen,nQtdALib)
	EndIf
	//Ŀ
	//Calcula o Saldo que pode ser liberado                                   
	//
	If ( !cBlq $ "SR" .And. !(M->C5_TIPO$"CIP") .And. Empty(cBloquei))
		cProdRef := cProduto
		If ( MatGrdPrrf(@cProdRef) )
			nPosQtdVen := &(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")
			nPosQtdLib := &(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")
			nPosQtdEnt := &(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")
			For nLinGr := 1 To Len(&(MaReadGrd()):aColsGrade[nLinha])
				For nColGr := 2 To Len(&(MaReadGrd()):aHeadGrade[nLinha])
					nQtdALib  := &(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdVen]-&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdEnt]
					nQtdLibGr := nQtdALib
					&(MaReadGrd()):aColsGrade[nLinha][nLinGr][nColGr][nPosQtdLib] := nQtdLibGr
					nQtdLib += nQtdLibGr
				Next nColGr
			Next nLinGr  
		Else
			nQtdLib := nQtdALib
		EndIf
	EndIf
EndIf
//Ŀ
//Atualiza o Acols                                                        
//
aCols[nLinha][nPQtdLib] := nQtdLib
//Ŀ
//Retorna o Estado de Entrada da Rotina                                   
//
RestArea(aAreaSC6)
RestArea(aArea)

Return( .T. )

/*/


Ŀ
Funcao    MaLibDoFat Autor Eduardo Riera           Data 09.03.99  
Ĵ
Descrio Liberacao dos Itens de Pedido de Venda                      
Ĵ
Retorno   ExpN1: Quantidade Liberada                                  
Ĵ
Transacao Nao possui controle de Transacao a rotina chamadora deve    
          controlar a Transacao e os Locks                            
Ĵ
ParametrosExpN1: Registro do SC6                                      
          ExpN2: Quantidade a Liberar                                 
          ExpL3: Bloqueio de Credito                                  
          ExpL4: Bloqueio de Estoque                                  
          ExpL5: Avaliacao de Credito                                 
          ExpL6: Avaliacao de Estoque                                 
          ExpL7: Permite Liberacao Parcial                            
          ExpL8: Tranfere Locais automaticamente                      
          ExpA9: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
          ExpbA: CodBlock a ser avaliado na gravacao do SC9           
          ExpAB: Array com Empenhos previamente escolhidos            
                 (impede selecao dos empenhos pelas rotinas)          
          ExpLC: Indica se apenas esta trocando lotes do SC9          
          ExpND: Valor a ser adicionado ao limite de credito          
          ExpNE: Quantidade a Liberar - segunda UM                    
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function MaLibDoFat(nRegSC6,nQtdaLib,lCredito,lEstoque,lAvCred,lAvEst,lLibPar,lTrfLocal,aEmpenho,bBlock,aEmpPronto,lTrocaLot,lOkExpedicao,nVlrCred,nQtdalib2)

Local aArea    	:= GetArea("SC6")
Local aAreaSA1 	:= SA1->(GetArea())
Local aAreaSF4 	:= SF4->(GetArea())
Local aAreaSC5 	:= {}
Local aAreaSC6 	:= {}
Local nQtdLib  	:= nQtdALib
Local nQtdLib2 	:= nQtdALib2
Local lContinua	:= .T.
Local lIntACD  	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local lPedLib  	:= .F.
Local lLibItPrev	:= SuperGetMV( 'MV_FATLBPR', .F., .T. )	//Indica se permite a liberao de Itens previstos do Pedido de Venda

nQtdLib := nQtdALib
//Ŀ
//Seta os parametros defaults                                             
//
DEFAULT nQtdALib    := SC6->C6_QTDLIB
DEFAULT nQtdALib2   := SC6->C6_QTDLIB2
DEFAULT lCredito    := .T.
DEFAULT lEstoque    := .T.
DEFAULT lAvCred     := .T.
DEFAULT lAvEst      := .T.
DEFAULT lOkExpedicao:= .F.
//Ŀ
//Verificar se o Pedido ja possui liberacao 
//
If lIntACD .And. IsInCallStack("MATA455") 
	lPedLib :=SC9->(dbSeek(xFilial("SC9")+SC6->(SC6->C6_NUM+SC6->C6_ITEM)))
EndIf

//Ŀ
//Posiciona Pedido                                                        
//
If Empty(SC6->C6_BLOQUEI) .And. AllTrim(SC6->C6_BLQ)<>"R" .And. If(lPedLib,If(SC9->(FieldPos("C9_ORDSEP"))<> 0,If(Empty(SC9->C9_ORDSEP),.T.,If(!Empty(SC9->C9_ORDSEP) .And. !Empty(SC9->C9_NFISCAL),.T.,.F.)),.T.),.T.) 

	dbSelectArea("SC6")
	If nRegSC6<>0
		aAreaSC6 := GetArea()
		MsGoto(nRegSC6)
	Else
		aAreaSC6 := GetArea("SC6")
	EndIf

	If SB1->B1_FILIAL+SB1->B1_COD <> xFilial('SB1')+SC6->C6_PRODUTO
		SB1->(DbSetOrder(1))
		SB1->(MsSeek(xFilial('SB1')+SC6->C6_PRODUTO))
	Endif
	dbSelectArea("SC5")
	dbSetOrder(1)
	If ( xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==SC6->C6_NUM )
		aAreaSC5 := GetArea("SC5")
	Else
		MsSeek(xFilial("SC5")+SC6->C6_NUM)
		aAreaSC5 := GetArea()
	EndIf
	//Ŀ
	//Integracao com EEC													   
	//Funcao: AvChkStDesp()												   
	//Parametros: Nro do pedido de venda. 									   
	//Retorno: True  - O pedido de venda podera ser liberado visto que as 	   
	//					despesas ja foram integradas.						   
	//         False - O pedido de venda no poder ser liberado visto que    
	//					existem pendencias para as despesas.				   
	//
	If !Empty(SC5->C5_PEDEXP)
		If FindFunction("AvChkStDesp")
			If !AvChkStDesp(SC5->C5_NUM)
				lContinua := .F.
			EndIf
		EndIf
	EndIf	
	
	//------------------------------------------------------------------------------
	// Verifica o tipo de operao (C6_TPOP) antes de liberar. Itens previstos no
	// podem ser liberados a menos que o parmetro MV_FATLBPR esteja como .T.
	// Alterao realizada para atender o requisito de Programao de Entrega.
	//------------------------------------------------------------------------------
	If ( SC6->C6_TPOP == "P" ) .And. ( !lLibItPrev )
		lContinua := .F.
	EndIf
	
	If lContinua
		If nRegSC6 == 0 .Or. ( RecLock("SC5") .And. RecLock("SC6") )
			If Empty(SC5->C5_BLQ)
				If nQtdALib2 == 0 .And. SC6->C6_UNSVEN <> 0
					nQtdALib2 := SB1->(ConvUm(SC6->C6_PRODUTO,nQtdALib,Nil,2))
					If nQtdALib2 == 0
						If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdALib==0
							nQtdALib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
						Else
							nQtdALib2 := nQtdALib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
						EndIf
					EndIf
					SC6->C6_QTDLIB2:= nQtdALib2
					nQtdALib2 := SC6->C6_QTDLIB2
				EndIf
				SC6->C6_QTDLIB := nQtdALib
				SC6->C6_QTDLIB2:= nQtdALib2
				FatAtuEmpN("-")
				nQtdLib := a440GeraC9(@nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLibPar,lTrfLocal,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lOkExpedicao,@nVlrCred,@nQtdlib2)
				FatAtuEmpN("+")
			EndIf
		EndIf
	Else
		nQtdLib := 0	
	EndIf
	RestArea(aAreaSC5)
	RestArea(aAreaSC6)

Else
	nQtdLib := 0
Endif

//Ŀ
//Restaura a Entrada                                                      
//
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdLib)

/*/


Ŀ
Funcao    MaLiberOk  Autor Eduardo Riera           Data 10.03.99  
Ĵ
Descrio Atualizacao do Campo C5_LiberOk                             
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpA1: Array com os Pedidos de Venda                        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
 07/05/99  Aline C. Vale  Controle de Eliminacao de Residuos Mata500 
ٱ


/*/
Function MaLiberOk(aPedidos,lResiduo)

Local aArea    := GetArea()
Local nCntFor  := 0
Local lLiberOk := .T.
Local lTotal   := .T.

#IFDEF TOP
	Local cQuery   := ""
	Local cQry     := ""
#ENDIF

lResiduo    := If(ValType(lResiduo)=='U',.F.,lResiduo)

For nCntFor := 1 To Len(aPedidos)
	dbSelectArea("SC5")
	dbSetOrder(1)
	If MsSeek(xFilial("SC5")+aPedidos[nCntFor])

		#IFDEF TOP
			If ( TcSrvType()<>"AS/400" )
				SC6->(dbCommit())
				cQry   := "MALIBEROK1"

				cQuery := "SELECT COUNT(*) QTDVEN FROM "+RetSqlName("SC6")
				cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
				cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
				cQuery += " C6_QTDVEN>(C6_QTDEMP+C6_QTDENT) AND"
				cQuery += " C6_BLQ <> 'R ' AND "
				cQuery += " D_E_L_E_T_<>'*' "
				cQuery := ChangeQuery(cQuery)
				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
				If ( QTDVEN > 0 )
					lLiberOk := .F.
				EndIf
				dbCloseArea()
				dbSelectArea("SC6")
				If ( lResiduo )
					SC6->(dbCommit())

					cQuery := "SELECT COUNT(*) RESIDUO FROM "+RetSqlName("SC6")
					cQuery += " WHERE C6_FILIAL = '"+xFilial("SC6")+"' AND"
					cQuery += " C6_NUM = '"+aPedidos[nCntFor]+"' AND"
					cQuery += " C6_QTDVEN>C6_QTDENT AND"
					cQuery += " C6_BLQ<>'R ' AND "
					cQuery += " D_E_L_E_T_<>'*' "
					cQuery := ChangeQuery(cQuery)
					dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cQry,.T.,.T.)
					If ( RESIDUO > 0 )
						lTotal := .F.
					EndIf
					dbCloseArea()
				EndIf
			Else
		#ENDIF
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+aPedidos[nCntFor])
			While ( !Eof() .And. xFilial("SC6")       == SC6->C6_FILIAL .And.;
					aPedidos[nCntFor] == SC6->C6_NUM )
				//Ŀ
				//Verifica se Todos os Itens foram Liberados                              
				//
				If ( Alltrim(SC6->C6_BLQ) <> "R" )
					If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk )
						lLiberOk := .F.
					EndIf
					If ( lResiduo .And. SC6->C6_QTDVEN > SC6->C6_QTDENT )
						lTotal := .F.
					EndIf
					If !lLiberOk
						Exit
					EndIf
				EndIf
				dbSelectArea("SC6")
				dbSkip()
			EndDo
			#IFDEF TOP
			EndIf
			#ENDIF
		dbSelectArea("SC5")
		//Ŀ
		//Atualiza do C5_LIBEROK                                                  
		//
		If lLiberOk
			RecLock("SC5")
			SC5->C5_LIBEROK := "S"
			If lResiduo .And. lTotal .And. Empty(SC5->C5_NOTA)
				SC5->C5_NOTA := Repl("X",Len(SC5->C5_NOTA))
			EndIf
			MsUnLock()
			
			//Ŀ
			//Elimina o saldo do relacionamento de pedidos finalizados.
			//
			If 	lResiduo 						.AND.; 
				lTotal 							.AND.;
				FindFunction("A410UsaAdi") 		.AND.;
				A410UsaAdi( SC5->C5_CONDPAG ) 	.AND.; 
				FindFunction("FPedAdtRsd") 
				
				FPedAdtRsd( "R", { SC5->C5_NUM } )
			EndIf
		EndIf
	Endif	
Next nCntFor
//Ŀ
//Restaura o Area  de Entrada                                             
//
RestArea(aArea)
Return(.T.)

/*/


Ŀ
Funcao    A440GeraC9 Rev.  Eduardo Riera           Data 22.03.99  
Ĵ
Descrio Gravacao do item liberado do pedido de Venda                
Ĵ
Retorno    ExpN1: Quantidade realmente liberada                       
Ĵ
Parametros ExpN1: Quantidade a Liberar                                
           ExpL2: Indica se o Credito foi Liberado                    
           ExpL3: Indica se o Estoque foi Liberado                    
           ExpL4: Avalia Credito                                      
           ExpL5: Avalia Estoque                                      
           ExpL6: Permite Liberacao Parcial                           
           ExpL7: Tranfere Locais automaticamente                     
           ExpA8: Empenhos ( Caso seja informado nao efetua a gravacao
                 apenas avalia ).                                     
           Expb9: CodBlock a ser avaliado na gravacao do SC9          
           ExpAB: Array com Empenhos previamente escolhidos           
                 (impede selecao dos empenhos pelas rotinas)          
          ExpL8: Indica se apenas esta trocando lotes do SC9          
          ExpN9: Valor a ser adicionado ao limite de credito          
          ExpNA: Quantidade a Liberar na segunda UM                   
Ĵ
Observacao O registro do SC5/SC6 deve estar posicionado               
           Deve estar numa transacao                                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Static Function a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,aEmpenho,;
							bBlock,aEmpPronto,lTrocaLot,lOkExpedicao,nVlrCred,nQtdLib2)

Local aArea     := GetArea(Alias())
Local aAreaSA1  := SA1->(GetArea())
Local aAreaSB2  := SB2->(GetArea())
Local aAreaSF4  := SF4->(GetArea())
Local aSaldos   := {}
Local aLocal    := {}

Local nSldSB6   := 0
Local cBlCred   := ""
Local cBlEst    := ""
Local cAliasSB6 := "SB6"
Local lQuery    := .F.

Local lBlqCrd   := GetMv("MV_BLQCRED")
Local lTravas   := .T.

Local nQtdJaLib := 0
Local nQtdPoder3:= 0
Local nQtdNPT   := 0
Local nQtdNosso := 0
Local lMTValAvC := ExistBlock("MTVALAVC")
Local	nValAv	 := 0
Local aEmpBN	:= If(FindFunction("A410CarBen"),A410CarBen(SC6->C6_NUM,SC6->C6_ITEM),{})
Local nX        := 0	
Local nMvTipCrd 	:= SuperGetMV("MV_TIPACRD", .F., 1)
Local nVlrTitAbe	:= 0
Local nVlrTitAtr	:= 0	

#IFDEF TOP
	Local cQuery    := ""
#ENDIF 	

//Ŀ
//Tratamento para e-Commerce      
//
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.) .And. GetRpoRelease("R5")
Local cOrcamto   := ""    //Obtem o orcamento original para poder posicionar na tabela MF5.

//Ŀ
//Ajusta a Entrada da Rotina                                              
//
DEFAULT lAvCred     := .T.
DEFAULT lAvEst      := .T.
DEFAULT lLiber      := .F.
DEFAULT lTransf     := .F.
DEFAULT lOkExpedicao:= .F.

If ( At(SC5->C5_TIPO,"CIP") > 0 )
	lLiber := .F.
EndIf
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)

//Ŀ
//Posiciona Registros                                                     
//
If ( At(SC5->C5_TIPO,"DB") == 0 .And. SF4->F4_DUPLIC=='S' )
	dbSelectArea("SA1")
	dbSetOrder(1)
	MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
	lTravas := RecLock("SA1")
EndIf

dbSelectArea("SB2")
dbSetOrder(1)
If ( MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+SC6->C6_LOCAL) .And. lTravas )
	lTravas := RecLock("SB2")
EndIf
//Ŀ
//Verifica se o SB2 e o SA1 estao Travados                                
//
If ( lTravas )
	//Ŀ
	//Complementos nao devem ter o Credito ou Estoque Avaliado.               
	//Devolucao de Poder de Terceiro nao deve ter o Credito avaliado.         
	//
	If ( AT(SC5->C5_TIPO,"CIP") > 0 .Or. ( SF4->F4_PODER3 == "D" .And. SF4->F4_ESTOQUE=="N") .Or. MaTesSel(SF4->F4_CODIGO) )
		lEstoque := .T.
		lCredito := .T.
	Else
		//Ŀ
		//Avaliacao de Estoque                                                    
		//
		If ( lAvEst )
			//Ŀ
			//Somente avalia-se estoque quando ha movimentacao e nao ha reserva       
			//
			If ( SF4->F4_ESTOQUE == "S" .And. Empty(SC6->C6_RESERVA) )
				If SuperGetMV("MV_AVALEST")==3 .And. !AtIsRotina("MATA455")
					If !((Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO)) .And. SuperGetMv("MV_GERABLQ")=="N")
						lEstoque := .F.
						For nX := 1 To Len( aEmpBN )
							A410LibBen(1,aEmpBN[nX,1],aEmpBN[nX,2],SC6->C6_QTDVEN,SC6->C6_UNSVEN)
						Next
					Else
						lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho)						
					EndIf	
				Else
					lEstoque := A440VerSB2(@nQtdLib,lLiber,lTransf,@aLocal,@aEmpenho)
				EndIf
			Else
				If ( !Empty(SC6->C6_RESERVA) )
					lEstoque := .T.
					
					If cPaisLoc<>"BRA" .AND. SC6->C6_QTDRESE == 0
						nQtdLib := Min(SC6->C6_QTDVEN,nQtdLib)
					Else
						nQtdLib := Min(SC6->C6_QTDRESE,nQtdLib)
					EndIf
					
				Else
					lEstoque := .T.
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Avaliacao de Credito                                                    
		//
		If ( lAvCred )
			If ( !SC5->C5_TIPO $ "DB" )
				If ( SF4->F4_DUPLIC == "S" .Or. SuperGetMv("MV_LIBNODP")=="S" )
					If ( lBlqCrd .And. !lEstoque )
						lCredito := .F.
						cBlCred  := "02"
					Else
						If lMTValAvC
							nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'A440GERAC9',SC6->C6_PRCVEN*nQtdLib,Nil})
						Else
							nValAv	:=	SC6->C6_PRCVEN*nQtdLib
						Endif
						//A variavel nValItPed (Private) he criada nas funcoes:(A440Grava, A410Grava e a440Proces)
						If nMvTipCrd == 2 .AND. FindFunction("FatCredTools") .AND. Type("nValItPed") <> "U" 
							
							If nValItPed == 0
								//Consulta os titulos em aberto
								nVlrTitAbe := SldCliente(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
								//Consulta os titulos em atraso				
								nVlrTitAtr := CrdXTitAtr(SC9->C9_CLIENTE + SC9->C9_LOJA, Nil, Nil, .F.)
							EndIf
							
							nValItPed += nValAv
							
							LJMsgRun(STR0010,,{|| lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)})//"Aguarde... Efetuando Analise de Crdito."
							//lCredito := FatCredTools(SA1->A1_COD,SA1->A1_LOJA, nValItPed, nVlrTitAbe, nVlrTitAtr)
						Else
							lCredito := MaAvalCred(SA1->A1_COD,SA1->A1_LOJA,nValAV,SC5->C5_MOEDA,.T.,@cBlCred,@aEmpenho,@nVlrCred)
						EndIf
					EndIf
				Else
					lCredito := .T.
				EndIf
			Else
				lCredito := .T.
			EndIf
		EndIf
	EndIf
EndIf
//Ŀ
//Para e-Commerce ira gravar com bloqueio de credito para Boleto(FI) e sem   
//bloqueio para os demais.                                                   
//
If  lECommerce .And. !( Empty(SC5->C5_ORCRES) ) .And. ChkFile("MF5")
    MF5->( DbSetOrder(1) ) //MF5_FILIAL+MF5_ECALIA+MF5_ECVCHV

    cOrcamto := Posicione("SL1",1,xFilial("SL1")+SC5->C5_ORCRES,"L1_ORCRES")
    
    If  !( Empty(cOrcamto) ) .And. !( Empty(Posicione("MF5",1,xFilial("MF5")+"SL1"+xFilial("SL1")+cOrcamto,"MF5_ECPEDI")) )
	    If  (Alltrim(SL1->L1_FORMPG) == "FI") .And. (MF5->MF5_ECPAGO != "1")
	    	cBlCred  := "02"
	    	lCredito := .F.
	    Else	
	    	cBlCred  := "  "
	    	lCredito := .T.
	    EndIf
    EndIf
EndIf
//Ŀ
//Neste momento eh gerado os empenhos e o SC9 dependendo do caso          
//
If ( lTravas .And. (SC5->C5_TIPO$"CIP" .Or. nQtdLib > 0 .Or. MaTesSel(SF4->F4_CODIGO)) )
	//Ŀ
	//Busca dados ref. ao Beneficiamento no SB6 para gerar Registros no SC9 
	//
	If ( SF4->F4_PODER3=='D' .And. !(SC5->C5_TIPO$"CIPD") )
		nQtdPoder3 := nQtdLib
	Else
		If lCredito .And. lEstoque
			aSaldos := MaNeedP3(nQtdLib)
			nQtdNosso := aSaldos[1]
			nQtdPoder3:= aSaldos[2]
			nQtdNPT   := aSaldos[3]
		Else
			nQtdNosso := nQtdLib
		EndIf
	EndIf
	//Ŀ
	//Verifica os codigos de bloqueio                                         
	//
	If ( Empty(cBlCred) )
		If ( !lCredito )
			If At(SC5->C5_TIPO,"DB") == 0 .And. SF4->F4_DUPLIC == 'S' .And. SC5->C5_TIPLIB == "2" .And.;
				( !Empty(SA1->A1_VENCLC) .And. SA1->A1_VENCLC < dDataBase ) .And. nVlrCred <= 0
				cBlCred := "04"		//Vencimento do Limite de Credito
			Else
				cBlCred := "01"
			EndIf
		EndIf
	EndIf
	If ( Empty(cBlEst) )
		If ( !lEstoque )
			cBlEst := "02"
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada do poder de terceiros           
	//
	If nQtdPoder3 > 0
		//Ŀ
		//Posiciona Registros                                              
		//
		dbSelectArea("SB6")
		If Empty(SC6->C6_IDENTB6)
			dbSetOrder(1)
		Else
			dbSetOrder(3)
		EndIf		
		#IFDEF TOP
			cAliasSB6 := "A440GERAC9"
			lQuery    := .T.
			aStruSB6  := SB6->(dbStruct())
			SB6->(dbCommit())						

			cQuery := "SELECT B6_FILIAL,B6_CLIFOR,B6_LOJA,B6_IDENT,B6_PRODUTO,"
			cQuery += "B6_QULIB,B6_SALDO "
			cQuery += "FROM "+RetSqlName("SB6")+" SB6 "
			cQuery += "WHERE SB6.B6_FILIAL='"+xFilial("SB6")+"' AND "
			cQuery += "SB6.B6_PRODUTO='"+SC6->C6_PRODUTO+"' AND "
			If !Empty(SC6->C6_IDENTB6)
				cQuery += "SB6.B6_IDENT='"+SC6->C6_IDENTB6+"' AND "
			EndIf
			cQuery += "(SB6.B6_SALDO-SB6.B6_QULIB)>0 AND "
			cQuery += "SB6.D_E_L_E_T_=' ' "
			cQuery += "ORDER BY "+SqlOrder(SB6->(IndexKey()))

			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasSB6,.T.,.T.)
			For nX := 1 To Len(aStruSB6)
				If aStruSB6[nX][2] <> "C" .And. FieldPos(aStruSB6[nX][1])<>0
					TcSetField(cAliasSB6,aStruSB6[nX][1],aStruSB6[nX][2],aStruSB6[nX][3],aStruSB6[nX][4])
				EndIf
			Next nX
		#ELSE
			If Empty(SC6->C6_IDENTB6)
				MsSeek(xFilial("SB6")+SC6->C6_PRODUTO)
			Else
				MsSeek(xFilial("SB6")+SC6->C6_IDENTB6+SC6->C6_PRODUTO)
			EndIf
		#ENDIF
		While (!Eof() .And.  xFilial("SB6") == (cAliasSB6)->B6_FILIAL .And.;
				IIf(Empty(SC6->C6_IDENTB6),.T.,;				
				SC6->C6_IDENTB6==(cAliasSB6)->B6_IDENT) .And.;
				SC6->C6_PRODUTO==(cAliasSB6)->B6_PRODUTO .And.;
				nQtdPoder3 > 0 )
			nSldSB6 := ( (cAliasSB6)->B6_SALDO - (cAliasSB6)->B6_QULIB )
			If ( nSldSB6 > 0 )
				nSldSb6 := Min(nSldSB6,nQtdPoder3)
				If !( ( Rastro(SC6->C6_PRODUTO).Or.Localiza(SC6->C6_PRODUTO) ) .And.;
						SuperGetMv("MV_GERABLQ")=="N" .And. !lEstoque )
					MaGravaSc9(nSldSb6,cBlCred,cBlEst,@aLocal,@aEmpenho,(cAliasSB6)->B6_IDENT,bBlock,aEmpPronto,nQtdLib2,@nVlrCred)
					nQtdJaLib += nSldSb6
				EndIf
				nQtdPoder3 -= nSldSB6
			EndIf
			dbSelectArea(cAliasSB6)
			dbSkip()
		EndDo
		If lQuery
			dbSelectArea(cAliasSB6)
			dbCloseArea()
			dbSelectArea("SB6")
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada - Nossa em Terceiros            
	//
	If nQtdNPT > 0
		//Ŀ
		//Verificacao do Parametro MV_GERABLQ                                     
		//
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO)) .And.;
				SuperGetMv("MV_GERABLQ")=="N" .And. !lEstoque )
			MaGravaSc9(nQtdNPT,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,,@nVlrCred,"03")
			nQtdJaLib += nQtdNPT
		EndIf
	EndIf
	//Ŀ
	//Tratamento da quantidade a ser liberada - Nosso Poder                   
	//

	If nQtdNosso > 0 .Or. MaTesSel(SF4->F4_CODIGO)	.Or. Ma440Compl()
		//Ŀ
		//Verificacao do Parametro MV_GERABLQ                                     
		//
		If !( (Rastro(SC6->C6_PRODUTO) .Or. Localiza(SC6->C6_PRODUTO)) .And.;
				SuperGetMv("MV_GERABLQ")=="N" .And. !lEstoque )
			MaGravaSc9(nQtdNosso,cBlCred,cBlEst,@aLocal,@aEmpenho,,bBlock,aEmpPronto,nQtdLib2,@nVlrCred,,lOkExpedicao)
			nQtdJaLib += nQtdNosso
		EndIf
		//Ŀ
		//Verificacao do Parametro MV_GRVBLQ2                                     
		//
		If ( SuperGetMv("MV_GRVBLQ2" ) .And. aEmpenho == Nil )
			If ( nQtdLib <> SC6->C6_QTDLIB ) .OR. ( SC6->C6_QTDLIB <> 0 )
				nQtdLib := SC6->C6_QTDLIB
				If ( nQtdLib <> 0 )
					If !lCredito
						lAvEst := .F.
						lEstoque := .F.
					Else
						lAvEst := .T.
					EndIf
					nQtdJaLib += a440GeraC9(nQtdLib,lCredito,lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,aEmpPronto,lTrocaLot,lOkExpedicao,@nVlrCred)
				EndIf
			EndIf
		EndIf
	EndIf
EndIf
If ( lTravas )
	//Ŀ
	//Atualiza a quantidade liberada para zero                                
	//
	If ( aEmpenho == Nil )
		SC6->C6_QTDLIB  := 0
		SC6->C6_QTDLIB2 := 0
	EndIf
EndIf
If ( !lTravas )
	lCredito := .F.
	lEstoque := .F.
	nQtdLib  := 0
EndIf
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aArea)
Return(nQtdJaLib)

/*/


Ŀ
Funcao    MaGravaSC9 Autor Eduardo Riera           Data 19.03.99  
Ĵ
Descrio Gravacao da Liberacao do pedido de Venda                    
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpN1: Quantidade a Ser Liberada                            
          ExpC2: Codigo do Bloqueio de Credito                        
                 "01" - Bloqueio de Credito por valor                 
                 "04" - Bloqueio por Vencimento do Limite de Credito  
          ExpC3: Codigo do Bloqueio de Estoque                        
                 "02" - Bloqueio de Estoque                           
          ExpA4: Array com os locais a serem transferidos             
          ExpA5: Empenhos ( Caso seja informado nao efetua a gravacao 
                 apenas avalia ).                                     
          ExpC6: Identificador do SB6                                 
          Expb7: CodBlock a ser avaliado na gravacao do SC9           
          ExpA8: Array com Empenhos previamente escolhidos            
                 (impede selecao dos empenhos pelas rotinas)          
          ExpN9: Quantidade a ser liberada na segunda UM              
          ExpNA: Valor a ser adicionado ao limite de credito          
          ExpCB: Codigo de bloqueio do WMS                            
                     01 - Bloqueio de Enderecamento do WMS/Somente SB2
                     02 - Bloqueio de Enderecamento do WMS            
                     03 - Bloqueio de WMS - Externo                   
Ĵ
Observacao1) Esta funcao deve gerar os empenhos de Lote e Localizacao 
          2) Quando ha Reserva no SC6 os empenhos ja foram efetuados  
             mas devem ser trocados.                                  
          3) deve estar numa transacao                                
          4) SC5/SC6 devem estar posicionados e travados              
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
16/05/2007Norbert Waage  Bops 125161 - Atualizacao do status do orca-
                         mento no Televendas (SIGATMK) apos liberacao
ٱ


/*/
Static Function MaGravaSC9(nQtdLib,cBlqCred,cBlqEst,aLocal,aEmpenho,cIdentB6,bBlock,aEmpPronto,nQtdLib2,nVlrCred,cBlqWMS,lOkExpedicao)

Static lMA440GrLt
Static cTiposLC

Local aArea    	:= GetArea(Alias())
Local aAreaSA1 	:= SA1->(GetArea())
Local aAreaSB2 	:= SB2->(GetArea())
Local aAreaSF4 	:= SF4->(GetArea())
Local aAreaSB1 	:= SB1->(GetArea())
Local aAuxiliar := {}
Local aLocaliz  := {}
Local aSaldos   := {}
Local nX        := 0
Local nY        := 0
Local nAuxiliar := 0
Local nQtdRese  := 0
Local nMCusto   := 0
Local nSaveSX8  := GetSX8Len()
Local nRegEmp   := 0
Local cQuery    := ""
Local cNameQry  := ""
Local cSeqSC9   := "00"
Local cReserva  := ""
Local cSeekDCF  := ''
Local lAtualiza := If(aEmpenho==Nil,.T.,.F.)
Local lEstoque  := .F.
Local lCredito  := .F.
Local lHasWMS   := IntDl(SC6->C6_PRODUTO) .And. !Empty(SC6->C6_SERVIC) //-- Soh considera o uso do WMS se houver Servico Preenchido para o Item do SC6
Local lUsaVenc  := .F.
Local lReserva  := .F.
Local lEmpenha  := .F.
Local lResEst   := SuperGetMv("MV_RESEST")
Local lIntACD	:= SuperGetMV("MV_INTACD",.F.,"0") == "1"
Local dValidLote:= Ctod( "" )
Local nRecSC9   := 0
Local nPrcVen   := 0
Local nTotSC9   := 0
Local nTotSC9Aux := 0
Local nDecimal   := TamSx3("C9_PRCVEN")[2]
//Ŀ
//Tratamento para e-Commerce      
//
Local lECommerce := SuperGetMV("MV_LJECOMM",,.F.) .And. GetRpoRelease("R5")

DEFAULT cBlqWms      := ""
DEFAULT cIdentB6     := ""
DEFAULT lMA440GrLt   := ExistBlock("MA440GRLT")
DEFAULT aEmpPronto   := {}
DEFAULT cTiposLC     := GetSESTipos({ || ES_SALDUP == "2"},"1")
DEFAULT lOkExpedicao := .F.

//Ŀ
// Configura a reserva de estoque quando for e-Commerce                   
//
If  lECommerce .AND. !( Empty(SC5->C5_ORCRES) ) .AND. SL1->( FieldPos("L1_ECFLAG") > 0 ) .AND. (Posicione("SL1",1,xFilial("SL1")+SC5->C5_ORCRES,"L1_ECFLAG")=="1")
	lResEst := .T.
EndIf

//Ŀ
// Baixa as qtdes transferidas para o local do pedido  
//
If ( lAtualiza )
	For nX :=1 To Len(aLocal)
		MaTrfLocal(SC6->C6_PRODUTO,aLocal[nX][1],SC6->C6_LOCAL,aLocal[nX][2],SC6->C6_NUM,.F.)
	Next nX
EndIf
//Ŀ
//Posiciona Registros                                                     
//
dbSelectArea("SF4")
dbSetOrder(1)
MsSeek(xFilial("SF4")+SC6->C6_TES)
//Ŀ
//Verifica a Sequencia de Liberacao do SC9                                
//
#IFDEF TOP
	If ( TcSrvType()<>"AS/400" )
		SC9->(dbCommit())
		cNameQry := "MAGRAVASC9"

		cQuery := "SELECT MAX(C9_SEQUEN) SEQUEN "
		cQuery +=   "FROM "+RetSqlName("SC9")+" SC9 "
		cQuery +=   "WHERE C9_FILIAL='"+xFilial("SC9")+"' AND "
		cQuery +=         "C9_PEDIDO='"+SC6->C6_NUM+"' AND "
		cQuery +=         "C9_ITEM='"+SC6->C6_ITEM+"' AND "
		cQuery +=         "SC9.D_E_L_E_T_<>'*'"

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cNameQry,.T.,.T.)
		If !Empty(SEQUEN)
			cSeqSC9 := AllTrim(SEQUEN)
		EndIf
		dbCloseArea()
		dbSelectArea("SC9")
	Else
#ENDIF
	dbSelectArea("SC9")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM,.F.) )
		While ( !Eof() .And. SC9->C9_FILIAL == xFilial("SC9") .And.;
				SC9->C9_PEDIDO == SC6->C6_NUM .And.;
				SC9->C9_ITEM   == SC6->C6_ITEM )
			If ( SC9->C9_PRODUTO == SC6->C6_PRODUTO )
				cSeqSC9  := SC9->C9_SEQUEN
			EndIf
			dbSelectArea("SC9")
			dbSkip()
		Enddo
	EndIf
	#IFDEF TOP
	EndIf
	#ENDIF
cSeqSC9 := Soma1(cSeqSC9,Len(SC9->C9_SEQUEN))
//Ŀ
//Inicializa as variaveis                                                 
//
nQtdLib2  := If(nQtdLib2==Nil,SB1->(ConvUm(SC6->C6_PRODUTO,nQtdLib,0,2)),nQtdLib2)
If nQtdLib2 == 0 .And. SC6->C6_UNSVEN <> 0
	If Empty( SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT-nQtdLib )
		//Ŀ
		// Se baixou toda a quantidade na primeira UM, baixa totalmente a segunda UM 
		//
		nQtdLib2 := SC6->C6_UNSVEN-SC6->C6_QTDEMP2-SC6->C6_QTDENT2
	Else
		//Ŀ
		// Se nao, baixa proporcionamenre a quantidade baixada na primeira UM     
		//
		nQtdLib2 := nQtdLib*SC6->C6_UNSVEN/SC6->C6_QTDVEN
	EndIf
	SC6->C6_QTDLIB2:= nQtdLib2
	nQtdLib2 := SC6->C6_QTDLIB2
EndIf
lReserva  := !Empty(SC6->C6_RESERVA)
lEstoque  := Empty(AllTrim(cBlqEst))
lCredito  := Empty(AllTrim(cBlqCred))
If ( SF4->F4_ESTOQUE=="S" .And. nQtdLib > 0 .And. lEstoque .And. (lCredito .Or. lResEst) .And. lAtualiza)
	//Ŀ
	//Verifica os novos lotes.                                                
	//
	If !Rastro(SC6->C6_PRODUTO) .And. !Localiza(SC6->C6_PRODUTO)
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
		EndIf
		aLocaliz := { aSaldos }
	Else
		//Ŀ
		// Ponto de Entrada p/ movimentar estoque antes da selecao Lote X Localiz.
		//
		If lMA440GrLt
			ExecBlock("MA440GRLT",.F.,.F.,{SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI})
		EndIf
		//Ŀ
		// Verifica se devem ser escolhidos Lotes/Sub-Lotes/Localizacao ou nao    
		//
		If Len(aEmpPronto) > 0
			aSaldos := ACLONE(aEmpPronto)
			lEmpenha := .T.
		Else
			lUsaVenc:= If(!Empty(SC6->C6_LOTECTL+SC6->C6_NUMLOTE),.T.,(SuperGetMv('MV_LOTVENC')=='S'))
			If ( !lHasWMS .Or. !Empty(SC6->C6_LOCALIZ+SC6->C6_NUMSERI) ) .And. (!lReserva .Or. (lReserva .And. Rastro(SC6->C6_PRODUTO) .And. Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE)))
				aSaldos := SldPorLote(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,nQtdLib2,SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,NIL,NIL,NIL,lUsaVenc,nil,nil,dDataBase)
				lEmpenha := .T.
			Else
				SC0->( dbSetOrder(1) )
				If !Empty(SC6->C6_RESERVA) .And.;
					(xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
					SC0->( dbSeek( xFilial("SC0")+SC6->C6_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL ) ) )

					//Ŀ
					// Pesquisa a data de validade dos lotes                                  
					//
					If Rastro(SC6->C6_PRODUTO,"L")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL ) )
						dValidLote := SB8->B8_DTVALID
					ElseIf Rastro(SC6->C6_PRODUTO,"S")
						SB8->( dbSetOrder( 3 ) )
						SB8->( MsSeek( xFilial( "SB8" ) + SC0->C0_PRODUTO + SC0->C0_LOCAL + SC0->C0_LOTECTL + SC0->C0_NUMLOTE ) )
						dValidLote := SB8->B8_DTVALID
					Else
						dValidLote := Ctod( "" )
					EndIf

					aSaldos := {{ SC0->C0_LOTECTL,SC0->C0_NUMLOTE,SC0->C0_LOCALIZ,SC0->C0_NUMSERI,nQtdLib,nQtdLib2,dValidLote,"","","",SC0->C0_LOCAL,0}}
				Else
					cReserva := ""
					lReserva := .F.
					aSaldos := {{ SC6->C6_LOTECTL,SC6->C6_NUMLOTE,SC6->C6_LOCALIZ,SC6->C6_NUMSERI,nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Aglutina os lotes/sub-lotes iguais                                      
		//Quando ha criacao de reservas na liberacao nao se deve aglutinar as     
		//localizacoes fisicas.                                                   
		//
		If ( lCredito .Or. lResEst)
			aAuxiliar := aClone(aSaldos)
			aSaldos   := {}
			For nX := 1 To Len(aAuxiliar)
				nAuxiliar := aScan(aSaldos,{|x|x[1]==aAuxiliar[nX,1] .And.;
					x[2]==aAuxiliar[nX,2] .And.;
					x[11]==aAuxiliar[nX,11] })
				If ( nAuxiliar == 0 )
					AAdd(aSaldos,Array(Len(aAuxiliar[nX])))
					For nY := 1 To Len(aAuxiliar[nX])
						aSaldos[Len(aSaldos)][nY] := aAuxiliar[nX,nY]
					Next nY
					AAdd(aLocaliz,{ aAuxiliar[nX] })
				Else
					//Ŀ
					//Quando aglutina os lotes/sub-lotes iguais com localizacoes diferentes,  
					//limpa a localizacao fisica do array asaldos                             
					//
					If !( aSaldos[nAuxiliar,3] == aAuxiliar[nX,3] )
						aSaldos[nAuxiliar,3] := ""
					EndIf
					aSaldos[nAuxiliar][5] += aAuxiliar[nX,5]
					aSaldos[nAuxiliar][6] += aAuxiliar[nX,6]
					AAdd(aLocaliz[nAuxiliar],aAuxiliar[nX])
				EndIf
			Next nX
		Else
			aLocaliz:= { aSaldos }
		EndIf
	EndIf
Else
	If Len(aEmpPronto) > 0
		aSaldos := ACLONE(aEmpPronto)
		lEmpenha := .T.
	Else
		aSaldos := {{ "","","","",nQtdLib,nQtdLib2,Ctod(""),"","","",SC6->C6_LOCAL,0}}
	EndIf
	aLocaliz:= { aSaldos }
EndIf
//Ŀ
// Verifica se o Bloqueio de Enderecamento do WMS deve ser efetuado       
//
If lHasWMS
	If lEmpenha
		cBlqWMS := "02"
	Else
		//-- Um pedido de venda pode ter liberacoes parciais, essas parciais geram uma sequencia no SC9 gravada em
		//-- C9_SEQUEN, o sistema ira gravar uma nova O.S.WMS referente as liberacoes gravando essa sequencia no campo
		//-- DCF_SEQUEN
		cBlqWMS := '01'
		DCF->(DbSetOrder(2)) //-- FILIAL+SERVIC+DOCTO+SERIE+CLIFOR+LOJA+CODPRO
		If	DCF->(MsSeek(cSeekDCF:=xFilial('DCF')+SC6->C6_SERVIC+PadR(SC6->C6_NUM,Len(DCF->DCF_DOCTO))+PadR(SC6->C6_ITEM,Len(DCF->DCF_SERIE))+SC6->C6_CLI+SC6->C6_LOJA+SC6->C6_PRODUTO))
			While DCF->(!Eof() .And. DCF->DCF_FILIAL + DCF->DCF_SERVIC + DCF->DCF_DOCTO + DCF->DCF_SERIE + DCF->DCF_CLIFOR + DCF->DCF_LOJA + DCF->DCF_CODPRO == cSeekDCF)
				
				If DCF->( FieldPos("DCF_SEQUEN") ) != 0
					If	DCF->DCF_SEQUEN == PadR(cSeqSC9,Len(DCF->DCF_SEQUEN))
						cBlqWMS := '05'
						Exit
					EndIf
				Else
					If	DCF->DCF_NUMSEQ == PadR(cSeqSC9,Len(DCF->DCF_NUMSEQ))
						cBlqWMS := '05'
						Exit
					EndIf
				EndIf
				
				DCF->(DbSkip())
			EndDo
		EndIf
	EndIf
EndIf
//Ŀ
// Verifica se o Bloqueio de Enderecamento do WMS deve ser efetuado       
//
For nX := 1 To Len(aSaldos)
	//Ŀ
	// Efetua a Gravacao do SC9                                               
	//
	If lAtualiza
		//Ŀ
		//Garante o estoque caso haja bloqueio de credito atraves de uma reserva  
		//de material.                                                            
		//
		If !lCredito .And. lResEst .And. SF4->F4_ESTOQUE=="S" .And. !lReserva .And. lEstoque
			cReserva := CriaVar("C0_NUM")
			nQtdRese := aSaldos[nX,5]
			If Empty(cReserva)
				cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
			Else
				While ( GetSX8Len() > nSaveSX8 )
					ConfirmSx8()
				EndDo
			EndIf
			If !a430Reserva({1,"PD",SC5->C5_NUM,"",cFilAnt},@cReserva,;
					SC6->C6_PRODUTO,aSaldos[nX,11],nQtdRese,;
					{aSaldos[nX,2],aSaldos[nX,1],aSaldos[nX,3],aSaldos[nX,4]})
				cReserva := ""
			Else
				//Ŀ
				// Atualiza a qtde em aberto do pedido de venda                 
				//
				dbSelectArea("SB2")
				dbSetOrder(1)
				If ( !MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					CriaSB2( SC6->C6_PRODUTO,aSaldos[nX,11] )
				EndIf
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nQtdRese
				SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD, nQtdRese, 0, 2)
				//Ŀ
				// Atualiza o saldo da reserva                                  
				//
				dbSelectArea("SC0")
				dbSetOrder(1)
				If (xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]==SC0->C0_FILIAL+SC0->C0_NUM+SC0->C0_PRODUTO+SC0->C0_LOCAL .Or. ;
						MsSeek(xFilial("SC0")+cReserva+SC6->C6_PRODUTO+aSaldos[nX,11]) )
					RecLock("SC0")
					SC0->C0_QUANT -= nQtdRese
					SC0->C0_TIPO  := "PD"
					SC0->C0_QTDPED += nQtdRese
				EndIf
				//Ŀ
				// Atualiza o item do pedidod de venda                          
				//
				RecLock("SC6")
				SC6->C6_QTDRESE += nQtdRese
				SC6->C6_RESERVA := cReserva
			EndIf
		Else
			cReserva := SC6->C6_RESERVA
			nQtdRese := SC6->C6_QTDRESE
		EndIf
		nValor := A410Arred(nQtdLib*SC6->C6_PRCVEN,"C6_PRCVEN")
		
		If nX == Len(aSaldos) .And. Len(aSaldos) > 1 .And. Empty(SC6->C6_LOTECTL) .And. Rastro(SC6->C6_PRODUTO)
			nPrcVen := noRound(nValor - nTotSC9,nDecimal) / aSaldos[nX,5]
			nPrcVen := A410Arred(nPrcVen,"C6_PRCVEN")
			If ( SuperGetMv("MV_ARREFAT") == "N" )
				nTotSC9Aux := nTotSC9
				nTotSC9 += a410Arred(aSaldos[nX,5] * nPrcVen ,"C9_PRCVEN")
				If nValor - nTotSC9 <> 0
					nPrcVen += a410Arred((nValor-nTotSC9)/aSaldos[nX,5] ,"C6_PRCVEN")
				EndIf
				nTotSC9 := nTotSC9Aux
			EndIf
		EndIf
		RecLock("SC9",.T.)
		SC9->C9_FILIAL := xFilial("SC9")
		SC9->C9_PEDIDO := SC6->C6_NUM
		SC9->C9_ITEM    := SC6->C6_ITEM
		SC9->C9_SEQUEN  := cSeqSC9
		SC9->C9_PRODUTO := SC6->C6_PRODUTO
		SC9->C9_CLIENTE := SC6->C6_CLI
		SC9->C9_LOJA    := SC6->C6_LOJA
		SC9->C9_PRCVEN  := IIF(nPrcVen==0,SC6->C6_PRCVEN,nPrcVen)
		SC9->C9_DATALIB := dDataBase
		SC9->C9_LOTECTL := aSaldos[nX,1]
		SC9->C9_NUMLOTE := aSaldos[nX,2]
		SC9->C9_QTDLIB  := aSaldos[nX,5]
		SC9->C9_QTDLIB2 := aSaldos[nX,6]
		SC9->C9_DTVALID := aSaldos[nX,7]
		SC9->C9_POTENCI := aSaldos[nX,12]		
		SC9->C9_BLCRED  := cBlqCred
		SC9->C9_BLEST   := cBlqEst
		SC9->C9_BLWMS   := cBlqWMS
		SC9->C9_QTDRESE := Min(nQtdRese,SC9->C9_QTDLIB)
		SC9->C9_RESERVA := cReserva
		SC9->C9_AGREG  := &(SuperGetMv("MV_AGREG"))
		SC9->C9_GRUPO  := &(SuperGetMv("MV_GRUPFAT"))
		SC9->C9_IDENTB6:= cIdentB6
		SC9->C9_LOCAL  := aSaldos[nX,11]
		SC9->C9_SERVIC := SC6->C6_SERVIC
		SC9->C9_PROJPMS:= SC6->C6_PROJPMS
		SC9->C9_TASKPMS:= SC6->C6_TASKPMS
		If SC6->(FieldPos('C6_TRT')) > 0 .And.SC9->(FieldPos('C9_TRT'))  > 0
			SC9->C9_TRT  := SC6->C6_TRT
		Endif	
		SC9->C9_LICITA := SC6->C6_LICITA
		SC9->C9_TPCARGA:= SC5->C5_TPCARGA
		SC9->C9_ENDPAD := SC6->C6_ENDPAD
		SC9->C9_TPESTR := SC6->C6_TPESTR
		SC9->C9_EDTPMS := SC6->C6_EDTPMS
		If ( SC9->( FieldPos('C9_DATENT') ) > 0 )
			SC9->C9_DATENT := SC6->C6_ENTREG
		EndIf
		//Grava tipo da Ordem de Produo na liberao
		If ( SC9->( FieldPos('C9_TPOP') ) > 0 )
			If ( SC6->C6_TPOP == ' ' ) .Or. ( SC6->C6_TPOP == 'F' )
				SC9->C9_TPOP := '1'
			Else
				SC9->C9_TPOP := '2'
			EndIf
		EndIf

	   nTotSC9 += a410Arred(SC9->C9_QTDLIB * SC9->C9_PRCVEN ,"C9_PRCVEN")
		//Ŀ
		// Regra do WMS, onde: 1=Apanhe por Lote/2=Apanhe por Numero de Serie/3=Apanhe por Data 
		//
		SC9->C9_REGWMS := SC6->C6_REGWMS
		//-- Executa bloco de comandos para montagem de cargas (Oms521Car)
		If ( bBlock <> Nil )
			nRecSC9 := SC9->(Recno())
			Eval(bBlock)
			SC9->(dbGoto(nRecSC9))
			If SoftLock("SC9")
				RecLock("SC9",.F.)
			EndIf
		EndIf
		If cPaisLoc == "COL" //Tratamento de Terceros em Vendas
			SC9->C9_NIT := SC6->C6_NIT
		Endif
		If SC9->(FieldPos("C9_CODISS")) > 0
			SC9->C9_CODISS := SC6->C6_CODISS
		Endif
		If SC9->(FieldPos("C9_RETOPER")) > 0
			SB1->(dbSetOrder(1))
			SB1->(dbSeek(xFilial("SB1")+SC6->C6_PRODUTO))
			//Ŀ
			//O campo C9_RETOPER  considerado na quebra de Nota Fiscal.              |
			//Alguns Clientes que migraram da versao 8 para 10 estao tendo problemas  |
			//com esta quebra pois na versao 8 esse campo nao possuia um inicializador| 
			//padrao e muitos produtos estao com esse campo em branco.                |
			//Os campos em branco "" devem ser considerados como "2"=Nao. Assim qdo   |
			//|houver dois produtos ou mais onde alguns estao com os campos em branco e|
			//|e outros com "2" todos devem sair na mesma Nota Fiscal                  |
			//

			If !Empty(SB1->B1_RETOPER)	
				SC9->C9_RETOPER := SB1->B1_RETOPER
			Else
				SC9->C9_RETOPER := "2"
			Endif	
			
		Endif
		If ExistBlock("M440SC9I")
			ExecBlock("M440SC9I",.F.,.F.)
		EndIf
		MaAvalSC9("SC9",1,aLocaliz[nX],Nil,Nil,Nil,Nil,Nil,@nVlrCred,,,,lOkExpedicao)
		//Ŀ
		//Atualiza o orcamento do Televendas, se foi originado a partir
		//dele no modulo Call Center (SIGATMK)                         
		//
		TkAtuTlv(SC9->C9_PEDIDO,2)

		//Ŀ
		// Integracao com o  ACD			  				  
		//
		If lIntACD .And. FindFunction("CBMTA440C9")
			CBMTA440C9()
		//Ŀ
		// Ponto de entrada para todos os itens do pedido.     
		//
		ElseIf ( ExistTemplate("MTA440C9") )
			ExecTemplate("MTA440C9",.F.,.F.)
		EndIf

		//Ŀ
		// Ponto de entrada para todos os itens do pedido.     
		//
		If ( ExistBlock("MTA440C9") )
			ExecBlock("MTA440C9",.F.,.F.)
		EndIf
	Else
		//Ŀ
		//Acumula os dados na variavel aEmpenho                                   
		//
		If ( SF4->F4_ESTOQUE == "S" .And. aSaldos[nX,5] > 0 )
			//Ŀ
			// Atualiza qtde a ser reservada no pedido informado            
			//
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+aSaldos[nX,11])
			RecLock("SB2")
			//Ŀ
			//Verifica se ha bloqueio de estoque                                      
			//
			If ( lCredito .And. lEstoque )
				//Ŀ
				//Atualiza os empenhos quando ha localizacao                              
				//
				nRegEmp := aScan(aEmpenho[2],{|x| x[1]==SB2->(RecNo()) .And.;
					x[3] == SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL })
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[2],{ SB2->(RecNo()),aSaldos[nX,5],SC6->C6_LOCALIZ+SC6->C6_NUMSERI+SC6->C6_NUMLOTE+SC6->C6_LOTECTL,aSaldos[nX,6]})
				Else
					aEmpenho[2][nRegEmp][2] += aSaldos[nX,5]
					aEmpenho[2][nRegEmp][4] += aSaldos[nX,6]
				EndIf
			EndIf
		EndIf
		If ( SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" )
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+SC6->C6_CLI+SC6->C6_LOJA)
			RecLock("SA1")
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
			If ( Empty(cBlqCred) )
				nRegEmp := aScan(aEmpenho[1],{|x| x[1]==SA1->(RecNo())})
				If ( nRegEmp == 0 )
					AAdd(aEmpenho[1],{ SA1->(RecNo()),0,0})
					nRegEmp := Len(aEmpenho[1])
				EndIf
				aEmpenho[1][nRegEmp][2] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
				aEmpenho[1][nRegEmp][3] += xMoeda( aSaldos[nX,5] * SC6->C6_PRCVEN , SC5->C5_MOEDA , nMCusto , dDataBase )
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Incrementa o SC9                                                        
	//
	cSeqSC9 := Soma1(cSeqSC9,Len(SC9->C9_SEQUEN))
Next nX
//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aAreaSF4)
RestArea(aAreaSB1)
RestArea(aArea)
Return(.T.)
/*/


Ŀ
Funcao    MaTrfLocal Autor Eduardo Riera           Data 19.03.99  
Ĵ
Descrio Efetua a transferencia de Locais                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpC1: Produto                                              
          ExpC2: Local de Origem                                      
          ExpC3: Local de Destino                                     
          ExpN4: Quantidade                                           
          ExpC5: Documento                                            
          ExpL6: Indica se eh um estorno                              
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaTrfLocal(cCodPro,cOrigem,cDestino,nQuant,cDocumento,lEstorno)

Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSD3 := SD3->(GetArea())
Local cNumSeq  := ProxNum()
Local aCm      := {}
Local aSd3     := {}
Local nCntFor  := 0
Local nCntFor2 := 0

dbSelectArea("SB1")
dbSetOrder(1)
MsSeek(xFilial("SB1")+cCodPro)

If !lEstorno
	//Ŀ
	//Requisicao do produto e local de origem                                 
	//
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cOrigem) )
		CriaSB2( SB1->B1_COD,cOrigem )
	EndIf
	RecLock("SB2",.F.)

	aCM := PegaCMAtu(SB1->B1_COD,cOrigem)
	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "RE4"
	SD3->D3_CHAVE   := "E0"
	SD3->D3_LOCAL   := cOrigem
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "999"
	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

	//Ŀ
	//Cria almoxarifado de destino                                            
	//
	dbSelectArea("SB2")
	dbSetOrder(1)
	If ( !MsSeek(xFilial("SB2")+SB1->B1_COD+cDestino) )
		CriaSB2( SB1->B1_COD,cDestino )
	EndIf
	RecLock("SB2",.F.)

	RecLock("SD3",.T.)
	SD3->D3_FILIAL  := xFilial("SD3")
	SD3->D3_COD     := SB1->B1_COD
	SD3->D3_QUANT   := nQuant
	SD3->D3_CF      := "DE4"
	SD3->D3_CHAVE   := "E9"
	SD3->D3_LOCAL   := cDestino
	SD3->D3_DOC     := cDocumento
	SD3->D3_EMISSAO := dDatabase
	SD3->D3_UM      := SB1->B1_UM
	SD3->D3_GRUPO   := SB1->B1_GRUPO
	SD3->D3_TIPO    := SB1->B1_TIPO
	SD3->D3_NUMSEQ  := cNumSeq
	SD3->D3_QTSEGUM := ConvUm(SB1->B1_COD,nQuant,0,2)
	SD3->D3_SEGUM   := SB1->B1_SEGUM
	SD3->D3_PARCTOT := "V"
	SD3->D3_TM      := "499"

	aCusto := GravaCusD3(aCM)
	B2AtuComD3(aCusto)

Else
	cDocumento := cDocumento + Space(Len(SD3->D3_DOC) - Len(AllTrim(cDocumento)))
	dbSelectArea("SD3")
	dbSetOrder(2)
	MsSeek(xFilial("SD3")+cDocumento+SB1->B1_COD)
	While ( !Eof() .And. cDocumento== SD3->D3_DOC .And.;
			cCodPro   == SD3->D3_COD )
		If ( SD3->D3_PARCTOT=="V" )
			AAdd(aSd3,{})
			For nCntFor := 1 To SD3->(FCount())
				AAdd(aSD3[Len(aSD3)],SD3->(FieldGet(nCntFor)))
			Next nCntFor
			RecLock("SD3",.F.)
			SD3->D3_ESTORNO := "S"
		EndIf
		dbSelectArea("SD3")
		dbSkip()
	EndDo
	For nCntFor := 1 To Len(aSd3)
		RecLock("SD3",.T.)
		For nCntFor2 := 1 To Len(aSd3[nCntFor])
			SD3->(FieldPut(nCntFor2,aSd3[nCntFor][nCntFor2]))
		Next nCntFor2
		aCm   := PegaCMAtu(SD3->D3_COD,SD3->D3_LOCAL)
		If ( SD3->D3_CF == "DE4" )
			SD3->D3_CF     := "RE4"
			SD3->D3_CHAVE  := "E0"
			SD3->D3_TM     := "999"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		Else
			SD3->D3_CF     := "DE4"
			SD3->D3_CHAVE  := "E9"
			SD3->D3_TM     := "499"
			SD3->D3_ESTORNO:= "S"
			SD3->D3_EMISSAO:= dDataBase
		EndIf
		aCusto := GravaCusD3(aCm)
		B2AtuComD3(aCusto)

	Next nCntFor
EndIf

//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSB1)
RestArea(aAreaSB2)
RestArea(aAreaSD3)
RestArea(aArea)

Return(.T.)

/*/


Ŀ
Funcao    MaAvLibPed Autor Eduardo Riera           Data 23.03.99  
Ĵ
Descrio Verifica se um pedido pode ser totalmente liberado          
Ĵ
Retorno   ExpL1: Pedido pode ser totalmente liberado                  
Ĵ
ParametrosExpC1: Numero do Pedido                                     
          ExpL2: Liberacao Parcial                                    
          ExpL3: Transfere Locais                                     
          ExpL4: lLiberOk                                             
          ExpA5: Registros a serem processados ( Default Todos )      
          Expb6: Code Block a ser avaliado na gravacao do SC9         
          ExpL7: Indica se ha estorno de liberacao                    
          ExpL8: Indica se ha avaliacao de credito                    
          ExpL9: Indica se ha avaliacao de estoque                    
Ĵ
ObservacaoDeve estar numa transacao                                   
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaAvLibPed(cNumPed,lLiber,lTransf,lLiberOk,aRegistros,bBlock,lEstLib,lAvCred,lAvEst,nVlrCred)

Local aArea    := GetArea()
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aAreaSC5 := SC5->(GetArea())
Local aAreaSC6 := SC6->(GetArea())
Local aAreaSC9 := SC9->(GetArea())
Local aEmpenho := {{},{}}
Local lRetorno := .F.
Local lBloqueio:= .F.
Local lLibEst  := .F.
Local lLibCred := .F.
Local lCredito := .F.
Local lEstoque := .F.
Local nX       := 0
Local nQtdLib  := 0
Local nCredito := nVlrCred
lLiberOk := .T.
DEFAULT nVlrCred   := 0
DEFAULT aRegistros := {}
DEFAULT lAvCred    := .T.
DEFAULT lAvEst     := .T.
DEFAULT lEstLib    := .F.
//Ŀ
//MEMORIA DE CALCULO DO ARRAY aEmpenho                                    
//                                                                        
//[1] - SA1                                                               
//[1][1] - Registro                                                       
//[1][2] - A1_SALPEDL                                                     
//[2] - SB2                                                               
//[2][1] - Registro                                                       
//[2][2] - B2_RESERVA                                                     
//                                                                        
//
//Ŀ
//Posiciona Registros                                                     
//
dbSelectArea("SC5")
dbSetOrder(1)
MsSeek(xFilial("SC5")+cNumPed)
lRetorno := RecLock("SC5")
If !( SC5->C5_TIPO$"BD" )
	dbSelectArea("SA1")
	dbSetOrder(1)
	MsSeek(xFilial("SA1")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
	lRetorno := RecLock("SA1")
Else
	dbSelectArea("SA2")
	dbSetOrder(1)
	MsSeek(xFilial("SA2")+SC5->C5_CLIENTE+SC5->C5_LOJACLI)
	lRetorno := RecLock("SA2")
EndIf
//Ŀ
//Verifica o tipo de processamento                                        
//
If Len(aRegistros) > 0
	lLibEst  := .T.
	lLibCred := .T.
	For nX := 1 To Len(aRegistros)
		SC6->(MsGoto(aRegistros[nX]))
		lRetorno := RecLock("SC6")
		If ( lRetorno )			
			If lEstLib
				//Ŀ
				//Verifica a necessidade de estorno da liberacao                          
				//
				nQtdLib := SC6->C6_QTDEMP
				If nQtdLib > 0
					MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nCredito)
					RecLock("SC6")
					SC6->C6_QTDLIB := nQtdLib
				Else
					nQtdLib := SC6->C6_QTDLIB
				EndIf
			Else
				nQtdLib := SC6->C6_QTDLIB
			EndIf
			lCredito := .F. .Or. !lAvCred
			lEstoque := .F.
			MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
		Else
			lCredito := .F.
			lEstoque := .F.
		EndIf
		lLibCred := lCredito .And. lLibCred
		lLibEst  := lEstoque .And. lLibEst
		If ( !lLibEst .And. !lLibCred )
			nX := Len(aRegistros)+1
		EndIf
	Next nX
Else
	lLibEst  := .T.
	lLibCred := .T.
	lBloqueio:= .F.
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+SC5->C5_NUM,.F.)
	While ( !Eof() .And. xFilial("SC6") == SC6->C6_FILIAL .And.;
			SC5->C5_NUM    == SC6->C6_NUM )
		lRetorno := RecLock("SC6")
		If ( lRetorno )
			AAdd(aRegistros,SC6->(RecNo()))
			If !lBloqueio
				lCredito := .F. .Or. !lAvCred
				lEstoque := .F.
				MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,lAvEst,lLiber,lTransf,@aEmpenho,bBlock,Nil,Nil,Nil,@nCredito)
			EndIf
		Else
			lCredito := .F.
			lEstoque := .F.
		EndIf
		lLibCred := lCredito .And. lLibCred
		lLibEst  := lEstoque .And. lLibEst
		If ( !lLibEst .And. !lLibCred )
			lBloqueio := .T.
		EndIf		
		dbSelectArea("SC6")
		dbSkip()
	EndDo
EndIf
//Ŀ
//Atualiza os dados com base no processamento anterior                    
//
lEstoque := .T.
For nX := 1 To Len(aRegistros)
	SC6->(MsGoto(aRegistros[nX]))
	RecLock("SC6")
	If ( !lLibEst .Or. !lLibCred )
		lRetorno := .F.
		If lEstLib
			//Ŀ
			//Verifica a necessidade de estorno da liberacao                          
			//
			nQtdLib := SC6->C6_QTDEMP
			If nQtdLib > 0
				MaAvalSC6("SC6",4,"SC5",Nil,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
			Else
				nQtdLib := SC6->C6_QTDLIB
			EndIf
		Else
			nQtdLib := SC6->C6_QTDLIB
		EndIf
		lCredito := lLibCred
		lEstoque := (lLibCred .And. lLibEst) .Or. (lLibEst .And. lEstoque .And. SuperGetMv("MV_RESEST"))
		MaLibDoFat(SC6->(RecNo()),nQtdLib,@lCredito,@lEstoque,lCredito .And. lAvCred,lEstoque,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
		Do Case
		Case lLibCred <> lCredito .And. lLibCred
			lLibCred := .F.
		Case lLibEst <> lEstoque .And. lLibEst
			lLibEst := .F.
		EndCase
	Else
		MaLibDoFat(SC6->(RecNo()),SC6->C6_QTDLIB,@lCredito,@lEstoque,lAvCred,.T.,lLiber,lTransf,,bBlock,Nil,Nil,Nil,@nVlrCred)
	EndIf
	//Ŀ
	//Verifica se Todos os Itens foram Liberados                              
	//
	If ( SC6->C6_QTDVEN > SC6->C6_QTDEMP + SC6->C6_QTDENT .And. lLiberOk .And. AllTrim(SC6->C6_BLQ)<>"R" )
		lLiberOk := .F.
	EndIf
Next nX
RestArea(aAreaSC9)
RestArea(aAreaSA1)
RestArea(aAreaSF4)
RestArea(aAreaSC5)
RestArea(aAreaSC6)
RestArea(aArea)
Return(lRetorno)

/*/


Ŀ
Funcao    a410Grade  Autor  Eduardo Riera          Data  03.12.98 
Ĵ
Descrio Montagem do aHeader, aCols , aColsGrade e aHeaderGrade.     
          para os itens que possuem grade.                            
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosExpL1: Se True e adionado o controle de Deletados           
          ExpL2: Indica se a chamada eh feita pela Liberacao          
          ExpC3: Alias de referencia ao SC6 ( Query )                 
          ExpL4: Indica se os registros bloqueado devem ser considera-
                 dos.                                                 
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function a410Grade(lDelAcols,lMata440,cAlias,lBloqueados,lCriaCols)

Local nTamaCols:=Len(aCols)
Local nPosItem :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_ITEM"})
Local nPosQtd  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_QTDVEN"})
Local nPosQtd2 :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_UNSVEN"})
Local nPosVlr  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALOR"})
Local nPosPrv  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_PRCVEN"})
Local nPosSld  :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_SLDALIB"})
Local nPosDesc :=aScan(aHeader,{|x| AllTrim(x[2])=="C6_VALDESC"})
Local nCntFor  :=0
Local nItGrade := 1
Local cProdRef := ""
//---------- Variaveis existentes somente para manter legado ate R4
Local cMascara := SuperGetMv("MV_MASCGRD")
Local nTamRef  := Val(Substr(cMascara,1,2))
Local nTamLin  := Val(Substr(cMascara,4,2))
Local nTamCol  := Val(Substr(cMascara,7,2))
//------------------------------------------------------------------
Local cLinha   := ""
Local cColuna  := ""
Local nLinha   := 0
Local nColuna  := 0
DEFAULT lBloqueados := .F.
DEFAULT lCriaCols   := .T.
lMata440 := If(lMata440==Nil,.F.,lMata440)
cAlias   := If(cAlias==Nil,"SC6",cAlias)

If ( nTamAcols <> 0 )
	nItGrade := nTamAcols
	If ( aCols[nTamaCols][nPosItem] <> (cAlias)->C6_ITEM )
		nItGrade ++
	EndIf
EndIf  

cProdRef := (cAlias)->C6_PRODUTO

//Ŀ
//Inicializa o aHeadGrade e o AcolsGrade                                  
//
&(MaReadGrd()):MontaGrade(nItGrade,@cProdRef,,lBloqueados)

cLinha   := AllTrim(Substr((cAlias)->C6_PRODUTO,&(MaReadGrd()):TamRef()+1,&(MaReadGrd()):TamLin()))
cColuna  := AllTrim(Substr((cAlias)->C6_PRODUTO,(&(MaReadGrd()):TamRef()+&(MaReadGrd()):TamLin()+1),&(MaReadGrd()):TamCol()))

nColuna := &(MaReadGrd()):RetPosCol(nItGrade,cColuna)	
nLinha  := &(MaReadGrd()):RetPosLin(nItGrade,cLinha)	
If ( nColuna<>0 .And. nLinha <> 0 )      
	nColuna++
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDVEN")] 	+= (cAlias)->C6_QTDVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDLIB")] 	:= 0
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_QTDENT")] 	:= If(lMata440,(cAlias)->C6_QTDENT+(cAlias)->C6_QTDEMP,(cAlias)->C6_QTDENT)
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_ITEM")]	:= (cAlias)->C6_ITEM
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_UNSVEN")] 	:= (cAlias)->C6_UNSVEN
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_BLQ")] 	:= (cAlias)->C6_BLQ
	&(MaReadGrd()):aColsGrade[nItGrade][nLinha][nColuna][&(MaReadGrd()):GetFieldGrdPos("C6_OPC")] 	:= (cAlias)->C6_OPC
EndIf	
//Ŀ
//Monta o Acols                                                                        
//
// -- Nao monta aCols se for chamada pelo bloco de codigo da FillGetDados
If lCriaCols
	If ( nTamAcols==0 .Or. aCols[nTamAcols][nPosItem] <> (cAlias)->C6_ITEM )
		AAdd(aCols,Array(Len(aHeader)+If(lDelaCols,1,0)))
		nTamAcols++
		For nCntFor := 1 To Len(aHeader)
			If ( aHeader[nCntFor][10] == "V" )
				aCols[nTamAcols][nCntFor] := CriaVar(aHeader[nCntFor][2])
			Else
				aCols[nTamAcols][nCntFor] := (cAlias)->(FieldGet(FieldPos(aHeader[nCntFor][2])))
			EndIf
			If ( AllTrim(aHeader[nCntFor][2]) == "C6_PRODUTO" )
				aCols[nTamAcols][nCntFor] := PadR(cProdRef,Len(SB1->B1_COD))
			EndIf
		Next nCntFor
		If ( lDelaCols )
			aCols[nTamAcols][Len(aHeader)+1] := .F.
		EndIf
	Else
		aCols[nTamAcols][nPosQtd]  += (cAlias)->C6_QTDVEN
		If nPosQtd2 <> 0
			aCols[nTamAcols][nPosQtd2] += (cAlias)->C6_UNSVEN
		EndIf
		If ( nPosDesc > 0 )
			aCols[nTamAcols][nPosDesc] += (cAlias)->C6_VALDESC
		Endif
		If ( nPosSld > 0 )
			aCols[nTamAcols][nPosSld] += Ma440SaLib()
		EndIf
		aCols[nTamAcols][nPosVlr] += (cAlias)->C6_VALOR
	EndIf
EndIf
Return(.T.)

/*/


Ŀ
Funcao    a410Arred  Autor  Eduardo Riera          Data  19.02.99 
Ĵ
Descrio  Retorna o valor com o padrao de arredondamento MV_ARREFAT. 
Ĵ
Retorno    ExpN1: Novo Valor conforme parametro MV_ARREFAT            
Ĵ
Parametros ExpN1: Valor                                               
           ExpC2: Nome do Campo                                       
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function A410Arred(nVArred,cCampo,nMoeda)

Local aArea    := GetArea()
Local aAreaSX3 := SX3->(GetArea())
Local nPosDec  := 0
Local nCasas   := 2

DEFAULT cCampo := "C6_PRCVEN"
DEFAULT __cSX3Casas  := ""
cCampo := Upper(Alltrim(cCampo))

If cPaisLoc<>"BRA" .And. nMoeda<>NIL
	nCasas:=MsDecimais(nMoeda)
Else
	nPosDec := AT(cCampo+"/",__cSX3Casas)
	IF nPosDec <> 0 .And. !SetMdiChild()
		nCasas  := Val(Subs(__cSX3Casas,nPosDec+Len(cCampo)+1,2))
	Else
		nCasas := TamSX3(cCampo)[2]
		If !SetMdiChild()
			__cSX3Casas += cCampo+"/"+StrZero(nCasas,2,0)+"//"
		EndIf
	EndIf
EndIf
If ( SuperGetMv("MV_ARREFAT") == "S" )
	nVArred := Round(nVarred,nCasas)
Else
	nVArred := NoRound(nVarred,nCasas)
EndIf

//Ŀ
//Retorna o estado de entrada                                             
//
RestArea(aAreaSX3)
RestArea(aArea)
Return(nVArred)

/*/


Ŀ
Funcao    Ma440SaLib Autor Eduardo Riera           Data  08.03.99 
Ĵ
Descrio Calculo do Saldo da Quantidade a Liberar.                   
Ĵ
Retorno   ExpN1: Saldo da Quantidade Liberada.                        
Ĵ
ParametrosNenhum                                                      
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function Ma440SaLib()

Local nSaldo := 0

nSaldo := Max(SC6->C6_QTDVEN - SC6->C6_QTDEMP - SC6->C6_QTDENT,0)

Return(nSaldo)

/*/


Ŀ
Funcao    IncNota    Autor Claudia Cabral          Data  08.08.00 
Ĵ
Descrio Inclusao Automatica de Nota Fiscal para a Exportacao(SIGAEEC) |
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNumero do Pedido de Venda                                   
          Serie da Nota Fiscal                                        
          Numero do Embarque de Exportacao                            
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
24/10/2006Ronald Piscion.BOPS 108518: o array aPvlNfs era enviado co-
                         mo parametro para a funcao MaPvlNfs zerado, 
                         quando o nro. de itens era igual ao parame- 
                         tro MV_NUMITEN (var. nItemNF)               
ٱ


/*/

Function IncNota(cC5Num,cSerie,cEmbExp,aNotas)
Local aPvlNfs := {}
Local nPrcVen := 0
Local nItemNf := a460NumIt(cSerie)

Default aNotas := {}

SC5->(DbSetOrder(1))
SC5->(MsSeek(xFilial("SC5")+cC5Num))

SC6->(dbSetOrder(1))
SC6->(MsSeek(xFilial("SC6")+SC5->C5_NUM))

While SC6->(!Eof() .And. C6_FILIAL == xFilial("SC6")) .And.;
		SC6->C6_NUM == SC5->C5_NUM

	SC9->(DbSetOrder(1))
	SC9->(MsSeek(xFilial("SC9")+SC6->(C6_NUM+C6_ITEM))) //FILIAL+NUMERO+ITEM

	SE4->(DbSetOrder(1))
	SE4->(MsSeek(xFilial("SE4")+SC5->C5_CONDPAG) )  //FILIAL+CONDICAO PAGTO

	SB1->(DbSetOrder(1))
	SB1->(MsSeek(xFilial("SB1")+SC6->C6_PRODUTO))    //FILIAL+PRODUTO

	SB2->(DbSetOrder(1))
	SB2->(MsSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL))) //FILIAL+PRODUTO+LOCAL

	SF4->(DbSetOrder(1))
	SF4->(MsSeek(xFilial("SF4")+SC6->C6_TES))   //FILIAL+TES

	nPrcVen := SC9->C9_PRCVEN
	If ( SC5->C5_MOEDA <> 1 )
		nPrcVen := xMoeda(nPrcVen,SC5->C5_MOEDA,1,dDataBase)
	EndIf

	AAdd(aPvlNfs,{ SC9->C9_PEDIDO,;
		SC9->C9_ITEM,;
		SC9->C9_SEQUEN,;
		SC9->C9_QTDLIB,;
		nPrcVen,;
		SC9->C9_PRODUTO,;
		.f.,;
		SC9->(RecNo()),;
		SC5->(RecNo()),;
		SC6->(RecNo()),;
		SE4->(RecNo()),;
		SB1->(RecNo()),;
		SB2->(RecNo()),;
		SF4->(RecNo())})


	If ( Len(aPvlNfs) >= nItemNf )
		cNota := MaPvlNfs(aPvlNfs,cserie , .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
		//cNota := MaPvlNfs(aPvlNfs,cSerie,lMostraCtb,lAglutCtb,lCtbOnLine,lCtbCusto,lReajusta,nCalAcrs,nArredPrcLis,lAtuSA7,lECF,cembexp)
		aPvlNfs := {}
		AAdd( aNotas, { cSerie, cNota } )
	EndIf
	SC6->(DbSkip())
EndDo
If Len(aPvlNfs) > 0
    cNota := MaPvlNfs(aPvlNfs,cserie, .F.    , .F.    , .F.     , .T.    , .F.    , 0      , 0          , .T.  ,.F.,cEmbExp)
    AAdd( aNotas, { cSerie, cNota } )
EndIf

Return

/*/


Ŀ
Funcao    Estorna_PV Autor Claudia Cabral          Data  08.08.00 
Ĵ
Descrio Estorno e Exclusao do Pedido de Venda para a Exportacao (SigaEEC)|
Ĵ
Retorno   Nenhum                                                      
Ĵ
ParametrosNumero do Pedido de Venda                                   
          Matriz de Cabecalho                                         
          Matriz de Itens                                             
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function Estorna_PV(cSC5Num,aMata410Cab,aMata410Itens)

dbSelectArea("SC6")
dbSetOrder(1)    //C6_FILIAL+C6_NUM+C6_ITEM+C6_PRODUTO
If MsSeek(xFilial("SC6")+cSC5Num)
	While !Eof() .and. cSC5Num == SC6->C6_NUM .and. xFilial("SC6") == SC6->C6_FILIAL
		//Ŀ
		// Eliminacao de residuo por item de pedido              
		//
		If SC6->C6_QTDEMP > 0
			dbSelectArea("SC9")
			dbSetOrder(1)
			If MsSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM)
				SC9->(a460Estorna())
			Endif
		Endif

		dbSelectArea("SC6")

		dbSkip()
	EndDo
Endif

MATA410( aMata410Cab ,aMata410Itens , 5 )

Return

/*


Ŀ
Program    FtContGrv Autor  Sergio Silveira        Data 06/12/2000 
Ĵ
Descrio  Gravacao / Exclusao da amarracao                               
Ĵ
Sintaxe    ExpL1 := FtContGrv( ExpC1, ExpC2, ExpA1, [ExpL2] )             
Ĵ
Retorno    ExpL1 -> Indica se gravou                                      
Ĵ
Parametros ExpC1 -> Entidade                                              
           ExpC2 -> Codigo entidade                                    
           ExpA1 -> Array de registros                                    
           ExpL2 -> Indica se e exclusao                                  
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                    
Ĵ
ٱ


*/

Function FtContGrv( cEntidade, cCodEnt, aRecAC8, lExclui )


Local cSeekAC8  := ""
Local lGravou   := .F.
Local lContGrv  := ExistBlock("CONTGRV")

Local nLoop     := 0
Local nLoop2    := 0

DEFAULT lExclui := .F.

If lExclui

	cSeekAC8 := xFilial( "AC8" ) + cEntidade + xFilial( cEntidade ) + cCodEnt
	AC8->( dbSetOrder( 2 ) )
	If AC8->( MsSeek( cSeekAC8 ) )
		lGravou := .T.
		While !AC8->( Eof() ) .And. cSeekAC8 == AC8->AC8_FILIAL + AC8->AC8_ENTIDA + ;
				AC8->AC8_FILENT + AC8->AC8_CODENT
			RecLock( "AC8", .F. )
			AC8->( dbDelete() )
			AC8->( MsUnLock() )
			AC8->( dbSkip() )
		EndDo
	EndIf
Else

	For nLoop := 1 To Len( aCols )
		lGravou := .T.
		If GDDeleted( nLoop )
			If nLoop <= Len( aRecAC8 )
				AC8->( MsGoto( aRecAC8[ nLoop ] ) )
				RecLock( "AC8", .F. )
				AC8->( dbDelete() )
				AC8->( MsUnlock() )
			EndIf
		Else
			If nLoop <= Len( aRecAC8 )
				AC8->( MsGoto( aRecAC8[ nLoop ] ) )
				RecLock( "AC8", .F. )
			Else
				//Ŀ
				// Inclui e grava os campos chave                                         
				//
				RecLock( "AC8", .T. )
				AC8->AC8_FILIAL := xFilial( "AC8" )
				AC8->AC8_FILENT := xFilial( cEntidade )
				AC8->AC8_ENTIDA := cEntidade
				AC8->AC8_CODENT := cCodEnt
			EndIf

			//Ŀ
			// Grava os demais campos                                                 
			//
			For nLoop2 := 1 To Len( aHeader )
				If ( aHeader[nLoop2,10] <> "V" ) .And. !( AllTrim( aHeader[nLoop2,2] ) $ "AC8_FILENT|AC8_ENTIDA|AC8_CODENT" )
					AC8->(FieldPut(FieldPos(aHeader[nLoop2,2]),aCols[nLoop,nLoop2]))
				EndIf
			Next nLoop2

			If ( lContGrv )
				ExecBlock("CONTGRV",.F.,.F.)
			EndIf

			AC8->( MsUnlock() )

		EndIf

	Next nLoop

EndIf

Return( lGravou )

/*


Ŀ
Program   FtContLOK  Autor  Sergio Silveira        Data 08/12/2000 
Ĵ
Descrio  Validacao da linha da amarracao.                            
Ĵ
Sintaxe    ExpL1 := FtContLOK()                                           
Ĵ
Retorno    ExpL1 -> Validacao                                             
Ĵ
Parametros Nenhum                                                         
Ĵ
 ATUALIZACOES SOFRIDAS DESDE A CONSTRUCAO INICIAL.                      
Ĵ
 PROGRAMADOR   DATA    BOPS   MOTIVO DA ALTERACAO                    
Ĵ
ٱ


*/

Function FtContLOK()

Local lRet    := .T.
Local nPosCod := GDFieldPos( "AC8_CODCON" )
Local nLoop   := 0
Local lTK260cnt := ExistBlock("TK260CNT")
If !GDDeleted()

	If Empty( GDFieldGet( "AC8_CODCON" ) )
		lRet := .F.
	EndIf

	If lRet
		For nLoop := 1 To Len( aCols )
			//Ŀ
			// Verifica se existe codigo de contato duplicado                         
			//
			If nLoop <> n .And. !GDDeleted( nLoop )
				If aCols[ nLoop, nPosCod ] == GDFieldGet( "AC8_CODCON" )
					lRet := .F.
					Help( "", 1, "FTCONTDUP" )
				EndIf
			EndIf
		Next nLoop
		If lRet .And. lTK260cnt
			lRet := ExecBlock("TK260CNT",.F.,.F.,{N}) //Manda linha posicionada do aCols
			If ValType(lRet) <> "L"
				lRet := .T.
			EndIf	
		EndIf
	EndIf
Else
	lRet := AC8Exclui(GDFieldGet("AC8_CODCON"),GDFieldGet("AC8_REC_WT"))
EndIf

Return( lRet )

/*/


Ŀ
Funcao    MaAvalSC5  Autor Eduardo Riera           Data 13.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos do Cabecalho do Pedido de   
          Venda.                                                      
Ĵ
ParametrosExpC1: Alias da tabela de Cabecalho do Pedido de Venda      
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do Pedido de Venda                   
                 [2] Estorno do Pedido de Venda                       
                 [3] Liberacao do Pedido de Venda                     
                 [4] Estorno da Liberacao do Pedido de Venda          
                 [5] Preparacao da Nota Fiscal de Saida               
                 [6] Exclusao da Nota Fiscal de Saida                 
                 [7] Reavaliacao de Credito (Por Pedido)              
                 [8] Estorno da Reavalizacao de Credito ( Por Pedido )
          ExpL3: Liberacao Parcial                                    
          ExpL4: Transfere Locais                                     
          ExpL5: Verifica se todos os itens foram liberados           
          ExpL6: Verifica os residuos do pedido de venda              
          ExpL7: Verifica se todos os itens foram faturados           
          ExpL8: Atualiza somente os acumulados          (DEFA: .F.)  
          ExpL9: Indica que todos os itens foram gravado (DEFA: .T.)  
          ExpCA: Numero do Pedido de Venda                      (OPC) 
          ExpAB: Array com os recnos do SC6                     (OPC) 
          ExpLC: Estorna liberacoes anteriores                  (OPC) 
          ExpLD: Avalia Credito                                 (OPC) 
          ExpNE: Valor a ser adicionado ao limite de credito    (OPC) 
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao cabecalho do pedido de venda                             
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
Uso        Materiais                                                  
ٱ


/*/
Function MaAvalSC5(cAliasSC5,nEvento,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,lFinal,cPedido,aRegSC6,lEstLib,lAvCred,nVlrCred)
Local aArea     := GetArea(cAliasSC5)
Local aAreaSC6  := {}
Local lAtuSC5   := .F.
Local lMALibReg := ExistBlock("MALIBREG")

#IFDEF TOP
	Local cQuery    := ""
#ENDIF

DEFAULT lAcumulado:= .F.
DEFAULT lFinal    := .T.
DEFAULT cPedido   := (cAliasSC5)->C5_NUM
DEFAULT nVlrCred  := 0

RecLock("SC5")
Do Case
	//Ŀ
	//Implantacao de um do pedido de venda                                    
	//
Case nEvento == 1
	Do Case
	Case lLiberOk
		(cAliasSC5)->C5_LIBEROK := "S"
	Case lResidOk
		(cAliasSC5)->C5_LIBEROK := "E"
	OtherWise
		(cAliasSC5)->C5_LIBEROK := ""
	EndCase
	If ( lFaturOk )
		//Ŀ
		//Release 11.5 Localizao Chile/Colombia                                  		    
		//Para esses paises ser informada a serie da tela de controle de formularios 			
		//por tanto no zera o campo C5_SERIE que sera alimentada pelo parametro MV_LOJAPED	
		//
		If cPaisloc$"COL|CHI" .AND. nModulo == 12 .AND. !Empty(SC5->C5_ORCRES)
			(cAliasSC5)->C5_NOTA  := ""		
		Else
			(cAliasSC5)->C5_NOTA  := ""
			(cAliasSC5)->C5_SERIE := ""
		EndIf
	Else
		If Empty((cAliasSC5)->C5_NOTA)
			If !((cAliasSC5)->C5_TIPO $ "CIP")
				(cAliasSC5)->C5_NOTA  := "XXXXXX"
				(cAliasSC5)->C5_SERIE := "XXX"
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Integracao com o SIGAEEC                                                
	//
	If GetMv("MV_EECFAT")
		If FindFunction("AE100STATUS")
			AE100STATUS(SC5->C5_PEDEXP)
		EndIf
		If FindFunction("FAT2PEDFAT")
			Fat2PedFat(SC5->C5_NUM,3)
		EndIf
	EndIf	
	If AliasInDic("AID") .And. !lAcumulado
		StartJob("FtJobPvCF",GetEnvServer(),.F.,cEmpAnt,cFilAnt,(cAliasSC5)->C5_NUM)
	EndIf
	If !lAcumulado
		//Ŀ
		// Grava os lancamentos nas contas orcamentarias SIGAPCO    
		//
		PcoDetLan("000100","03","MATA410")
	EndIf	
	//Ŀ
	//Estorno de um pedido de venda                                           
	//
Case nEvento == 2
	//Ŀ
	//Atualiza a tabela de fluxo de caixa do PV        
	//
	If AliasInDic("AID")
		dbSelectArea("AID")
		#IFDEF TOP
			cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
			TcSqlExec(cQuery)
		#ELSE
			dbSelectArea("AID")
			dbSetOrder(1)
			If MsSeek(xFilial("AID")+cPedido)
				While !Eof() .And. xFilial("AID") == AID->AID_FILIAL .And. cPedido == AID->AID_NUMPV
					RecLock("AID")
					dbDelete()
					dbSelectArea("AID")
					dbSkip()
				EndDo
			EndIf
		#ENDIF
	EndIf
	//Ŀ
	//Integracao com o SIGAEEC                                                
	//
	If GetMv("MV_EECFAT")
		If FindFunction("FAT2PEDFAT")
			Fat2PedFat(SC5->C5_NUM,5)
		EndIf
	EndIf		
	//Ŀ
	// Verifica se o Pedido de Venda foi originado pelo TMS                   
	//
	If SC5->(FieldPos("C5_SOLFRE")) > 0 .And. !Empty(SC5->C5_SOLFRE)
		DT4->(dbSetOrder(1))
		//Ŀ
		// Deixa a Solicitacao de Frete Pendente Novamente                        
		//
		If DT4->(MsSeek(xFilial("SC5")+SC5->C5_SOLFRE+SC5->C5_ITESOL) )
			RecLock("DT4",.F.)
			DT4->DT4_STATUS := "01"
		Else
			Help(" ",1, "A410SOLNAO")
		EndIf
	EndIf
	//Ŀ
	//Libera bloqueio de regra ou de verba                                    
	//
	If !__lPyme
		(cAliasSC5)->C5_BLQ := Space(Len(SC5->C5_BLQ))
	EndIf

	//Ŀ
	//Liberacao de um pedido de venda                                         
	//
Case nEvento == 3
	lLiberOk := .F.
	If !lAcumulado .And. lFinal
		MaAvLibPed((cAliasSC5)->C5_NUM,lLiber,lTransf,@lLiberOk,aRegSC6,,lEstLib,lAvCred,Nil,@nVlrCred)
	EndIf
	If ( lLiberOk )
		(cAliasSC5)->C5_LIBEROK := "S"
	EndIf
	//Ŀ
	//Estorno da liberacao do pedido de venda                                 
	//
Case nEvento == 4
	//Ŀ
	// PCO - Estorna os lancamentos de liberacao das contas orcamentarias 
	//
	If !Empty((cAliasSC5)->C5_LIBEROK)
		PcoDetLan("000103","02","MATA440",.T.)
    EndIf
	(cAliasSC5)->C5_LIBEROK := ""
	//Ŀ
	//Preparacao da Nota Fiscal de Saida                                      
	//
Case nEvento == 5
	//Ŀ
	//Atualiza o Pedido de Venda                                              
	//
	#IFDEF TOP
		lAtuSC5 := .T.
		If ( TcSrvType()<>"AS/400" )
			SC6->(dbCommit())
			cQuery  := ""
			cQuery  += "SELECT COUNT(*) NUMERO FROM "+RetSqlName("SC6")+" "
			cQuery  += "WHERE C6_FILIAL='"+xFilial("SC6")+"' AND "
			cQuery  +=     "C6_NUM='"+cPedido+"' AND "
			cQuery  +=     "C6_BLQ<>'R ' AND "
			cQuery  +=     "C6_QTDVEN > C6_QTDENT AND "
			cQuery  +=     "D_E_L_E_T_=' '"
			cQuery := ChangeQuery(cQuery)

			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MAAVALSC5",.F.,.T.)

			If ( NUMERO == 0 )
				lAtuSC5 := .F.
			EndIf
			dbCloseArea()
		Else
	#ENDIF
		lAtuSC5 := .F.
		dbSelectArea("SC6")
		aAreaSC6	:=	SC6->(GetArea())
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+cPedido)
		While ( !Eof() .And. xFilial("SC6") == SC6->C6_FILIAL .And.;
				SC6->C6_NUM    == cPedido     .And.;
				SC6->C6_BLQ    <> "R" )
			If ( SC6->C6_QTDVEN > SC6->C6_QTDENT )
				lAtuSC5 := .T.
				Exit
			EndIf
			dbSelectArea("SC6")
			dbSkip()
		EndDo
		RestArea(aAreaSC6)
		#IFDEF TOP
		EndIf
		#ENDIF
	dbSelectArea("SC5")
	dbSetOrder(1)
	If ( !lAtuSC5 )
		If ( MsSeek(xFilial("SC5")+cPedido) )
			RecLock("SC5",.F.)
			If cPaisLoc == "BRA"
				SC5->C5_NOTA  := SF2->F2_DOC
				SC5->C5_SERIE := SF2->F2_SERIE
			Else
				If IsRemito(1,"SF2->F2_TIPODOC")
					SC5->C5_NOTA  := "REMITO"
					SC5->C5_SERIE := "RXX"
				Else
					SC5->C5_NOTA  := SF2->F2_DOC
					If SC5->C5_SERIE <> "RXX"
						SC5->C5_SERIE := SF2->F2_SERIE
					Endif
				Endif
			Endif
			MsUnlock()
			
			//Ŀ
			//Elimina o saldo do relacionamento de pedidos finalizados.
			//
			If 	FindFunction("A410UsaAdi") 		.AND.;
				A410UsaAdi( SC5->C5_CONDPAG ) 	.AND.; 
				FindFunction("FPedAdtRsd") 
				
				FPedAdtRsd( "R", { SC5->C5_NUM } )
			EndIf			
		EndIf
	EndIf
	//Ŀ
	//Atualiza a tabela de fluxo de caixa do PV        
	//
	If AliasInDic("AID")
		dbSelectArea("AID")
		#IFDEF TOP
			cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
			TcSqlExec(cQuery)
		#ELSE
			dbSelectArea("AID")
			dbSetOrder(1)
			If MsSeek(xFilial("AID")+cPedido)
				While !Eof() .And. xFilial("AID") == AID->AID_FILIAL .And. cPedido == AID->AID_NUMPV
					RecLock("AID")
					dbDelete()
					dbSelectArea("AID")
					dbSkip()
				EndDo
			EndIf
		#ENDIF
	EndIf	
	//Ŀ
	//Atualiza a tabela de fluxo de caixa do PV        
	//
	If AliasInDic("AID")
		dbSelectArea("AID")
		#IFDEF TOP
			cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
			TcSqlExec(cQuery)
		#ELSE
			dbSelectArea("AID")
			dbSetOrder(1)
			If MsSeek(xFilial("AID")+cPedido)
				While !Eof() .And. xFilial("AID") == AID->AID_FILIAL .And. cPedido == AID->AID_NUMPV
					RecLock("AID")
					dbDelete()
					dbSelectArea("AID")
					dbSkip()
				EndDo
			EndIf
		#ENDIF
	EndIf
	
	//Ŀ
	//Estorno da Nota fiscal de Saida                                         
	//
Case nEvento == 6
	//Ŀ
	//Atualiza a tabela de fluxo de caixa do PV        
	//
	If AliasInDic("AID")
		dbSelectArea("AID")
		#IFDEF TOP
			cQuery := "DELETE FROM "+RetSqlName("AID")+" WHERE AID_FILIAL='"+xFilial("AID")+"' AND AID_NUMPV='"+cPedido+"' "
			TcSqlExec(cQuery)
		#ELSE
			dbSelectArea("AID")
			dbSetOrder(1)
			If MsSeek(xFilial("AID")+cPedido)
				While !Eof() .And. xFilial("AID") == AID->AID_FILIAL .And. cPedido == AID->AID_NUMPV
					RecLock("AID")
					dbDelete()
					dbSelectArea("AID")
					dbSkip()
				EndDo
			EndIf
		#ENDIF
	EndIf
	If cPaisLoc=="BRA"
		(cAliasSC5)->C5_LIBEROK := ""
		(cAliasSC5)->C5_SERIE   := ""
		(cAliasSC5)->C5_NOTA    := ""
	Else
		If Empty(SD2->D2_REMITO)
			(cAliasSC5)->C5_LIBEROK := ""
			(cAliasSC5)->C5_SERIE   := ""
			(cAliasSC5)->C5_NOTA    := ""
		Else
			If (cAliasSC5)->C5_SERIE == "RXX"
				(cAliasSC5)->C5_NOTA := "REMITO"
			Else
				(cAliasSC5)->C5_NOTA  := ""
				(cAliasSC5)->C5_SERIE := ""
			Endif
		Endif
	Endif
		
	//Ŀ
	//Liberacao de regras ou verbas                                           
	//
Case nEvento == 9

	dbSelectArea("SC6")
	dbSetOrder(1)
	#IFDEF TOP

		cAliasSC6 := "QRYSC6"

		dbSelectArea('SC6')
		dbCommit() //-- Atualiza as gravacoes pendentes na tabela

		cQuery := "UPDATE "+RetSqlName("SC6")
		cQuery += " SET C6_BLOQUEI = '  ' "
		cQuery += " WHERE C6_FILIAL='"+xFilial('SC6')+"' AND "
		cQuery += " C6_NUM='"+SC5->C5_NUM+"' AND "
		cQuery += "(C6_BLOQUEI = '01' OR C6_BLOQUEI = '02') AND "
		cQuery += " D_E_L_E_T_ = ' '"

		TcSqlExec(cQuery)
		dbGoto(Recno()) //-- Reposiciona na tabela/registro atual somente para atualizar gravacoes pendentes

	#ELSE

		aAreaSC6 := SC6->(GetArea())

		SC6->(dbSetOrder(1))
		If SC6->(MsSeek(xFilial("SC6")+SC5->C5_NUM))
			While SC6->( !Eof() ) .And. SC6->C6_FILIAL == xFilial("SC6") .And. ;
											SC6->C6_NUM == SC5->C5_NUM

				RecLock("SC6",.F.)
				SC6->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))
				MsUnlock()

				SC6->(dbSkip())

			EndDo

		Endif

		RestArea(aAreaSC6)

	#ENDIF

	Reclock("SC5",.F.)
	SC5->C5_BLQ :=Space(Len(SC5->C5_BLQ))
	MsUnlock()	

	If lMALibReg
		ExecBlock("MALIBREG",.F.,.F.,{SC5->C5_NUM})
	EndIf

EndCase
RestArea(aArea)

//-- Ponto de entrada apos avaliacao dos eventos do cabecalho do Pedido de Vendas.
If ExistBlock("MAAVSC5")
	ExecBlock("MAAVSC5",.F.,.F.,{nEvento})
EndIf

Return(.T.)
/*/


Ŀ
Funcao    MaAvalSC6  Autor Eduardo Riera           Data 13.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos do item do Pedido de Venda  
Ĵ
ParametrosExpC1: Alias da tabela dos itens do Pedido de Venda         
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do Pedido de Venda                   
                 [2] Estorno  do Pedido de Venda                      
                 [3] Liberacao do Pedido de Venda                     
                 [4] Estorno da Liberacao do Pedido de Venda          
                 [5] Preparacao da Nota Fiscal de Saida               
                 [6] Estorno da Nota Fiscal de Saida                  
          ExpC3: Alias do pedido de venda                             
          ExpL4: Liberacao Parcial                                    
          ExpL5: Transfere Locais                                     
          ExpL6: Verifica se todos os itens foram liberados           
          ExpL7: Verifica os residuos do pedido de venda              
          ExpL8: Verifica se todos os itens foram faturados           
          ExpL9: Atualiza somente os acumulados                       
          ExpNA: Valor a ser adicionado ao limite de credito          
          ExpCB: Alias do SD2 ( Uso Interno para otimizacao )         
          ExpLC: Indica se esta o SC6 esta sendo baixado por un REMITO
          ExpCD: Moeda do pedido de venda ( opcional )                
          ExpLE: Validacao regra de negocios pelo Televendas          
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao item do pedido de venda.                                 
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
Uso        Materiais                                                  
Ĵ
Michel M. 29/03/078.11  Bops: 119212 - Corrigido nao-conformidade   
                        ao tentar Travar registro com o SA1 em EOF. 
                                                                	  
Norbert W.12/04/079.12  Bops: 122632 - Removido o codigo onde o cam-
                        po C5_BLQ era limpo a cada validacao do SC6,
                        eliminando o bloqueio de um item anterior.  
ٱ


/*/
Function MaAvalSC6(cAliasSC6,;
					nEvento,;
					cAliasSC5,;
					lLiber,;
					lTransf,;
					lLiberOk,;
					lResidOk,;
					lFaturOk,;
					lAcumulado,;
					nVlrCred,;
					cAliasSD2,;
					lRemito,;
					nMoeda,;
					lTLVReg)

Local aArea    := GetArea(cAliasSC6)
Local aAreaSA1 := SA1->(GetArea())
Local aAreaSB2 := SB2->(GetArea())
Local aAreaSF4 := SF4->(GetArea())
Local aProdDesc:= {}
Local nQtdRese := 0
Local nQtdLib  := 0
Local nQtdLib2 := 0
Local nSldPed  := 0
Local nSldPed2 := 0
Local nMCusto  := 0

Local nSaveSX8 := GetSX8Len()
Local cReserva := ""
Local cPedido  := ""
Local cItemPV  := ""
Local cProduto := ""
Local cTipoPV  := ""
Local cTipLib  := ""
Local cRet     := ""
Local dEmissao := Ctod("")
Local lContinua:= .T.
Local lCredito := .F.
Local lEstoque := .F.
Local lTipoAB7 := .F.
Local lResAut  := SuperGetMv("MV_RESAUT")
Local lTipRes  := SuperGetMv("MV_TIPRES")

Local lBlqReg  := .F.
Local lProgEnt := .F.	//Indica se o Pedido de Venda foi gerado por uma Programao de Entrega

#IFNDEF TOP
	Local nRecACM  := 0
#ENDIF

//Ŀ
//Inicializa variaveis                                                    
//
DEFAULT cAliasSC5 := "SC5"
DEFAULT cAliasSC6 := "SC6"
DEFAULT cAliasSD2 := "SD2"
DEFAULT lLiber    := .F.
DEFAULT lTransf   := .F.
DEFAULT lAcumulado:= .F.
DEFAULT lRemito   := .F.
DEFAULT lTLVReg   := .F.

If !xFilial("SC5")+(cAliasSC6)->C6_NUM==(cAliasSC5)->C5_FILIAL+(cAliasSC5)->C5_NUM .And.;
		!Empty((cAliasSC6)->C6_NUM)
	dbSelectArea("SC5")
	dbSetOrder(1)
	MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM)
EndIf

//Ŀ
// Inicializa a moeda do pedido                                           
//
DEFAULT nMoeda    := (cAliasSC5)->C5_MOEDA

cPedido  := (cAliasSC5)->C5_NUM
cItemPV  := (cAliasSC6)->C6_ITEM
cProduto := (cAliasSC6)->C6_PRODUTO
cTipoPV  := (cAliasSC5)->C5_TIPO
cTipLib  := (cAliasSC5)->C5_TIPLIB
dEmissao := (cAliasSC5)->C5_EMISSAO

Do Case
	//Ŀ
	//Implantacao de um item do pedido de venda                               
	//
Case nEvento == 1

	//Ŀ
	//Posiciona registros                                                     
	//
	If !cTipoPV$'DB'
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES)
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL)
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL)
	EndIf
	//Ŀ
	//Efetua travamento dos registros                                         
	//
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		DBSelectArea("SA1")
		SA1->( DBSetOrder(1) )
		If ( lContinua := SA1->( MsSeek(xFilial("SA1")+(cAliasSC5)->C5_CLIENTE+(cAliasSC5)->C5_LOJACLI,.F.) ) )
			lContinua := RecLock("SA1")
		EndIf
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//Ŀ
	//Avalia se existe regra de negocio ou bloqueio para verificar verba      
	//

	If !__lPyme

		If (cAliasSC5)->C5_TIPO == 'N' .And. (ACN->(dbSeek(xFilial("ACN"))) .Or. AllTrim(SuperGetMv("MV_ESTADO")) == "AL")
			//Ŀ
			//Verifica verba de venda caso nao houve bloqueio de regra de negocio     
			//
			If !lAcumulado .Or. AllTrim(SuperGetMv("MV_ESTADO")) == "AL"
				nDescon   := (100 - ((cAliasSC6)->C6_PRCVEN / (cAliasSC6)->C6_PRUNIT) * 100 )
				aProdDesc := {{(cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_ITEM,(cAliasSC6)->C6_PRCVEN,(cAliasSC6)->C6_PRUNIT,nDescon,0,"",0,Empty((cAliasSC6)->C6_NFORI)}}

				//Ŀ
				//Avalia se Existe Bloqueio de Regra                                      
				//

				If	Upper(FunName())<>"TMKA271" .And.;	//SIGATMK
					Upper(FunName())<>"TMSA200"			//SIGATMS
					If AllTrim(SuperGetMv("MV_ESTADO")) == "AL" //Legislao somente para alagoas
						lBlqReg := BlPVLFat((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_BLQ=="1")
					EndIf
					If !lBlqReg
						lBlqReg := !ACN->(FtRegraNeg((cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_TABELA,(cAliasSC5)->C5_CONDPAG,,@aProdDesc, .F., nil, .F. ))
					EndIf
				EndIf
				If lBlqReg .Or. lTLVReg
					//Ŀ
					//Avalia se existe Bloqueio de Venda                                      
					//
					If aProdDesc[1,7] == "02"
						cRet := ACN->(FtVerbaVen(cAliasSC5,cAliasSC6,(cAliasSC5)->C5_CLIENTE,(cAliasSC5)->C5_LOJACLI,(cAliasSC5)->C5_VEND1,(cAliasSC6)->C6_PRODUTO, @aProdDesc[1],.T. ))
						If cRet <> "1"
							cRet := If(cRet == "3","1","2")
						Else
							cRet := "3"
						EndIf
					Else
						cRet := "1"
					EndIf
				Else
					cRet := "3"
				EndIf
				Do Case
					//Ŀ
					//Grava SC5 / SC6 bloqueados por Verba                                    
					//
					Case cRet == "2"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(2, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)	
						(cAliasSC6)->C6_BLOQUEI :=  StrZero(2, Len(SC6->C6_BLOQUEI))
						//Ŀ
						//Grava SC5 / SC6 bloqueado por Regra                                     
						//
					Case cRet == "1"
						RecLock("SC5", .F.)
						(cAliasSC5)->C5_BLQ := StrZero(1, Len(SC5->C5_BLQ))

						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := StrZero(1, Len(SC6->C6_BLOQUEI))
					OtherWise
						RecLock("SC6", .F.)
						(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))
				EndCase
			EndIf
		EndIf
	EndIf

	If lContinua
		//Ŀ
		// Complemento da atualizacao no item do pedido de venda                  
		//
		If !lAcumulado

			(cAliasSC6)->C6_FILIAL	:= xFilial("SC6")
			(cAliasSC6)->C6_NUM		:= (cAliasSC5)->C5_NUM
			(cAliasSC6)->C6_CLI		:= (cAliasSC5)->C5_CLIENTE
			(cAliasSC6)->C6_LOJA 	:= (cAliasSC5)->C5_LOJACLI
			//Ŀ
			//No grava C6_GERANF para pedido de vendas.
			//
			If cPaisLoc <> "BRA".And. Empty((cAliasSC6)->C6_GERANF)
				(cAliasSC6)->C6_GERANF := If((cAliasSC5)->C5_TIPOREM$"01A","S","N")
			EndIf
			//Ŀ
			// Atualiza as Tabela Auxiliares                                          
			//
			//Ŀ
			// Efetua amarracao com o projeto - SIGATEC                         
			//
			SC5->(FkCommit())
			SC6->(FkCommit())

			ABI->( dbSetOrder( 1 ) )
			If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_PROJET + (cAliasSC6)->C6_ITPROJ ) )
				Reclock( "ABI", .F. )
				ABI->ABI_NUMPV  := (cAliasSC6)->C6_NUM
				ABI->ABI_ITEMPV := (cAliasSC6)->C6_ITEM
				ABI->( MsUnlock() )
			EndIf

			dbSelectArea("AB8")
			dbSetOrder(1)
			If !Empty((cAliasSC6)->C6_NUMOS)
				If MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOS)
					RecLock("AB8")
					AB8->AB8_NUMPV := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					dbSelectArea("AB7")
					dbSetOrder(1)
					If MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8))
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOSFA)
				If ( MsSeek(xFilial("AB8")+(cAliasSC6)->C6_NUMOSFA ) )
					RecLock("AB8")
					AB8->AB8_NUMPVF := (cAliasSC5)->C5_NUM+SC6->C6_ITEM
					dbSelectArea("AB7")
					dbSetOrder(1)
					If MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8))
						RecLock("AB7")
						AB7->AB7_TIPO := AtTipoAB7()
					EndIf
				EndIf
			EndIf
			//Ŀ
			// Atualiza o status da OS ( AB6 )                                  
			//
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				dbSelectArea("AB6")
				dbSetOrder(1)
				If MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
					SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
			//Ŀ
			// Atualiza Contratos de Parceria                                         
			//
			If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
				dbSelectArea("ADB")
				dbSetOrder(1)
				If MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON)
				
					//Ŀ
					//Tratamento especifico - SIGAAGR(UBS)               	
					//
					If AliasInDic("NPN")        
						NPN->(dbSetOrder(3))
						lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
					EndIf

					If lContinua 
						RecLock("ADB")
						If Empty(ADB->ADB_PEDCOB) .And. SC6->C6_TES==ADB->ADB_TESCOB
							ADB->ADB_PEDCOB := SC6->C6_NUM
						Else
							ADB->ADB_QTDEMP += SC6->C6_QTDVEN
							If ADB->ADB_QTDEMP > ADB->ADB_QUANT
								ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
								(cAliasSC6)->C6_CONTRAT := ""
								(cAliasSC6)->C6_ITEMCON := ""
							EndIf
						EndIf
						MsUnLock()
						dbSelectArea("ADA")
						dbSetOrder(1)
						If MsSeek(xFilial("ADA")+SC6->C6_CONTRAT)
							Ft400StatCt()
						EndIf
					Else 
						lContinua := .T.
					EndIf	
				EndIf
			EndIf
		EndIf
		//Ŀ
		// Atualiza os Saldos Fisicos e Financeiros - SB2                         
		//
		If !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ) //Se nao Bloqueado
			If SF4->F4_ESTOQUE == "S"
				//Ŀ
				//Verificar se o material com lote deve ser reservado mesmo que nao haja  
				//liberacao de pedido, a fim de garantir o lote na data do faturamento    
				//
				If !lAcumulado

					If !Empty((cAliasSC6)->C6_RESERVA)
						//Ŀ
						//Se a reserva estiver preenchida, verificar se e valida                  
						//
						SC0->( dbSetOrder( 1 ) )
						If !SC0->( MsSeek( xFilial( "SC0" ) + (cAliasSC6)->C6_RESERVA + (cAliasSC6)->C6_PRODUTO) )
							(cAliasSC6)->C6_RESERVA := ""
							(cAliasSC6)->C6_QTDRESE := 0
						EndIf
					EndIf

					If lResAut .And. Empty((cAliasSC6)->C6_RESERVA) .And. Rastro((cAliasSC6)->C6_PRODUTO) .And. ;
						( (cAliasSC6)->C6_QTDVEN - (cAliasSC6)->C6_QTDEMP - (cAliasSC6)->C6_QTDENT > 0 )

						If !Empty((cAliasSC6)->C6_NUMLOTE) .Or. !Empty((cAliasSC6)->C6_LOTECTL)
							cReserva := CriaVar("C0_NUM")

							//Ŀ
							//Verifica se a reserva sera feita pelo total da quantidade vendida
							//ou pelo saldo do lote.                                           
							//
							If lTipRes
								nSaldo := (cAliasSC6)->C6_QTDVEN
							Else
								nSaldo   := SldAtuEst((cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									(cAliasSC6)->C6_QTDVEN,;
									(cAliasSC6)->C6_LOTECTL,;
									(cAliasSC6)->C6_NUMLOTE,;
									(cAliasSC6)->C6_LOCALIZ,;
									(cAliasSC6)->C6_NUMSERI,;
									(cAliasSC6)->C6_RESERVA,;
									SF4->F4_PODER3<>"N" .Or. (SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3)),;
									,;
									(cAliasSC6)->C6_PROJPMS,;
									(cAliasSC6)->C6_TASKPMS,;
									(cAliasSC6)->C6_SERVIC)
							Endif

							If Empty(cReserva)
								cReserva := NextNumero("SC0",1,"C0_NUM",.T.)
							Else
								While ( GetSX8Len() > nSaveSX8 )
									ConfirmSx8()
								EndDo
							EndIf
							If a430Reserva({1,"VD",(cAliasSC6)->C6_NUM,"",cFilAnt},cReserva,;
									(cAliasSC6)->C6_PRODUTO,;
									(cAliasSC6)->C6_LOCAL,;
									nSaldo,;
									{(cAliasSC6)->C6_NUMLOTE,(cAliasSC6)->C6_LOTECTL,(cAliasSC6)->C6_LOCALIZ,(cAliasSC6)->C6_NUMSERI})

								(cAliasSC6)->C6_RESERVA := cReserva

							EndIf
						EndIf
					EndIf
				EndIf
				//Ŀ
				//Atualiza previsoes de saida de material                                 
				//
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				FatAtuEmpN("+")
				RecLock("SB2")
				SB2->B2_QPEDVEN += nSldPed
				SB2->B2_QPEDVE2 += nSldPed2
				//Ŀ
				// Tratamento para Reserva de material                  
				//
				If !lAcumulado
					If !Empty((cAliasSC6)->C6_RESERVA)
						If !cTipoPV$"CIP"
							dbSelectArea("SC0")
							dbSetOrder(1)
							If MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL)
								If !((cAliasSC6)->C6_NUMLOTE<>SC0->C0_NUMLOTE   .Or.;
									(cAliasSC6)->C6_LOTECTL<>SC0->C0_LOTECTL  .Or.;
									(cAliasSC6)->C6_LOCALIZ<>SC0->C0_LOCALIZ  .Or.;
									(cAliasSC6)->C6_NUMSERI<>SC0->C0_NUMSERI )
									RecLock("SC0")
									nQtdRese := Min(SC0->C0_QUANT,(cAliasSC6)->C6_QTDVEN)
									SC0->C0_QUANT  -= nQtdRese
									SC0->C0_TIPO   := "PD"
									SC0->C0_QTDPED += nQtdRese
								EndIf
							Endif
							//Ŀ
							// Atualiza o campo de qtd.reservada do Pedido de Venda 
							//
							(cAliasSC6)->C6_QTDRESE += nQtdRese
							//Ŀ
							//Nao deve atualizar a Quantidade em Pedido de Venda quando houver Reserva
							//pois neste caso o estoque ja esta liberado.                             
							//
							SB2->B2_QPEDVEN -= nQtdRese
							SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,nQtdRese,0,2)
						Else
							(cAliasSC6)->C6_RESERVA := ""
						EndIf
					Else
						(cAliasSC6)->C6_RESERVA := ""
					EndIf
				Else	
					SB2->B2_QPEDVEN -= (cAliasSC6)->C6_QTDRESE
					SB2->B2_QPEDVE2 -= ConvUM(SB2->B2_COD,(cAliasSC6)->C6_QTDRESE,0,2)
				EndIf
			EndIf
		EndIf
		//Ŀ
		//Atualiza o Saldo de Pedidos - SA1                                       
		//
		If SF4->F4_DUPLIC == "S" .And. !cTipoPV$"DB"
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
			If nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"
				nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
			EndIf
		EndIf
		If !lAcumulado .And. !("S" $ (cAliasSC6)->C6_BLQ .Or. "R" $ (cAliasSC6)->C6_BLQ)
			//Ŀ
			//Verifica a necessidade de Liberacao do Item                             
			//
			SC5->(FkCommit())
			SC6->(FkCommit())
			MaAvalSC6(cAliasSC6,3,cAliasSC5,lLiber,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
		EndIf
	EndIf
	//Ŀ
	//Verificacao dos acumulados do SC5                                       
	//
	If ( SC6->C6_QTDVEN > (SC6->C6_QTDEMP+SC6->C6_QTDENT) .And. AllTrim(SC6->C6_BLQ)<>"R")
		lLiberOk := .F.
	EndIf
	If (! "R" $ SC6->C6_BLQ )
		lResidOk := .F.
	EndIf
	If ( SC6->C6_QTDVEN > SC6->C6_QTDENT .And. AllTrim(SC6->C6_BLQ)<>"R" ) .Or. ( SF4->F4_QTDZERO=="1" .And. !lAcumulado )
		lFaturOk := .T.
	EndIf
	If !lAcumulado
		//Ŀ
		// Grava os lancamentos nas contas orcamentarias SIGAPCO    
		//
		PcoDetLan("000100","01","MATA410")
	EndIf	
	SC5->(FkCommit())
	SC6->(FkCommit())
	SC9->(FkCommit())
	//Ŀ
	//Estorno de um item do pedido de venda                                   
	//
Case nEvento == 2

	If !__lPyme

		If !Empty(ACM->(LastRec()))

			//Ŀ
			//Busca movimentacao das verbas                                           
			//

			#IFDEF TOP

				cQuery := "SELECT ACM_OPERA, ACM.R_E_C_N_O_ RECACM, ACL.R_E_C_N_O_ RECACL FROM "
				cQuery += RetSqlName("ACM")+ " ACM, "
				cQuery += RetSqlName("ACL")+ " ACL  "
				cQuery += " WHERE "
				cQuery += "ACM_FILIAL = '"+xFilial("ACM")+"' AND "
				cQuery += "ACM_NUMPED = '"+(cAliasSC6)->C6_NUM+"' AND "
				cQuery += "ACM_ITEPED = '"+(cAliasSC6)->C6_ITEM+"' AND "
				cQuery += "ACM.D_E_L_E_T_ = ' ' AND "
				cQuery += "ACL_FILIAL = '"+xFilial("ACL")+"' AND "
				cQuery += "((ACL_CODPRO = '"+cProduto+"' AND ACL_CODVER = ACM_CODVER ) OR "
				cQuery += "(ACL_CODPRO = '"+Space(Len(SB1->B1_COD))+"' AND ACL_CODVER = ACM_CODVER )) AND "
				cQuery += "ACL.D_E_L_E_T_ = ' ' "

				cQuery := ChangeQuery(cQuery)

				dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"QRYACL",.T.,.T.)

				While QRYACL->(!Eof())

					ACL->(MsGoto(QRYACL->RECACL))
					ACM->(MsGoto(QRYACL->RECACM))

					Do Case

						Case QRYACL->ACM_OPERA == "D"
							RecLock("ACL",.F.)
								ACL->ACL_SALDO += ACM->ACM_VALOR
							MsUnlock()
						Case QRYACL->ACM_OPERA == "C"
							RecLock("ACL",.F.)
								ACL->ACL_SALDO -= ACM->ACM_VALOR
							MsUnlock()
					EndCase

					RecLock("ACM",.F.)
						dbDelete()
					MsUnlock()

					QRYACL->(dbSkip())

				EndDo

				(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))

				DbSelectArea("QRYACL")
				DbCloseArea()
				DbSelectArea("SC6")

			#ELSE

				ACM->(dbSetOrder(2))
				If ACM->(MsSeek(xFilial("ACM")+(cAliasSC6)->C6_NUM+(cAliasSC6)->C6_ITEM))

					nRecACM := 0

					While ACM->(!Eof()) .And. ACM->ACM_FILIAL == xFilial("ACM") .And. ;
												ACM->ACM_NUMPED == (cAliasSC6)->C6_NUM .And. ;
												ACM->ACM_ITEPED == (cAliasSC6)->C6_ITEM

						ACM->(dbSkip())
						nRecACM := ACM->(Recno())
						ACM->(dbSkip(-1))

						ACL->(dbSetOrder(2))
						If !ACL->(MsSeek(xFilial("ACL")+cProduto+ACM->ACM_CODVER))
							ACL->(MsSeek(xFilial("ACL")+Space(Len(SB1->B1_COD))+ACM->ACM_CODVER))	
						EndIf

						If ACL->(Found())

							Do Case

								Case ACM->ACM_OPERA == "D"
									RecLock("ACL",.F.)
										ACL->ACL_SALDO += ACM->ACM_VALOR
									MsUnlock()
								Case ACM->ACM_OPERA == "C"
									RecLock("ACL",.F.)
										ACL->ACL_SALDO -= ACM->ACM_VALOR
									MsUnlock()
							EndCase

						EndIf

						RecLock("ACM",.F.)
							dbDelete()
						MsUnlock()

						ACM->(MsGoto(nRecACM))

					Enddo

					(cAliasSC6)->C6_BLOQUEI := Space(Len(SC6->C6_BLOQUEI))

				EndIf

			#ENDIF

		EndIf
	Endif


	If !cTipoPV$'DB'
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+(cAliasSC6)->C6_TES)
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL)
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	//Ŀ
	//Verifica a necessidade de estorno da liberacao                          
	//
	MaAvalSC6(cAliasSC6,4,cAliasSC5,lLiber,Nil,Nil,Nil,Nil,Nil,@nVlrCred)
	//Ŀ
	//Efetua travamento dos registros                                         
	//
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !cTipoPV$'DB'
		lContinua := RecLock("SA1")
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		lContinua := RecLock("SB2")
	EndIf
	//Ŀ
	// Estorna as Tabela Auxiliares                                           
	//
	If lContinua
		//Ŀ
		//Estorna o Saldo de Pedidos - SA1                                        
		//
		If ( SF4->F4_DUPLIC=="S" .And. !cTipoPV$"DB" )
			dbSelectArea("SA1")
			dbSetOrder(1)
			If ( MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA,.F.) )
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				If ( nSldPed > 0 .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" )
					nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
					SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,nMoeda,nMCusto,dEmissao)
				EndIf
			EndIf
		EndIf
		//Ŀ
		// Atualiza os Saldos Fisicos e Financeiros - SB2                         
		//
		If !("S"$(cAliasSC6)->C6_BLQ .Or. "R"$(cAliasSC6)->C6_BLQ)
			If SF4->F4_ESTOQUE == "S"
				//Ŀ
				// Tratamento para Reserva de material                  
				//
				If !Empty((cAliasSC6)->C6_RESERVA)
					dbSelectArea("SC0")
					dbSetOrder(1)
					If MsSeek(xFilial("SC0")+(cAliasSC6)->C6_RESERVA+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL)
						RecLock("SC0")
						SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"VD","PD")
						SC0->C0_QUANT  += SC6->C6_QTDRESE
						SC0->C0_QTDPED -= SC6->C6_QTDRESE
					EndIf

					SB2->B2_QPEDVEN += (cAliasSC6)->C6_QTDRESE

					(cAliasSC6)->C6_QTDRESE := 0
					If SuperGetMv("MV_DELRES")
						(cAliasSC6)->C6_RESERVA := ""
						a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
							SC0->C0_NUM,;
							SC0->C0_PRODUTO,;
							SC0->C0_LOCAL,;
							SC0->C0_QUANT,;
							{SC0->C0_NUMLOTE,;
							SC0->C0_LOTECTL,;
							SC0->C0_LOCALIZ,;
							SC0->C0_NUMSERI})
					EndIf
				EndIf

				//Ŀ
				//Atualiza previsoes de saida de material                                 
				//
				nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)
				nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				FatAtuEmpN("-")
				RecLock("SB2")
				SB2->B2_QPEDVEN -= nSldPed
				SB2->B2_QPEDVE2 -= nSldPed2

			EndIf
		EndIf
	EndIf
	//Ŀ
	// Atualiza Contratos de Parceria                                         
	//
	If !Empty(SC6->C6_CONTRAT) .And. !Empty(SC6->C6_ITEMCON)
		dbSelectArea("ADB")
		dbSetOrder(1)
		If MsSeek(xFilial("ADB")+SC6->C6_CONTRAT+SC6->C6_ITEMCON)
			//Ŀ
			//Tratamento especifico - SIGAAGR(UBS)               	
			//
			If AliasInDic("NPN")        
				NPN->(dbSetOrder(3))
				lContinua := !IsIncallStack("AGRA900") .And. !NPN->(dbSeek(xFilial("NPN")+SC6->(C6_NUM+C6_ITEM)))
			EndIf
            
			If lContinua
				RecLock("ADB")
				If !Empty(ADB->ADB_PEDCOB) .And. SC6->C6_NUM==ADB->ADB_PEDCOB
					ADB->ADB_PEDCOB := ""
				Else
					ADB->ADB_QTDEMP -= SC6->C6_QTDVEN
				EndIf
				MsUnLock()
				dbSelectArea("ADA")
				dbSetOrder(1)
				If MsSeek(xFilial("ADA")+SC6->C6_CONTRAT)
					Ft400StatCt()
				EndIf
			EndIf	
		EndIf
	EndIf	
	//Ŀ
	// Estorna amarracao com a Ordem de Servico - SIGATEC               
	//
	If ( !Empty((cAliasSC6)->C6_NUMOS) .Or. !Empty((cAliasSC6)->C6_NUMOSFA) )
		lTipoAb7 := .T.
		dbSelectArea("AB8")
		dbSetOrder(1)
		If ( MsSeek(xFilial("AB8")+SC6->C6_NUMOSFA) .And. !Empty(SC6->C6_NUMOSFA))
			RecLock("AB8")
			AB8->AB8_NUMPVF := ""
		EndIf
		If ( MsSeek(xFilial("AB8")+SC6->C6_NUMOS) .And. !Empty(SC6->C6_NUMOS))
			RecLock("AB8")
			AB8->AB8_NUMPV := ""
		EndIf
		If MsSeek(xFilial("AB8")+SubStr(SC6->C6_NUMOS,1,8))
			While ( !Eof() .And. xFilial("AB8") == AB8->AB8_FILIAL .And.;
					AB8->AB8_NUMOS+AB8->AB8_ITEM == SubStr(SC6->C6_NUMOS,1,8) )
				If ( !Empty(AB8->AB8_NUMPV) .Or. !Empty(AB8->AB8_NUMPVF) )
					lTipoAb7 := .F.
				EndIf
				dbSelectArea("AB8")
				dbSkip()
			EndDo
		EndIf
		If ( lTipoAb7 )
			dbSelectArea("AB7")
			dbSetOrder(1)

			If !Empty( SubStr(SC6->C6_NUMOS,1,8))
				If MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOS,1,8))
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf

			If !Empty( SubStr(SC6->C6_NUMOSFA,1,8))
				If MsSeek(xFilial("AB7")+SubStr(SC6->C6_NUMOSFA,1,8))
					RecLock("AB7")
					AB7->AB7_TIPO := AtTipoAB7()
				EndIf
			EndIf
			If !Empty((cAliasSC6)->C6_NUMOS) .OR. !Empty((cAliasSC6)->C6_NUMOSFA)
				//Ŀ
				// Atualiza o status da OS ( AB6 )                                  
				//
				dbSelectArea("AB6")
				dbSetOrder(1)
				If MsSeek(xFilial("AB6") + If( Empty( SubStr(SC6->C6_NUMOS,1,6) ),;
						SubStr(SC6->C6_NUMOSFA,1,6), SubStr(SC6->C6_NUMOS,1,6) ) )
					RecLock("AB6")
					AB6->AB6_STATUS := AtOsStatus( AB6->AB6_NUMOS )
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	// Estorna amarracao com o projeto - SIGATEC                        
	//
	ABI->( dbSetOrder( 3 ) )
	If ABI->( MsSeek( xFilial( "ABI" ) + (cAliasSC6)->C6_NUM + (cAliasSC6)->C6_ITEM ) )
		Reclock( "ABI", .F. )
		ABI->ABI_NUMPV  := Space( Len( ABI->ABI_NUMPV ) )
		ABI->ABI_ITEMPV := Space( Len( ABI->ABI_ITEMPV ) )
		ABI->( MsUnlock() )
	EndIf

	//Ŀ
	//Liberacao de um item do pedido de venda                                 
	//
Case nEvento == 3
	nQtdLib  := (cAliasSC6)->C6_QTDLIB
	nQtdLib2 := If( Empty( (cAliasSC6)->C6_QTDLIB2 ), Nil, (cAliasSC6)->C6_QTDLIB2 )
	If nQtdLib > 0 .Or. cTipoPV$"CIP" .Or. MaTesSel((cAliasSC6)->C6_TES)
		If cTipLib<>"2"
			MaLibDoFat(0,@nQtdLib,@lCredito,@lEstoque,.T.,.T.,lLiber,lTransf,Nil,Nil,Nil,Nil,Nil,@nVlrCred,@nQtdLib2)
		EndIf
	EndIf
	
	//Ŀ
	//Estorno de um item do pedido de venda                                   
	//
Case nEvento == 4
	//Ŀ
	//Estornar as liberacoes efetuadas desde que nao possuam NFS              
	//
	dbSelectArea("SC9")
	dbSetOrder(1)
	If ( MsSeek(xFilial("SC9")+cPedido+cItemPV) )
		While !Eof() .And. xFilial("SC9")==SC9->C9_FILIAL .And.;
				cPedido==SC9->C9_PEDIDO .And.;
				cItemPv==SC9->C9_ITEM
			If cProduto==SC9->C9_PRODUTO
				If SC9->C9_BLCRED <> "ZZ" .And. SC9->C9_BLEST <> "ZZ" .And. SC9->C9_BLCRED <> "10" .And. SC9->C9_BLEST <> "10" .And. Empty(SC9->C9_REMITO)
					//Ŀ
					//Efetua o estorno das movimentacoes internas                        
					//
					MaTrfLocal((cAliasSC6)->C6_PRODUTO, , , ,(cAliasSC6)->C6_NUM,.T.)
					//Ŀ
					//Efetua o estorno do itens de pedido de venda liberados             
					//
					SC9->(a460Estorna(.T.,,@nVlrCred))
				EndIf
			EndIf
			dbSelectArea("SC9")
			dbSkip()
		EndDo
		//Ŀ
		// PCO - Estorna os lancamentos de liberacao das contas orcamentarias 
		//
		PcoDetLan("000103","01","MATA440",.T.)
	EndIf	
	//Ŀ
	//Preparacao da Nota Fiscal de Saida                                      
	//
Case nEvento == 5
	If lAcumulado
		RecLock("SC6",.F.)
	EndIf
	If lRemito .Or. Empty( (cAliasSD2)->D2_REMITO )
		(cAliasSC6)->C6_QTDENT  += (cAliasSD2)->D2_QUANT
		(cAliasSC6)->C6_QTDENT2 += (cAliasSD2)->D2_QTSEGUM
		If !lAcumulado
			(cAliasSC6)->C6_QTDEMP  -= (cAliasSD2)->D2_QUANT
			(cAliasSC6)->C6_QTDEMP2 := Max( (cAliasSC6)->C6_QTDEMP2 - (cAliasSD2)->D2_QTSEGUM, 0 )
		EndIf
	Endif
	If !lRemito
		(cAliasSC6)->C6_NOTA   := (cAliasSD2)->D2_DOC
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
		(cAliasSC6)->C6_DATFAT := (cAliasSD2)->D2_EMISSAO
		If (cAliasSC6)->C6_QTDRESE == 0
			(cAliasSC6)->C6_RESERVA := ""
		EndIf
		
		//------------------------------------------------------------------------------
		// Se o Pedido de Venda foi gerado por uma Programao de Entrega (MATA412),
		// grava o nmero do Documento de Sada no item da Programao
		//------------------------------------------------------------------------------
		If ( AliasInDic("SD0") .And. AliasInDic("SDX") )
			
			DbSelectArea("SD0")
			SD0->(DbSetOrder(3))	//D0_FILIAL + D0_PEDIDO + D0_CLIENTE + D0_LOJA
			
			If ( SD0->( MsSeek( xFilial("SD0") + (cAliasSC6)->C6_NUM ) ) )
			
				lProgEnt := .T.
			
				DbSelectArea("SDX")
				SDX->(DbSetOrder(1))	//DX_FILIAL + DX_NUMENT + DX_ITEM + DX_PRODUTO							
				
				If ( SDX->( MsSeek( xFilial("SDX") + SD0->D0_NUMENT + AllTrim((cAliasSC6)->C6_ITEM) + (cAliasSC6)->C6_PRODUTO ) ) )
					RecLock( "SDX", .F. )
					SDX->DX_NOTA := (cAliasSD2)->D2_DOC
				EndIf	
							
			EndIf
									
		EndIf
		
	Else
		(cAliasSC6)->C6_NOTA   := "REMITO"
		(cAliasSC6)->C6_SERIE  := (cAliasSD2)->D2_SERIE
	Endif
	If lAcumulado
		MsUnLock()
	EndIf
	//Ŀ
	//Estorno da Nota fiscal de Saida                                         
	//
Case nEvento == 6
	//Ŀ
	//Posiciona registros                                                     
	//
	If !cTipoPV $ 'DB'
		If !xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+(cAliasSC6)->C6_CLI+(cAliasSC6)->C6_LOJA)
		EndIf
		lContinua := RecLock("SA1")
	EndIf
	If !(xFilial("SC5")==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC6)->C6_NUM)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC6)->C6_NUM)
	EndIf
	If !xFilial("SF4")+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+SC6->C6_TES)
	EndIf
	dbSelectArea("SB2")
	dbSetOrder(1)
	If !MsSeek(xFilial("SB2")+(cAliasSC6)->C6_PRODUTO+(cAliasSC6)->C6_LOCAL)
		//Ŀ
		//Sempre criar o SB2 para otimizacao da Query do MATA461                  
		//
		CriaSB2((cAliasSC6)->C6_PRODUTO,(cAliasSC6)->C6_LOCAL )
	EndIf
	If lContinua
		(cAliasSC6)->C6_NOTA  := ""
		(cAliasSC6)->C6_SERIE := ""	
		If "R" $ (cAliasSC6)->C6_BLQ
			MaAvalSC6(cAliasSC6,2,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
			(cAliasSC6)->C6_BLQ := ""
			MaAvalSC6(cAliasSC6,1,cAliasSC5,lLiber,lTransf,lLiberOk,lResidOk,lFaturOk,lAcumulado,@nVlrCred,cAliasSD2,lRemito,nMoeda)
		EndIf
		If lRemito .Or. Empty( SD2->D2_REMITO )
			(cAliasSC6)->C6_QTDENT  -= SD2->D2_QUANT
			(cAliasSC6)->C6_QTDENT2 := Max( (cAliasSC6)->C6_QTDENT2 - SD2->D2_QTSEGUM, 0 )
		Else
			If !Empty(SD2->D2_REMITO)
				(cAliasSC6)->C6_NOTA  := "REMITO"
				(cAliasSC6)->C6_SERIE := SD2->D2_SERIREM
			Endif
		EndIf
		If (cAliasSC6)->C6_QTDENT == 0 .Or. !lRemito
			(cAliasSC6)->C6_DATFAT := Ctod("")
		EndIf
		If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS" ) .And. (!lRemito .And. Empty(SD2->D2_REMITO))
			nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			nSldPed := SD2->D2_QUANT
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC6)->C6_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
		EndIf
		If ( SF4->F4_ESTOQUE == "S" ) .And. ( lRemito .Or. Empty( SD2->D2_REMITO ) ) .And. !AllTrim((cAliasSC6)->C6_BLQ)$"RS"

			//Ŀ
			//Atualiza previsoes de saida de material                                 
			//
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-((cAliasSC6)->C6_QTDENT+SD2->D2_QUANT)-(cAliasSC6)->C6_QTDEMP,0)
			nSldPed := Max((cAliasSC6)->C6_QTDVEN-(cAliasSC6)->C6_QTDENT-(cAliasSC6)->C6_QTDEMP,0)-nSldPed

			nSldPed2:= SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If SC6->C6_QTDVEN-SC6->C6_QTDEMP-SC6->C6_QTDENT > 0
				Do Case
					Case SC6->C6_OP == "02"
						SC6->C6_OP     := ""
					Case SC6->C6_OP == "08"
						SC6->C6_OP     := "01"
					Case SC6->C6_OP == "06"	
						SC6->C6_OP     := "05"
				EndCase
			EndIf

			RecLock("SB2")
			SB2->B2_QPEDVEN += nSldPed
			SB2->B2_QPEDVE2 += nSldPed2	
		EndIf
	EndIf

EndCase

//--------------------------------------------------------------------------
// Se for Programao de entrega
//--------------------------------------------------------------------------
If ( lProgEnt )
	//Atualiza Status da Programao de entrega
	If ( FindFunction("Ma412Stat") )
		Ma412Stat( SC6->C6_NUM )
	EndIf
EndIf
	
//Ŀ
//Restaura a entrada da rotina                                            
//
RestArea(aAreaSF4)
RestArea(aAreaSA1)
RestArea(aAreaSB2)
RestArea(aArea)
Return(.T.)
/*/


Ŀ
Funcao    MaAvalSC9  Autor Eduardo Riera           Data 20.02.2000
Ĵ
Descrio Rotina de avaliacao dos eventos dos itens liberados do pedi-
          do de Venda ( SC9 )                                         
Ĵ
ParametrosExpC1: Alias da tabela dos itens liberados do Pedido de Ven-
                 da                                                   
          ExpN2: Codigo do Evento                                     
                 [1] Implantacao do SC9                               
                 [2] Estorno do SC9                                   
                 [3] Liberacao de Credito do SC9                      
                 [4] Estorno da Liberacao de Credito do SC9           
                 [5] Liberacao de Estoque do SC9                      
                 [6] Estorno da Liberacao de Estoque do SC9           
                 [7] Montagem de Carga do SC9                         
                 [8] Estorno da Montagem de Carga do SC9              
                 [9] Liberacao WMS do SC9                             
                 [10]Estorno WMS do SC9                               
                 [11]Geracao do Documento de Saida                    
                 [12]Estorno do Documento de Saida                    
          ExpL3: Array da SldPorLote somente da Localizacao Fisica    
          ExpL4: Array da SldPorLote (Somente para WMS)               
          ExpL5: Atualiza somente os acumulados (OPC)                 
                 DEFAULT .F.                                          
          ExpL6: Indica se o estorno sera precedido de uma exclusao   
                 DEFAULT .T. (OPC)                                    
			 ExpL7: Indica se Atualizar Empenhos				          
			 ExpL8: Array com os dados da roteirizacao (OPC)             
			        [1] Codigo da Rota             			          
			        [2] Codigo da Zona             			          
			        [3] Codigo do Setor             			          
			        [4] Motorista                  			          
			        [5] Caminhao                    			          
			        [6] Ajudante 1                 			          
			        [7] Ajudante 2                  			          
			        [8] Ajudante 3                  			          
			        [9] Hora chegada                			          
			        [10] Time Service                			          
			        [11] Data chegada                			          
			        [12] Data saida                			          
			        [13] Hora de inicio de entrega    			          
          ExpN9: Valor a ser adicionado ao limite de credito          
          ExpLA: Indica se esta o SC9 esta sendo baixado por un REMITO
Ĵ
Retorno   Nenhum                                                      
                                                                      
Ĵ
Descrio Esta rotina tem como objetivo atualizar os eventos vinculado
          ao item do pedido de venda.                                 
          A) Atualizacao das tabelas complementares.                  
          B) Atualizacao das informacoes complementares do PV         
                                                                      
Ĵ
ObservacaoBloqueios do SC9                                            
                                                                      
          C9_BLCRED: 01 - Bloqueio de Credito por Valor               
                     04 - Vencto do Limite de Credito                 
                     05 - Bloqueio de Credito por Estorno             
                     06 - Bloqueio de Credito por Risco               
                     09 - Rejeicao de Credito                         
                                                                      
          C9_BLEST:  02 - Bloqueio de Estoque                         
                     03 - Bloqueio Manual de Estoque                  
                                                                      
          C9_BLWMS:  01 - Bloqueio de Enderecamento do WMS/Somente SB2
                     02 - Bloqueio de Enderecamento do WMS            
                     03 - Bloqueio de WMS - Externo                   
                     05 - Liberacao para Bloqueio 01                  
                     06 - Liberacao para Bloqueio 02                  
                     07 - Liberacao para Bloqueio 03                  
                                                                      
Ĵ
Uso        Materiais                                                  
ٱ


/*/
Function MaAvalSC9(cAliasSC9,nEvento,aLocaliz,aSaldos,lAcumulado,lDeleta,lAtuEmp,aRotas,nVlrCred,lRemito,lDeletaDCF,cIdDCF,lOkExpedicao,cFilCar,lWmsLibSC9)

Local aArea     := GetArea(cAliasSC9)
Local aAreaSF4  := SF4->(GetArea())
Local aAreaSC9  := {}
Local aCopySC9  := {}
Local aAuxiliar := {}
Local aAreaDAI  := {}
Local cSeqSC9   := ""
Local cQuery    := ""
Local cCarga    := ""
Local cSeqCar   := ""
Local nSldPed   := 0
Local nSldPed2  := 0
Local nRegEmp   := 0
Local nX        := 0
Local nY        := 0
Local nAuxiliar := 0
Local nPos      := 0
Local nVlEntcom := SB1->(OsVlEntCom())
Local lContinua := .T.
Local lBlqCred  := !Empty((cAliasSC9)->C9_BLCRED)
Local lBlqEst   := !(Empty((cAliasSC9)->C9_BLCRED) .And. Empty((cAliasSC9)->C9_BLEST))
Local lBlqWMS1  := (cAliasSC9)->C9_BLWMS=="01"
Local lBlqWMS2  := (cAliasSC9)->C9_BLWMS=="02"
Local lBlqWMS3  := (cAliasSC9)->C9_BLWMS=="03"
Local lBlqWMS	:= lBlqWMS1 .Or. lBlqWMS2 .Or. lBlqWMS3
Local lLibWMS1  := (cAliasSC9)->C9_BLWMS=="05"
Local lLibWMS2  := (cAliasSC9)->C9_BLWMS=="06"
Local lLibWMS3  := (cAliasSC9)->C9_BLWMS=="07"
Local lLibWMS	:= lLibWMS1 .Or. lLibWMS2 .Or. lLibWMS3
Local lFaturado := ((cAliasSC9)->C9_BLCRED=="10" .And. (cAliasSC9)->C9_BLEST=="10") .Or. ((cAliasSC9)->C9_BLCRED=="ZZ" .And. (cAliasSC9)->C9_BLEST=="ZZ")
Local lDelRes   := .F.
Local lGeraWMS  := .F.
Local lFreteEmb := .F.
Local nMCusto   := 0
Local lMTValAvC := ExistBlock("MTVALAVC")
Local	nValAv	 := 0
//-- Variaveis utilizadas pela funcao wmsexedcf
Local cServic	:= ''
Local nPosDCF	:= 0

lAtuEmp:=If(lAtuEmp==NIL,.T.,lAtuEmp)

DEFAULT lAcumulado  := .F.
DEFAULT lDeleta     := .T.
DEFAULT aRotas      := Array(15)
DEFAULT nVlrCred    := 0
DEFAULT lRemito     := .F.
DEFAULT lDeletaDCF  := .T.
DEFAULT cIdDCF      := ''
DEFAULT lOkExpedicao:= .F.
DEFAULT cFilCar     := xFilial("DAI")
DEFAULT lWmsLibSC9  := .T.
Do Case
	//Ŀ
	//Implantacao de um item liberado do pedido de venda                      
	//
Case nEvento == 1
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SC6->C6_TES)
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA)
		lContinua := RecLock("SA1")
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		dbSelectArea("SB2")
		dbSetOrder(1)
		If MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL)
	   		lContinua := RecLock("SB2")   
		Else
	   		HELP(" ",1,"NOFOUNDSB2") 
	   		lContinua := .F.
	 	EndIf
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. (SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.)
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//Ŀ
		//Atualiza os dados do item do pedido de venda                            
		//
		RecLock("SC6")
		SC6->C6_QTDEMP  += (cAliasSC9)->C9_QTDLIB
		SC6->C6_QTDEMP2 += (cAliasSC9)->C9_QTDLIB2		
		If !lAcumulado
			SC6->C6_QTDLIB  -= (cAliasSC9)->C9_QTDLIB
			SC6->C6_QTDLIB2 := Max( SC6->C6_QTDLIB2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			//Ŀ
			// Libera o arquivo Poder de Terceiros                     
			//
			If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
				SB6->B6_QULIB += (cAliasSC9)->C9_QTDLIB
			EndIf
		EndIf
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		MaAvalSC9(cAliasSC9,3,,,lAcumulado,Nil,Nil,Nil,@nVlrCred)
		//Ŀ
		//Atualiza a Liberacao de Estoque                                         
		//
		MaAvalSC9(cAliasSC9,5,aLocaliz,,lAcumulado,Nil,Nil,Nil,@nVlrCred)
	EndIf
	//Ŀ
	//Gera o registro do WMS no DCF com base no pedido de Vendas              
	//
	If	!lOkExpedicao .And. IntDl((cAliasSC9)->C9_PRODUTO) .And. !Empty((cAliasSC9)->C9_SERVIC) .And. Empty((cAliasSC9)->C9_BLCRED) .And. Empty((cAliasSC9)->C9_BLEST)
		If	SC5->(FieldPos("C5_GERAWMS")) > 0
			//-- 1=no Pedido;2=na Montagem da Carga;3=na Unitizacao da Carga
			lGeraWMS := SC5->C5_GERAWMS == '1'
		Else
			lGeraWMS := SC5->C5_TPCARGA == '2'
		EndIf
		If	lGeraWMS .And. !((cAliasSC9)->C9_BLWMS == '05')
			cServic := (cAliasSC9)->C9_SERVIC
			CriaDCF('SC9',,,,,@nPosDCF)
			//-- Verifica se a execucao do servico de wms sera automatica
			If	!lAcumulado .And. !Empty(nPosDCF) .And. WmsVldSrv('4',cServic)
				//-- Executa o servico de wms
				DCF->(MsGoTo(nPosDCF))
				WmsExeDCF('1',.F.)
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Estorno de um item liberado do pedido de venda                          
	//
Case nEvento == 2
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SC6->C6_TES)
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA)
		lContinua := RecLock("SA1")
	EndIf
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		dbSelectArea("SB2")
		dbSetOrder(1)
		MsSeek(xFilial("SB2")+SC6->C6_PRODUTO+(cAliasSC9)->C9_LOCAL)
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf	
	If lContinua .And. ( SF4->F4_PODER3=='D' .Or. !Empty((cAliasSC9)->C9_IDENTB6)) .And. !lAcumulado
		dbSelectArea("SB6")
		dbSetOrder(3)
		If MsSeek(xFilial("SB6")+(cAliasSC9)->C9_IDENTB6+SC6->C6_PRODUTO+"R",.F.)
			lContinua := RecLock("SB6")
		Else
			lContinua := .F.
		EndIf
	EndIf
	If lContinua
		//Ŀ
		//Verifica se eh um item de liberacao ou um item faturado      
		//
		If !lFaturado
			//Ŀ
			// Apaga marca de Pedido totalmente liberado (SC5->C5_LIBEROK) 
			//
			If lDeleta .And. !lAcumulado
				MaAvalSC5("SC5",4)
			EndIf
			//Ŀ
			// Efetua o Estorno de Estoque                             
			//
			MaAvalSC9(cAliasSC9,6,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred)
			//Ŀ
			//Efetua o estorno de credito                                  
			//
			MaAvalSC9(cAliasSC9,4,,,lAcumulado,,lAtuEmp,Nil,@nVlrCred)
			//Ŀ
			// Estorna valor no arquivo Poder de Terceiros             
			//
			If !lAcumulado
				If ( SF4->F4_PODER3=="D" .Or. !Empty((cAliasSC9)->C9_IDENTB6) )
					SB6->B6_QULIB -= (cAliasSC9)->C9_QTDLIB
				EndIf
			EndIf
			//Ŀ
			// Estorna qtde empenhada e nao faturada                   
			//
			SC6->C6_QTDEMP  -= (cAliasSC9)->C9_QTDLIB
			SC6->C6_QTDEMP2 := Max( SC6->C6_QTDEMP2 - (cAliasSC9)->C9_QTDLIB2, 0 )
			//Ŀ
			//Deleta Servico do WMS                                                   
			//
			If lDeletaDCF
				If	FindFunction("WmsDelDCF") .And. WmsDelDCF('1')
				Else
					MADeletDCF()
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Liberacao de Credito de um item liberado do pedido de venda             
	//
Case nEvento == 3
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SC6->C6_TES)
	If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB'
		dbSelectArea("SA1")
		dbSetOrder(1)
		MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA)
		lContinua := RecLock("SA1")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//Ŀ
		// Marca os pedidos liberados por credito para filtro na geracao da OP    
		//
		If !lBlqCred .And. !lAcumulado
			If ( Empty( SC6->C6_OP ) .Or. SC6->C6_OP == "02" .Or. SC6->C6_OP == "04") .And. SF4->F4_ESTOQUE=="S"
				SC6->C6_OP := "07"
			EndIf
			If SC6->C6_OP == "04"
				SC6->C6_OP := ""
			EndIf
		EndIf
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		dbSelectArea("SA1")		
		If SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lBlqCred
				SA1->A1_SALPEDL += nSldLib
				nVlrCred -= nValAV
			Else
				SA1->A1_SALPEDB += nSldLib
			EndIf
			nSldPed := (cAliasSC9)->C9_QTDLIB
			nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
			SA1->A1_SALPED -= xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
		EndIf
	EndIf
	//Ŀ
	//Estorno da Liberacao de Credito de um item liberado do pedido de venda  
	//
Case nEvento == 4
	If !lFaturado
		//Ŀ
		//Posiciona registros                                                     
		//
		If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
			dbSelectArea("SC5")
			dbSetOrder(1)
			MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
		EndIf
		If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
				SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
				SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
				SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
		EndIf
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+SC6->C6_TES)
		If lContinua .And. SF4->F4_DUPLIC=="S" .And. !SC5->C5_TIPO$'DB' .And. (lBlqEst.Or.SF4->F4_ESTOQUE=='N')		
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA)
			lContinua := RecLock("SA1")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC5")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC6")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock(cAliasSC9)
		EndIf
		If lContinua

			//Ŀ
			// Desmarca os pedidos liberados por credito para filtro na geracao da OP 
			//
			If !lAcumulado
				If SC6->C6_OP == "07"
					SC6->C6_OP := ""
				EndIf
			EndIf
			If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
				nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				Endif

				nSldLib  := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

				If !lBlqCred
					SA1->A1_SALPEDL -= nSldLib
					nVlrCred += nValAV
				Else
					SA1->A1_SALPEDB -= nSldLib
				EndIf
				nSldPed := (cAliasSC9)->C9_QTDLIB
				nSldPed := If(nSldPed>(SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT),SC6->C6_QTDVEN-SC6->C6_QTDEMP+nSldPed-SC6->C6_QTDENT,nSldPed)
				SA1->A1_SALPED += xMoeda(nSldPed*(cAliasSC9)->C9_PRCVEN,SC5->C5_MOEDA,nMCusto,SC5->C5_EMISSAO)
				(cAliasSC9)->C9_BLCRED := "05" //Bloqueado Manualmente de Credito"
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Liberacao de estoque de um item liberado do pedido de venda             
	//
Case nEvento == 5
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SC6->C6_TES)
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		dbSelectArea("SB2")
		dbSetOrder(1)
		MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL)
		lContinua := RecLock("SB2")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lAcumulado
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		//Ŀ
		//Atualiza a Liberacao de Estoque                                         
		//
		If ( SF4->F4_ESTOQUE == "S" )
			If ( !lBlqCred .And. !lBlqEst )
				//Ŀ
				//Atualiza as reservas para faturamento                                   
				//
				If !Empty((cAliasSC9)->C9_RESERVA)
					If !lAcumulado
						dbSelectArea("SC0")
						dbSetOrder(1)
						If MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL)
							//Ŀ
							//Tratamento dos Lotes da Reserva                                         
							//
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;      //2
								(cAliasSC9)->C9_QTDLIB,;   //3
								Nil,  ;        //4
								SC0->C0_LOTECTL,; //5
								SC0->C0_NUMLOTE,; //6
								SC0->C0_LOCALIZ,; //7
								SC0->C0_NUMSERI,; //8
								Nil,;          //9
								Nil,;          //10
								SC6->C6_RESERVA,; //11
								Nil,;          //12
								"SC0",;           //13
								Nil,;          //14
								Nil,;          //15
								Nil,;          //16
								.T.,;          //17
								.F.,;          //18
								.T.,;          //19
								.F.,;          //20
								Nil,;           //21
								IIf(!IntDL(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22
							RecLock("SB2")
						EndIf
					Else
						RecLock("SB2")
						SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
					EndIf
				EndIf
				//Ŀ
				//Reserva o saldo em Estoque                                              
				//
				For nX := 1 To Len(aLocaliz)
					GravaEmp((cAliasSC9)->C9_PRODUTO,;     //01
						(cAliasSC9)->C9_LOCAL,;       	//02
						aLocaliz[nX,5],;     			//03
						aLocaliz[nX,6],;     			//04
						(cAliasSC9)->C9_LOTECTL,;     	//05
						(cAliasSC9)->C9_NUMLOTE,;     	//06
						aLocaliz[nX,3],;     			//07
						aLocaliz[nX,4],;     			//08
						Nil,;             				//09
						(cAliasSC9)->C9_SEQUEN,;    	//10
						(cAliasSC9)->C9_PEDIDO,;       //11
						(cAliasSC9)->C9_ITEM,;         //12
						"SC6",;              			//13
						Nil,;             				//14
						Nil,;             				//15
						Nil,;             				//16
						.F.,;             				//17
						.F.,;             				//18
						.T.,;             				//19
						.F.,;             				//20
						!Empty((cAliasSC9)->C9_LOTECTL+(cAliasSC9)->C9_NUMLOTE),;//21
						lBlqWMS3 .Or. lBlqWMS2 .Or. !lBlqWMS,;						//22
						(lBlqWMS3 .Or. lBlqWMS2 .Or. !lBlqWMS) .And. !lAcumulado) //23
					RecLock("SB2")
				Next nX
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If (Empty((cAliasSC9)->C9_RESERVA)) .And. !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN -= nSldPed
						SB2->B2_QPEDVE2 -= nSldPed2
				Else
					//Ŀ
					// Atualiza o saldo da reserva                                  
					//
					If !lAcumulado
						dbSelectArea("SC0")
						dbSetOrder(1)
						If ( MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL) )
							RecLock("SC0")
							SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
							If ( SC6->C6_QTDRESE == 0 )
								// SC6->C6_RESERVA := ""
							EndIf
							SC0->C0_QTDPED -= (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO   := If(SC0->C0_QTDPED==0,"LB","PD")
						EndIf
					EndIf
				EndIf
			Else
				If !lAcumulado
					If (cAliasSC9)->C9_RESERVA==SC6->C6_RESERVA .And. !Empty((cAliasSC9)->C9_RESERVA)
						//Ŀ
						//Atualiza os dados do SC6                                                
						//
						SC6->C6_QTDRESE -= (cAliasSC9)->C9_QTDRESE
						If ( SC6->C6_QTDRESE == 0 )
							//SC6->C6_RESERVA := ""
						EndIf
					EndIf
				Else
					RecLock("SB2")
					SB2->B2_QPEDVEN -= (cAliasSC9)->C9_QTDRESE
					//Ŀ
					//Atualiza as reservas para faturamento                                   
					//
					If !Empty((cAliasSC9)->C9_RESERVA)
						dbSelectArea("SC0")
						dbSetOrder(1)
						If MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL)
							//Ŀ
							//Tratamento dos Lotes da Reserva                                         
							//
							GravaEmp(SC0->C0_PRODUTO,;    //1
								SC6->C6_LOCAL,;            //2
								(cAliasSC9)->C9_QTDRESE+SC6->C6_QTDRESE,;   //3
								NIL,;                //4
								SC0->C0_LOTECTL,;       //5
								SC0->C0_NUMLOTE,;       //6
								SC0->C0_LOCALIZ,;       //7
								SC0->C0_NUMSERI,;       //8
								Nil,;                //9
								Nil,;                //10
								(cAliasSC9)->C9_RESERVA,;        //11
								Nil,;                //12
								"SC0",;                 //13
								Nil,;                //14
								Nil,;                //15
								Nil,;                //16
								.F.,;                //17
								.F.,;                //18
								.T.,;                //19
								.F.,;                //20
								Nil,;                 //21
								IIf(!IntDL(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22
							RecLock("SB2")
						EndIf
					EndIf
				EndIf
			EndIf
			
			PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL, SC9->C9_QTDLIB, "-", SC9->C9_QTDLIB2,IIF(SC9->(FieldPos('C9_TRT'))<>0,SC9->C9_TRT,""))
			
			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If !lAcumulado
				Do Case
				Case Empty(SC6->C6_OP)
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					Else
						SC6->C6_OP     := "02"
					EndIf
				Case SC6->C6_OP == "07"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := ""
					EndIf
				Case SC6->C6_OP == "01"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "08"
					Else
						SC6->C6_OP     := "03"
					EndIf
				Case SC6->C6_OP == "05"
					If !lBlqEst .Or. SF4->F4_ESTOQUE=="N"
						SC6->C6_OP     := "06"
					EndIf
				EndCase
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Estorno da Liberacao de estoque de um item liberado do pedido de venda  
	//
Case nEvento == 6
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	dbSelectArea("SF4")
	dbSetOrder(1)
	MsSeek(xFilial("SF4")+SC6->C6_TES)
	If lContinua .And. SF4->F4_ESTOQUE=="S"
		dbSelectArea("SB2")
		dbSetOrder(1)
		MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+(cAliasSC9)->C9_LOCAL)
		lContinua := RecLock("SB2")
		nRecnoB2 := SB2->(Recno())
	EndIf

	If lContinua .And. !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf

	If lContinua .And. !lAcumulado
		lContinua := RecLock("SC5")
	EndIf
	If lContinua
		lContinua := RecLock("SC6")
	EndIf
	If lContinua .And. !lAcumulado
		lContinua := RecLock(cAliasSC9)
	EndIf
	If lContinua
		If SF4->F4_ESTOQUE == "S" .And. !lFaturado
			//Ŀ
			//                Notas sobre o campo C6_OP                               
			// 01 - OP Gerada pelo MATA650                                            
			// 02 - Liberacao de PV bloqueada ( Sem OP )                              
			// 03 - Liberacao de PV bloqueada ( Item 01 )                             
			// 04 - Bloqueio de credito pelo MATA650                                  
			// 05 - OP nao gerada pois ha qtde em Estoque                             
			// 06 - Liberacao de PV liberada  ( Item 05 )                             
			// 07 - Liberacao de credito efetuada / Estoque pendente/bloqueada        
			// 08 - Liberacao de estoque efetuada ( item 01 )                         
			//
			If !lAcumulado
				Do Case
				Case SC6->C6_OP == "02"
					SC6->C6_OP := "07"
				Case SC6->C6_OP=="08"
					SC6->C6_OP  := "03"
				Case SC6->C6_OP == "06"
					SC6->C6_OP  := "05"
				Case SC6->C6_OP == "03"
					SC6->C6_OP  := "01"					
				EndCase

			EndIf
			If !lBlqEst .And. !lBlqCred
				//Ŀ
				//Atualiza os dados da Reserva                                            
				//
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))

				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					dbSelectArea("SC0")
					dbSetOrder(1)
					If MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+SC6->C6_PRODUTO+SC6->C6_LOCAL)
						RecLock("SC0")
						If SC6->C6_QTDRESE==0
							SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
							SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
							SC0->C0_QTDPED  += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO    := "PD"
						Else
							lDelRes       := SuperGetMv("MV_DELRES")
							SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO  := If(SC0->C0_QTDPED==0.And.SC0->C0_TIPO=="PD","VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
						EndIf
					EndIf
				ElseIf !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
						RecLock("SB2",.F.)
						SB2->B2_QPEDVEN += nSldPed
						SB2->B2_QPEDVE2 += nSldPed2
					EndIf
				//Ŀ
				//Estorna o saldo Reservado                                               
				//
				GravaEmp((cAliasSC9)->C9_PRODUTO,;  //1
					(cAliasSC9)->C9_LOCAL,;       //2
					(cAliasSC9)->C9_QTDLIB,;      //3
					If( Empty( (cAliasSC9)->C9_QTDLIB2 ), NIL, (cAliasSC9)->C9_QTDLIB2 ),;  //4
					(cAliasSC9)->C9_LOTECTL,;     //5
					(cAliasSC9)->C9_NUMLOTE,;     //6
					Nil,;             //7
					Nil,;             //8
					Nil,;             //9
					(cAliasSC9)->C9_SEQUEN,;      //10
					(cAliasSC9)->C9_PEDIDO,;      //11
					(cAliasSC9)->C9_ITEM,;        //12
					"SC6",;              //13
					Nil,;             //14
					Nil,;             //15
					Nil,;             //16
					.T.,;             //17
					.F.,;             //18
					.T.,;             //19
					.F.,;             //20
					Nil,;             //21
					If(cPaisLoc=="BRA",lBlqWMS3 .Or. lBlqWMS2 .Or. !lBlqWMS,lAtuEmp),;        //22
					lBlqWMS3 .Or. lBlqWMS2 .Or. !lBlqWMS)         //23	
				RecLock("SB2")
				//Ŀ
				//Atualiza a Reserva de Material                                          
				//
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					dbSelectArea("SC0")
					dbSetOrder(1)
					If MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL)
						//Ŀ
						//Tratamento dos Lotes da Reserva                                         
						//
						GravaEmp(SC0->C0_PRODUTO,;    //1
							SC6->C6_LOCAL,;            //2
							(cAliasSC9)->C9_QTDLIB,;   //3
							NIL,;                //4
							SC0->C0_LOTECTL,;       //5
							SC0->C0_NUMLOTE,;       //6
							SC0->C0_LOCALIZ,;       //7
							SC0->C0_NUMSERI,;       //8
							Nil,;                //9
							Nil,;                //10
							(cAliasSC9)->C9_RESERVA,;        //11
							Nil,;                //12
							"SC0",;                 //13
							Nil,;                //14
							Nil,;                //15
							Nil,;                //16
							.F.,;                //17
							.F.,;                //18
							.T.,;                //19
							.F.,;                //20
							Nil,;                 //21
							IIf(!IntDL(SC0->C0_PRODUTO),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE).Or.Localiza( SC0->C0_PRODUTO ),!Empty(SC0->C0_LOTECTL+SC0->C0_NUMLOTE+SC0->C0_LOCALIZ+SC0->C0_NUMSERI))) //22

						If lDelRes
							a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
								SC0->C0_NUM,;
								SC0->C0_PRODUTO,;
								SC0->C0_LOCAL,;
								SC0->C0_QUANT,;
								{SC0->C0_NUMLOTE,;
								SC0->C0_LOTECTL,;
								SC0->C0_LOCALIZ,;
								SC0->C0_NUMSERI})
						EndIf

						RecLock("SB2")
					Else
						If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
							SB2->B2_QPEDVEN += nSldPed
							SB2->B2_QPEDVE2 += nSldPed2
						EndIf
					EndIf
				EndIf
				//Ŀ
				//Atualiza o Bloqueio de Estoque                                          
				//
				(cAliasSC9)->C9_BLEST := "03" //"Bloqueio Manual de Estoque"
				//Ŀ
				//Cria o Log de movimento do estoque                                      
				//
				
				PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,IIF(SC9->(FieldPos('C9_TRT'))<>0,SC9->C9_TRT,""))
				
			Else
				//Ŀ
				//Atualiza dados do SC6                                                   
				//
				nSldPed  := Max(Min(SC6->C6_QTDVEN-SC6->C6_QTDENT-SC6->C6_QTDEMP+(cAliasSC9)->C9_QTDLIB,(cAliasSC9)->C9_QTDLIB),0)
				nSldPed2 := SB1->(ConvUm(SB2->B2_COD,nSldPed,nSldPed2,2))
				If ( !Empty((cAliasSC9)->C9_RESERVA) )
					If ( SC6->C6_RESERVA==(cAliasSC9)->C9_RESERVA .Or. SC6->C6_QTDRESE==0 )
						SC6->C6_QTDRESE += (cAliasSC9)->C9_QTDRESE
						SC6->C6_RESERVA := (cAliasSC9)->C9_RESERVA
					Else
						dbSelectArea("SC0")
						dbSetOrder(1)
						If MsSeek(xFilial("SC0")+(cAliasSC9)->C9_RESERVA+(cAliasSC9)->C9_PRODUTO+SC6->C6_LOCAL)
							RecLock("SC0")
							SC0->C0_QUANT += (cAliasSC9)->C9_QTDRESE
							SC0->C0_TIPO  := If (SC0->C0_QTDPED==0,"VD",SC0->C0_TIPO)
							If !("S" $ SC6->C6_BLQ .Or. "R" $ SC6->C6_BLQ) //Se nao Bloqueado
								SB2->B2_QPEDVEN += (cAliasSC9)->C9_QTDRESE
							EndIf
							If SuperGetMv("MV_DELRES")
								a430Reserva({3,SC0->C0_TIPO,SC0->C0_DOCRES,SC0->C0_SOLICIT,SC0->C0_FILRES},;
									SC0->C0_NUM,;
									SC0->C0_PRODUTO,;
									SC0->C0_LOCAL,;
									SC0->C0_QUANT,;
									{SC0->C0_NUMLOTE,;
									SC0->C0_LOTECTL,;
									SC0->C0_LOCALIZ,;
									SC0->C0_NUMSERI})
							EndIf
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf	
	//Ŀ
	//Montagem de Carga                                                       
	//
Case nEvento == 7
	If lContinua
		//Ŀ
		//Verifica-se a existencia do item da carga                               
		//
		dbSelectArea("DAI")
		dbSetOrder(1) //DAI_FILIAL+DAI_COD+DAI_SEQCAR+DAI_SEQUEN+DAI_PEDIDO
		If !MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO)
			RecLock("DAI",.T.)
			DAI->DAI_FILIAL  := OsFilial("DAI",cFilCar)
			DAI->DAI_COD     := (cAliasSC9)->C9_CARGA
			DAI->DAI_SEQCAR  := (cAliasSC9)->C9_SEQCAR
			DAI->DAI_SEQUEN  := (cAliasSC9)->C9_SEQENT
			DAI->DAI_PEDIDO  := (cAliasSC9)->C9_PEDIDO
			If DAI->(FieldPos("DAI_FILPV")) > 0
				DAI->DAI_FILPV := (cAliasSC9)->C9_FILIAL
			EndIf
			DAI->DAI_CLIENT  := (cAliasSC9)->C9_CLIENTE
			DAI->DAI_LOJA    := (cAliasSC9)->C9_LOJA
			DAI->DAI_ROTEIR  := aRotas[1]
			DAI->DAI_PERCUR  := aRotas[2]
			DAI->DAI_ROTA    := aRotas[3]
			DAI->DAI_SEQROT  := Space(6)
			DAI->DAI_DATA    := dDataBase
			DAI->DAI_HORA    := Time()
			DAI->DAI_CARORI  := "CARGA"
			DAI->DAI_PESO   := 0
			DAI->DAI_CAPVOL := 0
			DAI->DAI_CHEGAD := aRotas[9]
			DAI->DAI_TMSERV := aRotas[10]
			DAI->DAI_DTCHEG := aRotas[11]
			DAI->DAI_DTSAID := aRotas[12]
			If lFreteEmb
				DAI->DAI_VALFRE := aRotas[14]
				DAI->DAI_FREAUT := aRotas[15]	
			EndIf
		Else
			RecLock("DAI",.F.)
		EndIf
		Msunlock()
		//Ŀ
		//Atualiza os acumulados do DAI                                       
		//
		OsAvalDAI("DAI",1,aRotas,,,cFilCar)
	EndIf
	//Ŀ
	//Estorno da Montagem de Carga                                            
	//
Case nEvento == 8
	aAreaDAI := DAI->(GetArea())
	//Ŀ
	//Verifica-se a filial da liberacao do pedido de venda                    
	//
	If FindFunction("OsFilOpe")
		cFilCar := (cAliasSC9)->(OsFilOpe(C9_CARGA,C9_SEQCAR,C9_SEQENT,C9_CLIENTE,C9_LOJA,C9_PEDIDO))
	EndIf
	//Ŀ
	//Deleta Servico do WMS                                                   
	//
	If !Empty((cAliasSC9)->C9_SERVIC) //.And. !((cAliasSC9)->C9_BLWMS == '05') //-- Soh quando o Item ainda tiver bloqueio de WMS (o Servico WNS ainda nao foi executado)
		//Ŀ
		//Retira as informacoes de Lote do SC9                                    
		//
		If lDeletaDCF
			If	FindFunction("WmsDelDCF") .And. WmsDelDCF('1')
				RecLock(cAliasSC9, .F.)
				(cAliasSC9)->C9_BLWMS := '01'
				If	(cAliasSC9)->(FieldPos('C9_IDDCF'))>0
					(cAliasSC9)->C9_IDDCF := ''
				EndIf	
				MsUnlock()
			ElseIf MADeletDCF()
				RecLock(cAliasSC9, .F.)
				(cAliasSC9)->C9_BLWMS := '01'
				MsUnlock()
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Atualiza os acumulados do DAI                                       
	//
	dbSelectArea("DAI")
	dbSetOrder(1)
	If	MsSeek(OsFilial("DAI",cFilCar)+(cAliasSC9)->C9_CARGA+(cAliasSC9)->C9_SEQCAR+(cAliasSC9)->C9_SEQENT+(cAliasSC9)->C9_PEDIDO)
		OsAvalDAI("DAI",2,aRotas,,,cFilCar)
	EndIf
	RestArea(aAreaDAI)
	//Ŀ
	//Liberacao do WMS                                                        
	//
Case nEvento == 9
	If !lBlqCred .And. !lBlqEst .And. !lFaturado
		//Ŀ
		//Posiciona registros                                                     
		//
		If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
			dbSelectArea("SC5")
			dbSetOrder(1)
			MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
		EndIf
		If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
				SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
				SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
				SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
		EndIf
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+SC6->C6_TES)
		If lContinua .And. SF4->F4_ESTOQUE=="S"
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+(cAliasSC9)->C9_LOCAL)
			lContinua := RecLock("SB2")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC5")
		EndIf
		If lContinua
			lContinua := RecLock("SC6")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock(cAliasSC9)
		EndIf
		If lContinua
			If SF4->F4_ESTOQUE == "S"
				Do Case
				Case lBlqWMS1 .Or. (!lBlqWMS2.And.!lBlqWMS3)
					//Ŀ
					//Aglutina os lotes/sub-lotes iguais                                      
					//Quando ha criacao de reservas na liberacao nao se deve aglutinar as     
					//localizacoes fisicas.                                                   
					//
					aAuxiliar := aClone(aSaldos)
					aSaldos   := {}
					aLocaliz  := {}
					For nX := 1 To Len(aAuxiliar)
						nAuxiliar := aScan(aSaldos,{|x|x[1]==aAuxiliar[nX,1] .And.;
							x[2]==aAuxiliar[nX,2] .And.;
							x[11]==aAuxiliar[nX,11] })
						If ( nAuxiliar == 0 )
							AAdd(aSaldos,Array(Len(aAuxiliar[nX])))
							For nY := 1 To Len(aAuxiliar[nX])
								aSaldos[Len(aSaldos)][nY] := aAuxiliar[nX,nY]
							Next nY
							AAdd(aLocaliz,{ aAuxiliar[nX] })
						Else
							aSaldos[nAuxiliar][5] += aAuxiliar[nX,5]
							aSaldos[nAuxiliar][6] += aAuxiliar[nX,6]
							AAdd(aLocaliz[nAuxiliar],aAuxiliar[nX])
						EndIf
					Next nX
					If Len(aSaldos) > 1
						//Ŀ
						//Guarda o conteudo dos campos do SC9 em uma variavel                     
						//
						For nX := 1 To (cAliasSC9)->(FCount())
							AAdd(aCopySC9,(cAliasSC9)->(FieldGet(nX)))
						Next nX
						//Ŀ
						//Verifica a Sequencia de Liberacao do SC9                                
						//
						#IFDEF TOP
							If ( TcSrvType()<>"AS/400" )
								SC9->(dbCommit())

								cQuery := "SELECT MAX(C9_SEQUEN) SEQUEN "
								cQuery +=   "FROM "+RetSqlName("SC9")+" SC9 "
								cQuery +=   "WHERE C9_FILIAL='"+xFilial("SC9")+"' AND "
								cQuery +=         "C9_PEDIDO='"+SC6->C6_NUM+"' AND "
								cQuery +=         "C9_ITEM='"+SC6->C6_ITEM+"' AND "
								cQuery +=         "SC9.D_E_L_E_T_<>'*'"

								cQuery := ChangeQuery(cQuery)
								dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MaAvalSC9",.T.,.T.)
								cSeqSC9 := SEQUEN
								dbCloseArea()
								dbSelectArea(cAliasSC9)
							Else
						#ENDIF
							aAreaSC9  := SC9->(GetArea(cAliasSC9))
							dbSelectArea(cAliasSC9)
							dbSetOrder(1)
							If ( MsSeek(xFilial("SC9")+SC6->C6_NUM+SC6->C6_ITEM,.F.) )
								While ( !Eof() .And. (cAliasSC9)->C9_FILIAL == xFilial("SC9") .And.;
										(cAliasSC9)->C9_PEDIDO == SC6->C6_NUM .And.;
										(cAliasSC9)->C9_ITEM   == SC6->C6_ITEM )
									If ( (cAliasSC9)->C9_PRODUTO == SC6->C6_PRODUTO )
										cSeqSC9  := (cAliasSC9)->C9_SEQUEN
									EndIf
									dbSelectArea(cAliasSC9)
									dbSkip()
								Enddo
							EndIf
							RestArea(aAreaSC9)
							#IFDEF TOP
							EndIf
							#ENDIF
						cSeqSC9 := Soma1(cSeqSC9,Len((cAliasSC9)->C9_SEQUEN))
					EndIf
					//Ŀ
					//Atualiza os dados do SC9 com Base no WMS                                
					//
					For nX := 1 To Len(aSaldos)
						If nX > 1
							RecLock(cAliasSC9,.T.)
							For nY := 1 To Len(aCopySC9)
								FieldPut(nY,aCopySC9[nY])
							Next nY
							(cAliasSC9)->C9_SEQUEN := cSeqSC9
							cSeqSC9 := Soma1(cSeqSC9,Len((cAliasSC9)->C9_SEQUEN))
						EndIf
						//Ŀ
						//Atualiza os campos de Lote/Localizacao/Almoxarifado                     
						//
						(cAliasSC9)->C9_LOTECTL := aSaldos[nX,01]
						(cAliasSC9)->C9_NUMLOTE := aSaldos[nX,02]
						(cAliasSC9)->C9_QTDLIB  := aSaldos[nX,05]
						(cAliasSC9)->C9_DTVALID := aSaldos[nX,07]
						(cAliasSC9)->C9_LOCAL   := aSaldos[nX,11]
						(cAliasSC9)->C9_POTENCI := aSaldos[nX,12]
						(cAliasSC9)->C9_QTDRESE := Min(aSaldos[nX,05],(cAliasSC9)->C9_QTDRESE)
						If lWmsLibSC9
							(cAliasSC9)->C9_BLWMS   := "05"
						EndIf	
						(cAliasSC9)->C9_DATALIB := dDataBase
						If	(cAliasSC9)->(FieldPos('C9_IDDCF'))>0
							(cAliasSC9)->C9_IDDCF := cIdDCF
						EndIf
						//Ŀ
						//Reserva o saldo em Estoque                                              
						//
						For nY := 1 To Len(aLocaliz[nX])
							GravaEmp((cAliasSC9)->C9_PRODUTO, ;		//-- 01.Codigo do Produto (Obrigatorio)
								(cAliasSC9)->C9_LOCAL, ;         	//-- 02.Local             (Obrigatorio)
								aLocaliz[nX,nY,5], ;             	//-- 03.Quantidade        (Obrigatorio)
								aLocaliz[nX,nY,6], ;             	//-- 04.Quantidade 2a UM  (Obrigatorio)
								(cAliasSC9)->C9_LOTECTL, ;       	//-- 05.Lote de Controle  (Obrig. se Inf. Sub-Lote)
								(cAliasSC9)->C9_NUMLOTE, ;       	//-- 06.Sub-Lote
								aLocaliz[nX,nY,3], ;             	//-- 07.Localizacao
								aLocaliz[nX,nY,4], ;             	//-- 08.Numero de Serie
								Nil, ;                           	//-- 09.Ordem de Producao
								(cAliasSC9)->C9_SEQUEN, ;        	//-- 10.Sequencia do Empenho / Liberacao do Pedido de Venda
								(cAliasSC9)->C9_PEDIDO, ;        	//-- 11.Pedido de Venda
								(cAliasSC9)->C9_ITEM, ;          	//-- 12.Item do Pedido de Venda
								'SC6',;                          	//-- 13.Origem do Empenho
								Nil, ;                           	//-- 14.Op original
								Nil, ;                           	//-- 15.Data de Entrega do Empenho
								Nil, ;                           	//-- 16.Array para o travamento dos saldos, caso nao seja informado nao havera travamento.
								.F., ;                           	//-- 17.Flag que indica se estorna empenho
								.F., ;                           	//-- 18.Flag que indica se e chamada da Projecao de Estoques
								.F., ;                           	//-- 19.Flag que indica se empenha material do SB2
								.F., ;                           	//-- 20.Flag que indica se grava registro no SD4
								!Empty((cAliasSC9)->C9_LOTECTL+(cAliasSC9)->C9_NUMLOTE), ;	//-- 21.Flag que indica se considera Lotes Vencidos
								.T., ;                           	//-- 22.Flag que indica se empenha material no SB8/SBF
								.T.,;                            	//-- 23.Flag que indica se CRIA registros no SDC
								,;									//-- 24.Flag que indica se encerra empenho de OP
								cIdDCF)								//-- 25.Identificador do DCF
							RecLock('SB2', .F.)
						Next nY
					Next nX
				Case lLibWMS2
					(cAliasSC9)->C9_BLWMS   := "06"
				OtherWise
					(cAliasSC9)->C9_BLWMS   := "07"
				EndCase
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Estorno do WMS de um item liberado do pedido de venda                   
	//
Case nEvento == 10
	If lLibWMS .And. !lBlqCred .And. !lBlqEst .And. !lFaturado
		//Ŀ
		//Posiciona registros                                                     
		//
		If !(xFilial("SC5")==SC5->C5_FILIAL .And. SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
			dbSelectArea("SC5")
			dbSetOrder(1)
			MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
		EndIf
		If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
				SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
				SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
				SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO )
			dbSelectArea("SC6")
			dbSetOrder(1)
			MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
		EndIf
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+SC6->C6_TES)
		If lContinua .And. SF4->F4_ESTOQUE=="S"
			dbSelectArea("SB2")
			dbSetOrder(1)
			MsSeek(xFilial("SB2")+(cAliasSC9)->C9_PRODUTO+(cAliasSC9)->C9_LOCAL)
			lContinua := RecLock("SB2")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock("SC5")
		EndIf
		If lContinua
			lContinua := RecLock("SC6")
		EndIf
		If lContinua .And. !lAcumulado
			lContinua := RecLock(cAliasSC9)
		EndIf
		If lContinua
			If SF4->F4_ESTOQUE == "S"
				If lLibWMS1
					//Ŀ
					//Atualiza os saldos em estoque                                           
					//
					GravaEmp((cAliasSC9)->C9_PRODUTO,; //01
						(cAliasSC9)->C9_LOCAL,;       	//02
						(cAliasSC9)->C9_QTDLIB,; 		//03
						Nil,;     						//04
						(cAliasSC9)->C9_LOTECTL,;     	//05
						(cAliasSC9)->C9_NUMLOTE,;     	//06
						Nil,;			     			//07
						Nil,;     						//08
						Nil,;             				//09
						(cAliasSC9)->C9_SEQUEN,;    	//10
						(cAliasSC9)->C9_PEDIDO,;       //11
						(cAliasSC9)->C9_ITEM,;         //12
						"SC6",;              			//13
						Nil,;             				//14
						Nil,;             				//15
						Nil,;             				//16
						.T.,;             				//17
						.F.,;             				//18
						.F.,;             				//19
						.F.,;             				//20
						!Empty((cAliasSC9)->C9_LOTECTL+(cAliasSC9)->C9_NUMLOTE),;//21
						lLibWMS2,;             			//22
						lLibWMS2)						//23
					RecLock("SB2")
					//Ŀ
					//Retira as informacoes de Lote do SC9                                    
					//
					(cAliasSC9)->C9_LOTECTL := ""
					(cAliasSC9)->C9_NUMLOTE := ""
					(cAliasSC9)->C9_DTVALID := Ctod("")
					(cAliasSC9)->C9_POTENCI := 0
					(cAliasSC9)->C9_BLWMS   := "01"	
				Else
					//Ŀ
					//Retorna o Bloqueio de WMS                                               
					//
					If lLibWMS2
						(cAliasSC9)->C9_BLWMS   := "02"	
					Else
						(cAliasSC9)->C9_BLWMS   := "03"	
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
	//Ŀ
	//Preparacao do Documento de Saida                                        
	//
Case nEvento == 11
	//Ŀ
	//Posiciona registros                                                     
	//
	If !(xFilial("SC5")==SC5->C5_FILIAL .And.;
			SC5->C5_NUM==(cAliasSC9)->C9_PEDIDO)
		dbSelectArea("SC5")
		dbSetOrder(1)
		MsSeek(xFilial("SC5")+(cAliasSC9)->C9_PEDIDO)
	EndIf
	If !SC5->C5_TIPO$'DB'
		If !xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA ==;
				SA1->A1_FILIAL+SA1->A1_COD+SA1->A1_LOJA
			dbSelectArea("SA1")
			dbSetOrder(1)
			MsSeek(xFilial("SA1")+(cAliasSC9)->C9_CLIENTE+(cAliasSC9)->C9_LOJA)
		EndIf
		lContinua := RecLock("SA1")
	EndIf	
	If !(xFilial("SC6")==SC6->C6_FILIAL .And.;
			SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
			SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
			SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
		dbSelectArea("SC6")
		dbSetOrder(1)
		MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
	EndIf
	If !xFilial("SF4")+SC6->C6_TES == SF4->F4_FILIAL+SF4->F4_CODIGO
		dbSelectArea("SF4")
		dbSetOrder(1)
		MsSeek(xFilial("SF4")+SC6->C6_TES)
	EndIf
	If lContinua
		If !lRemito
			(cAliasSC9)->C9_BLCRED  := "10"
			(cAliasSC9)->C9_BLEST   := "10"
			(cAliasSC9)->C9_NFISCAL := SD2->D2_DOC
			(cAliasSC9)->C9_SERIENF := SD2->D2_SERIE
			If SC9->(FieldPos("C9_NUMSEQ"))<>0
				(cAliasSC9)->C9_NUMSEQ := SD2->D2_NUMSEQ
				If GetNewPar("MV_NFS_JOB",.F.)
					(cAliasSC9)->C9_BLCRED  := "ZZ"
					(cAliasSC9)->C9_BLEST   := "ZZ"	
				EndIf
			EndIf
			If ( SF4->F4_DUPLIC == "S" .And. !SC5->C5_TIPO$"DB" .And. !AllTrim(SC6->C6_BLQ)$"RS" )
				nMCusto :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC,Val(SuperGetMv("MV_MCUSTO")))
				If lMTValAvC
					nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
				Else
					nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
				Endif
				nSldLib := xMoeda(nValAV,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)
				Reclock("SA1",.F.)
				SA1->A1_SALPEDL -= nSldLib
				MsUnLock()
			EndIf
		Else
			(cAliasSC9)->C9_REMITO  := SD2->D2_DOC
			(cAliasSC9)->C9_SERIREM := SD2->D2_SERIE
			(cAliasSC9)->C9_ITEMREM := SD2->D2_ITEM
			(cAliasSC9)->C9_DTREMIT := SD2->D2_EMISSAO
		Endif
	EndIf
	//Ŀ
	//Deleta Servico do WMS                                                   
	//
	If lDeletaDCF
		If	FindFunction("WmsDelDCF") .And. WmsDelDCF('1',,,,,,.T.)
		Else
			MADeletDCF()
		EndIf
	EndIf
	//Ŀ
	//Estorno do Documento de Saida                                           
	//
Case nEvento == 12
	If lRemito
		//Ŀ
		//Atualiza a Liberacao de Credito                                         
		//
		If !SC5->C5_TIPO$"DB" .And. SF4->F4_DUPLIC == "S"  .And. !AllTrim(SC6->C6_BLQ)$"RS"
			nMCusto  :=  If(SA1->A1_MOEDALC > 0,SA1->A1_MOEDALC, Val(SuperGetMv("MV_MCUSTO")))
			If lMTValAvC
				nValAv	:=	ExecBLock("MTValAvC",.F.,.F.,{'MAAVALSC9',(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN,nEvento})
			Else
				nValAv	:=	(cAliasSC9)->C9_QTDLIB*(cAliasSC9)->C9_PRCVEN
			Endif

			nSldLib  := xMoeda(nValAv,SC5->C5_MOEDA,nMCusto,(cAliasSC9)->C9_DATALIB)

			If !lBlqCred
				SA1->A1_SALPEDL -= nSldLib
				nVlrCred 		 += nValAV
			Else
				SA1->A1_SALPEDB -= nSldLib
			EndIf
		EndIf
	Endif

	If SF4->F4_MOVPRJ $ "25" .and. SF4->F4_ESTOQUE == "S"
		PmsBxEmp(SC9->C9_PROJPMS, SC9->C9_TASKPMS, SC9->C9_PRODUTO, SC9->C9_LOCAL,SC9->C9_QTDLIB, "+", SC9->C9_QTDLIB2,IIF(SC9->(FieldPos('C9_TRT'))<>0,SC9->C9_TRT,""))
	EndIf
EndCase
RestArea(aAreaSF4)
RestArea(aArea)
Return(.T.)

/*


Ŀ
Funcao    MatGrdSoma Autor Eduardo Riera           Data  26.02.99 
Ĵ
Descrio Atualizar a Quantidade Vendida com as Quantidades da Grade  
Ĵ
Retorno   ExpN1: Quantidade digitada na Grade                         
Ĵ
ParametrosExpN1: Linha do aCols Principal                             
          ExpN2: Quantidade digitada na Acols Principal               
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
          Erike Yuri      Esta funcao esta fora de uso.              
ٱ


*/
Function MatGrdSoma(nLinAcols,nQtdInf,nColQtd)

Local nColunas	:= 0
Local nLinhas	:= 0
Local nSoma		:= 0

//Ŀ
//Soma a Quantidade digitada na grade                                     
//
For nColunas:=2 to Len(aHeadGrade[nLinAcols])
	For nLinhas:=1 to Len(aColsGrade[nLinAcols])
		nSoma+=aColsGrade[nLinAcols][nLinhas][nColunas][nColQtd]
	Next nLinhas
Next nColunas
//Ŀ
//Verifica se ha divergencias                                             
//
If ( nSoma <> nQtdInf .And. nQtdInf <> 0 )
	Help(" ",1,"A410QTDDIF")
EndIf
Return(nSoma)


/*/


Ŀ
Funcao    MatGrdMont Autor Eduardo Riera           Data  23.02.99 
Ĵ
Descrio Montagem do aHeadGrade e do aColsGrade                      
Ĵ
Retorno   ExpL1: Logico                                               
Ĵ
ParametrosExpN1: Numero da Linha da GetDados Principal                
          ExpC2: Produto da Grade                                     
          ExpL3: Indica se deve ser reinicializada a Grade            
          ExpL4: Indica se os registros bloqueado devem ser considera-
                 dos.                                                 
Ĵ
ObservacaoEstrutura dos Array's de Grade                              
          - aHeadGrade                                                
            [xx]             Referencia a Linha do Acols Principal    
            [xx][01]         Indica se eh uma (R)Referencia ou (N)Nao 
            [xx][yy]         Colunas da Grade                         
          - aColsGrade                                                
            [xx]             Referencia a Linha do Acols Principal    
            [xx][yy]         Referencia a Linha da Grade              
            [xx][yy][01]     Codigo da Linha da Grade                 
            [xx][yy][zz]     Referencia a Coluna da Grade             
            [xx][yy][zz][01] Quantidade Vendida                       
            [xx][yy][zz][02] Quantidade Liberada                      
            [xx][yy][zz][03] Quantidade ja Liberada                   
            [xx][yy][zz][04] Item do SC6                              
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
          Erike Yuri      Esta funcao esta fora de uso               
ٱ


/*/
Function MatGrdMont(nCnt,cProdGrd,lAlterou,lBloqueados)

Local aArea       := GetArea()
Local aAreaSB1    := SB1->(GetArea())
Local aTam        := {}
Local aColuna     := {}
Local aLinha      := {}

Local lRefer      := .F.

Local cProdRef    := ""
Local cMascara    := SuperGetMv("MV_MASCGRD")

Local nCntFor     := 0
Local nCntFor2    := 0
Local nTamRef     := Val(Substr(cMascara,1,2))
Local nTamLin     := Val(Substr(cMascara,4,2))
Local nTamCol     := Val(Substr(cMascara,7,2))
Local nLinhas     := 0

cProdGrd    := If(cProdGrd==Nil,"",cProdGrd)
cProdRef    := cProdGrd
//Ŀ
//Verifica se o Produto e uma referencia                                  
//
lReFer := MatGrdPrrf(@cProdRef)
//Ŀ
//Inicializa os Parametros com seus valores default                       
//
lAlterou := If(lAlterou==Nil,.F.,lAlterou)
DEFAULT lBloqueados := .F.

//Ŀ
//Tratamento da Grade de Produtos                                         
//
If ( !lRefer )
	//Ŀ
	//Produto que nao possuem controle de grade.                              
	//
	If ( Len(aHeadGrade) >= nCnt )
		aHeadGrade[nCnt]  := {}
		AAdd(aHeadGrade[nCnt],"N")
		aColsGrade[nCnt] := {}
	Else
		While Len(aHeadGrade) < nCnt
			AAdd(aHeadGrade,{})
			AAdd(aHeadGrade[Len(aHeadGrade)],"N")
			AAdd(aColsGrade,{})
		EndDo
	EndIf
Else
	//Ŀ
	//Produto que possue controle por grade                                   
	//
	dbSelectArea("SB4")
	dbSetOrder(1)
	MsSeek(xFilial("SB4")+cProdRef)
	If ( Len(aHeadGrade) >= nCnt )
		//Ŀ
		// Quando existe, verifica se o array era de um produto     
		// referencia, se ja era ok, se nao deve criar o array de   
		// novo                                                     
		//
		If ( aHeadGrade[nCnt][1] == "N" .Or. lAlterou )
			aHeadGrade[nCnt]  := {}
			AAdd(aHeadGrade[nCnt],{})
			aHeadGrade[nCnt][1] := "R"
			aTam:=TamSX3("C6_QTDVEN")
			//Ŀ
			//Verifica as Linhas e Colunas da Grade pelo produto                      
			//
			If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
				aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
				aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
			Else
				dbSelectArea("SB1")
				dbSetOrder(1)
				MsSeek(xFilial("SB1")+cProdRef)
				While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
						SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
					If SB1->B1_GRADE # "S" .And. ( !RegistroOk("SB1",.F.) .Or. lbloqueados )
						dbSkip()
						Loop
					EndIf
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
					dbSelectArea("SB1")
					dbSkip()
				EndDo
			EndIf
			If GetNewPar("MV_ORDGRDP",.T.)
				aColuna  := aSort(aColuna)
				aLinha   := aSort(aLinha)
			EndIf
			//Ŀ
			//Verifica a Coluna da Grade                                              
			//
			For nCntFor := 1 To Len(aColuna)
				AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
					"_"+A550RemoveSinal(aColuna[nCntFor]),;
					PesqPictQt("C6_QTDVEN",14),;
					aTam[1],;
					aTam[2],;
					"A410GValid()",;
					"",;
					"C",;
					" ",;
					" " })
			Next nCntFor
			//Ŀ
			//Verifica a Linha da Grade                                               
			//
			aColsGrade[nCnt]  := {}
			For nCntFor := 1 To Len(aLinha)
				nLinhas++
				For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
					If ( nCntFor2 == 1 )
						AAdd(aColsGrade[nCnt],{})
						AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
					Else
						AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
					EndIf
				Next nCntFor2
				AAdd(aColsGrade[nCnt][nLinhas],.F.)
			Next nCntFor
		EndIf
	Else
		aTam:=TamSX3("C6_QTDVEN")
		AAdd(aHeadGrade,{})
		AAdd(aHeadGrade[nCnt],"R")
		//Ŀ
		//Verifica as Linhas e Colunas da Grade pelo produto                      
		//
		If ExistBlock("PVORDGRL") .And. ExistBlock("PVORDGRC")
			aLinha  := ExecBlock("PVORDGRL",.F.,.F.,{cProdRef})
			aColuna := ExecBlock("PVORDGRC",.F.,.F.,{cProdRef})
		Else	
			dbSelectArea("SB1")
			dbSetOrder(1)
			MsSeek(xFilial("SB1")+cProdRef)
			While ( !Eof() .And. SB1->B1_FILIAL == xFilial("SB1") .And.;
					SubStr(SB1->B1_COD,1,nTamRef) == cProdRef )
				If RegistroOk("SB1",.F.) .Or. lBloqueados
					If ( aScan(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))==0 )
						AAdd(aColuna,SubStr(SB1->B1_COD,nTamRef+nTamLin+1,nTamCol))
					EndIf
					If ( aScan(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))==0 )
						AAdd(aLinha,SubStr(SB1->B1_COD,nTamRef+1,nTamLin))
					EndIf
				EndIf
				dbSelectArea("SB1")
				dbSkip()
			EndDo
		EndIf
		If GetNewPar("MV_ORDGRDP",.T.)
			aColuna  := aSort(aColuna)
			aLinha   := aSort(aLinha)
		EndIf
		//Ŀ
		//Verifica a Colunas                                                      
		//
		For nCntFor := 1 To Len(aColuna)
			AAdd(aHeadGrade[nCnt],{  aColuna[nCntFor],;
				"_"+A550RemoveSinal(aColuna[nCntFor]),;
				PesqPictQt("C6_QTDVEN",14),;
				aTam[1],;
				aTam[2],;
				"A410GValid()",;
				"",;
				"C",;
				" ",;
				" " })
		Next nCntFor
		//Ŀ
		//Verifica as Linhas                                                      
		//
		AAdd(aColsGrade,{})
		For nCntFor := 1 To Len(aLinha)
			nLinhas++
			For nCntFor2 := 1 To Len(aHeadGrade[nCnt])
				If ( nCntFor2 == 1 )
					AAdd(aColsGrade[nCnt],{})
					AAdd(aColsGrade[nCnt][nLinhas],aLinha[nCntFor])
				Else
					AAdd(aColsGrade[nCnt][nLinhas],{0,0,0,"",0})
				EndIf
			Next nCntFor2
		Next nCntFor
	EndIf
EndIf
RestArea(aAreaSB1)
RestArea(aArea)
Return(lRefer)

/*/


Ŀ
Funcao    FTReprEst  Autor  Sergio Silveira        Data 20/02/2001
Ĵ
Descrio  Retorna os grupos abaixo de um representante ( vendedor )  
Ĵ
Sintaxe    ExpA1 := FTReprEst( ExpC1 )                                
Ĵ
Retorno    ExpA1 -> Array com os grupos do representante.             
               1 - Grupo / 2 - String com acessos da workare          
Ĵ
Parametros ExpC1 -> Representante.                                    
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function FTReprEst( cRepres )

Local aArea		 := GetArea()
Local aGruposEst := {}

SA3->( dbSetOrder( 1 ) )
If SA3->( DbSeek( xFilial( "SA3" ) + cRepres ) )
	FTGrupRepr( SA3->A3_GRPREP, @aGruposEst )
EndIf

RestArea(aArea)

Return( aGruposEst )

/*/


Ŀ
Funcao    FTGrupRepr Autor  Sergio Silveira        Data 20/02/2001
Ĵ
Descrio  Faz a inclusao dos grupos ( funcao recursiva )             
Ĵ
Sintaxe    FTGrpRepr( ExpC1, @ExpA1 )                                 
Ĵ
Retorno    .T.                                                        
Ĵ
Parametros ExpC1 -> Grupo incluido / ExpA1 -> Array de grupos.        
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/

Function FTGrupRepr( cGrupoInc, aGruposEst )

Local aRecnoACA  := {}
Local cSeekSup   := ""
Local nLoop      := 0

#IFDEF TOP
	Local lExistADK  := ChkFile("ADK")
	Local cQuery     := ""
	Local cAliasQry  := ""
#ENDIF 	

ACA->( dbSetOrder( 1 ) )
If ACA->( DbSeek( xFilial( "ACA" ) + cGrupoInc ) )

	//Ŀ
	// Inclui os grupos que tem este grupo como superior            
	//
	aRecnoACA := {}

	#IFDEF TOP

		If TcSrvType() # "AS/400"

			cAliasQry := GetNextAlias()
			cQuery    := ""

			cQuery += "SELECT R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ACA" ) + " "
			cQuery += "WHERE "
			cQuery += "ACA_FILIAL='" + xFilial( "ACA" ) + "' AND "
			cQuery += "ACA_GRPSUP='" + cGrupoInc        + "' AND "
			If FtIsP10R13()
				cQuery += "ACA_TIPSUP = '2GR' AND "
			EndIf
			cQuery += "D_E_L_E_T_<>'*'"
			
			cQuery := ChangeQuery(cQuery)
			
			dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )
			dbGoTop()
			While !Eof()
				AAdd( aRecnoACA, ACARECNO )
				dbSkip()
			EndDo
			(cAliasQry)->(dbCloseArea())
			
			If lExistADK		
				cAliasQry2 := GetNextAlias()
				cQuery    := ""
	
				cQuery += "SELECT ACA.R_E_C_N_O_ ACARECNO FROM " + RetSqlName( "ADK" ) + " ADK "
				cQuery += "INNER JOIN " + RetSqlName( "ACA" ) + " ACA ON ADK.ADK_COD = ACA.ACA_GRPSUP AND ACA.D_E_L_E_T_ <> '*' "
				cQuery += "WHERE "
				cQuery += "ADK_FILIAL='" + xFilial( "ADK" ) + "' AND "
				cQuery += "ADK_GRUNVE='" + cGrupoInc        + "' AND "
				cQuery += "ADK.D_E_L_E_T_ <> '*' "
				
				cQuery := ChangeQuery(cQuery)
	
				dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry2, .F., .T. )
				dbGoTop()
				While !Eof()
					AAdd( aRecnoACA, ACARECNO )
					dbSkip()
				EndDo
				(cAliasQry2)->(dbCloseArea())  
			EndIf
		Else
	#ENDIF
		ACA->( dbSetOrder( 2 ) )
		cSeekSup := xFilial( "ACA" ) + cGrupoInc
		If ACA->( MsSeek( cSeekSup ) )
			While !ACA->( Eof() ) .And. ACA->ACA_FILIAL + ACA->ACA_GRPSUP == cSeekSup
				AAdd( aRecnoACA, ACA->( RecNo() ) )
				ACA->( dbSkip() )
			EndDo
		EndIf
		#IFDEF TOP
		EndIf
		#ENDIF

	//Ŀ
	// Processa a lista de recnos                                   
	//
	For nLoop := 1 To Len( aRecnoACA ) 	
		ACA->( MsGoto( aRecnoACA[ nLoop ] ) )
		//Ŀ
		// Inclui este grupo                                            
		//
		AAdd( aGruposEst, { ACA->ACA_GRPREP, ACA->ACA_ACCLIE + ACA->ACA_ACPROS + ;
			ACA->ACA_ACPIPE + ACA->ACA_ACAPON + ACA->ACA_ACOPOR + ACA->ACA_ACESTR + ACA->ACA_MODCLI + ;
			ACA->ACA_MODPRO + "11" + ACA->ACA_MODOPO + ACA->ACA_MODEST } )
			
			FTGrupRepr( ACA->ACA_GRPREP, @aGruposEst )

	Next nLoop
EndIf
Return(.T.)
/*/


Ŀ
Funcao    MaNeedP3   Autor  Eduardo Riera          Data 02/04/2002
Ĵ
Descrio Funcao de analise da Necessidade do Saldo do Poder de 3     
Ĵ
Sintaxe   ExpN1 := MaNeedP3()                                         
Ĵ
Retorno   ExpA1: [1] Saldo proprio necessario                         
                 [2] Saldo do Poder de Terceiro Necessario            
Ĵ
ParametrosExpN1: Quantidade Necessaria                                
          ExpN2: Quantidade ja reservada                         (OPC)
                                                                      
Ĵ
ObservacaoA Tes e o item do pedido de venda devem estar posicionados  
                                                                      
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


/*/
Function MaNeedP3(nQtdLib,nQtdReserva)

Local aArea      := GetArea()
Local aAreaSC9   := SC9->(GetArea())
Local aSaldos    := {0,0,0}
Local nSldFisico := 0
Local nSldPoder3 := 0
Local nSldNosso  := 0
Local nSldNPT    := 0
Local nQtdJaReser:= 0
Local nQtdJaLib  := 0

#IFDEF TOP
	Local cQuery     := ""
#ENDIF

DEFAULT nQtdReserva := 0
//Ŀ
// Verifica se eh necessario o saldo de poder de terceiro                 
//
If SF4->(FieldPos("F4_TESP3"))<>0 .And. !Empty(SF4->F4_TESP3) .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA)
	//Ŀ
	// Calcula o disponivel considerando o poder de teceiro                   
	//
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,NIL,SC6->C6_SERVIC)
	//Ŀ
	// Calcula o disponivel nao considerando o poder de teceiro               
	//
	nSldNosso  := Max(SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,999999999999,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,NIL,SC6->C6_SERVIC),0)
	//Ŀ
	// Verifica o saldo em poder de terceiro ja liberado                      
	//
	#IFDEF TOP
		cQuery := "SELECT SUM(C9_QTDLIB) QTDLIB "
		cQuery += "FROM "+RetSqlName("SC9")+" SC9 "
		cQuery += "WHERE SC9.C9_FILIAL='"+xFilial("SC9")+"' AND "
		cQuery += "SC9.C9_PRODUTO='"+SC6->C6_PRODUTO+"' AND "
		cQuery += "SC9.C9_LOCAL='"+SC6->C6_LOCAL+"' AND "
		cQuery += "SC9.C9_BLEST='"+Space(Len(SC9->C9_BLEST))+"' AND "
		cQuery += "SC9.C9_BLCRED='"+Space(Len(SC9->C9_BLCRED))+"' AND "
		cQuery += "SC9.C9_IDENTB6<>'"+Space(Len(SC9->C9_IDENTB6))+"' AND "
		cQuery += "SC9.D_E_L_E_T_=' ' "

		cQuery := ChangeQuery(cQuery)

		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"MANEEDP3",.T.,.T.)
		nSldFisico += QTDLIB
		nQtdJaLib := QTDLIB
		dbCloseArea()
		dbSelectArea("SC9")
	#ELSE
		dbSelectArea("SC9")
		dbSetOrder(7)
		MsSeek(xFilial("SC9")+SC6->C6_PRODUTO+SC6->C6_LOCAL)
		While ( !Eof() .And. xFilial("SC9") == SC9->C9_FILIAL .And.;
				SC6->C6_PRODUTO == SC9->C9_PRODUTO .And.;
				SC6->C6_LOCAL == SC9->C9_LOCAL )
			If Empty(SC9->C9_BLCRED) .And. Empty(SC9->C9_BLEST) .And. !Empty(SC9->C9_IDENTB6)
				nSldFisico += SC9->C9_QTDLIB
				nQtdJaLib += SC9->C9_QTDLIB
			EndIf
			dbSkip()
		EndDo
	#ENDIF	
	nSldPoder3 := nSldFisico-nQtdJaLib
	If nQtdLib > nSldNosso
		aSaldos[1] := Min(nQtdLib,nSldNosso)
		aSaldos[2] := Min(nQtdLib-nSldNosso,nSldPoder3)
	Else
		aSaldos[1] := Min(nQtdLib,nSldNosso)
	EndIf
Else
	aSaldos[1] := nQtdLib
EndIf
//Ŀ
// Verifica se eh necessario o saldo de poder em terceiro                 
//
If aSaldos[2]==0 .And. nQtdLib > 0 .And. SF4->F4_ESTOQUE=="S" .And.;
		SF4->F4_PODER3=="N" .And. Empty(SC6->C6_RESERVA) .And.;
		(SF4->(FieldPos("F4_SLDNPT"))<>0 .And. SF4->F4_SLDNPT=="1")
	//Ŀ
	// Calcula o disponivel considerando o poder de teceiro                   
	//
	nSldFisico := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib,Nil,Nil,Nil,Nil,Nil,Nil,.F.,NIL,NIL,SC6->C6_SERVIC)
	nSldFisico += nQtdReserva
	If nSldFisico < 0
		nQtdJaReser := Abs(nSldFisico)
		nSldFisico  := 0
	EndIf
	If nSldFisico < nQtdLib	
		nSldNPT := SldAtuEst(SC6->C6_PRODUTO,SC6->C6_LOCAL,nQtdLib+nQtdJaReser,Nil,Nil,Nil,Nil,Nil,Nil,.T.,NIL,NIL,SC6->C6_SERVIC)-nSldFisico
		If nSldNPT > 0 .And. nSldNPT >= nQtdJaReser+nQtdLib
			aSaldos[1] := Min(nQtdLib,nSldFisico)
			aSaldos[3] := Min(nQtdLib-aSaldos[1],nSldNPT)
		EndIf
	EndIf
EndIf
RestArea(aAreaSC9)
RestArea(aArea)
Return(aSaldos)


/*


Ŀ
Funcao    FaAvRestri Autor  Sergio Silveira        Data 19/07/2002
Ĵ
Descrio Funcao de avaliacao das restricoes de visita                
Ĵ
Sintaxe   ExpA1 := FaAvRestri(ExpC1,ExpC2,ExpN1,[ExpC3],ExpD1,[ExpC4],
             [ExpC5],[ExpC6] )                                        
Ĵ
Retorno   ExpA1: Array contendo a seguintes elementos : { 1, 2, 3, 4 }
           1 - Tipo L - Indica se existe restricao                    
           2 - Tipo L - Indica se conseguiu sugerir um novo horario   
             apos a restricao ( apenas quando elem. 1 igual a .f. )   
           3 - Tipo C - Novo horario de inicio - Valido apenas quando 
                   elem. 2 = .T.                                      
           4 - Tipo C - Novo horario de fim    - Valido apenas quando 
                   elem. 2 = .T.                                      
Ĵ
ParametrosExpC1: Codigo do Cliente                                    
          ExpC2: Loja do cliente                                      
          ExpN1: Tipo de restricao: 1-Visita / 2-Entrega / 3-Ambos    
          ExpC3: Contato                                              
          ExpD1: Data de referencia                                   
          ExpC4: Hora inicial ou hora de referencia                   
          ExpC5: Hora final                                           
          ExpC6: Hora limite                                          
                                                                      
          O parametros de horario nao sao obrigatorios. E permitido   
          passar apenas o horario inicial e nesta situacao apenas     
          este sera verificado. O parametro hora limite e utilizado   
          para limitar o horario maximo permitido quando o sistema    
          sugerir um novo horario imediatamente apos uma restricao    
          existente.                                                  
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function FaAvRestri( cCodCli, cLoja, nAbrang, cContato, dDataAval, cHoraIni, cHoraFim, cHrLimite )

Local aGrupos   := {}
Local aArea     := GetArea()

Local bAbrang   := { || .T. }
Local bContato  := { || .T. }

Local cSeekACW  := ""
Local cQuery    := ""
Local cAliasQry := ""
Local cHrIniNew := ""
Local cHrFimNew := ""
Local cContNull := Space( Len( ACW->ACW_CODCON ) )

Local lRet      := .T.
Local lContinua := .T.
Local lHora     := ( ValType( cHoraIni ) == "C" )
Local lContato  := ( ValType( cContato ) == "C" )
Local lHoraNew  := .F.

Local nLoop     := 0
Local nRecnoACW := 0
Local nMinuto   := 1 / 60
Local nTemp     := 0

If lHora
	cHoraFim := If( ValType( cHoraFim ) == "C", cHoraFim, cHoraIni )
EndIf

bContato := If( lContato, { || ACW->ACW_CODCON == cContato .Or. ACW->ACW_CODCON == cContNull }, { || .T. } )

If nAbrang == 1
	bAbrang := { || ACW->ACW_ABRANG $ "13" }
ElseIf nAbrang == 2
	bAbrang := { || ACW->ACW_ABRANG $ "23" }
Else
	bAbrang := { || .T. }
EndIf

SA1->( dbSetOrder( 1 ) )
If SA1->( MsSeek( xFilial( "SA1" ) + cCodCli + cLoja ) )

	//Ŀ
	// Pesquisa uma restricao para o cliente                                   
	//
	cSeekACW := xFilial( "ACW" ) + SA1->A1_COD + SA1->A1_LOJA + DTOS( dDataAval )
	ACW->( dbSetOrder( 3 ) )
	If ACW->( MsSeek( cSeekACW ) )
		If lHora

			//Ŀ
			// Pesquisa o horario da restricao                                         
			//
			#IFDEF TOP

				cAliasQry := "FAAVRESTRI"

				cQuery := ""
				cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
				cQuery += "WHERE "
				cQuery += "ACW_FILIAL='"   + xFilial( "ACW" ) + "' AND "
				cQuery += "ACW_CODCLI='"   + SA1->A1_COD      + "' AND "
				cQuery += "ACW_LOJA='"     + SA1->A1_LOJA     + "' AND "
				cQuery += "ACW_DATA='"     + DTOS( dDataAval )+ "' AND "

				If nAbrang == 1
					cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
				ElseIf nAbrang == 2
					cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
				EndIf

				If lContato
					cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
				EndIf

				cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
				cQuery += "ACW_HORA1<='"     + cHoraFim         + "' ) OR "

				cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
				cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

				cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
				cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
				cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
				cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND "

				cQuery += "D_E_L_E_T_<>'*' "
				cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

				cQuery := ChangeQuery( cQuery )

				dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

				TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

				//Ŀ
				// Verifica o primeiro que atende a situacao                               
				//
				If !( cAliasQry )->( Eof() )
					lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
					lContinua := .F.
					nRecnoACW := ( cAliasQry )->ACWRECNO
				EndIf

				//Ŀ
				// Fecha a area de trabalho da query                                       
				//
				( cAliasQry )->( dbCloseArea() )

				dbSelectArea( "ACW" )

			#ELSE
				While !ACW->( Eof() ) .And. cSeekACW == ACW->ACW_FILIAL + ACW->ACW_CODCLI + ACW->ACW_LOJA + DTOS( ACW->ACW_DATA )

					If Eval( bContato ) .And. Eval( bAbrang ) .And. ( ( ACW->ACW_HORA1 >= cHoraIni .And. ACW->ACW_HORA1 <= cHoraFim  ) .Or. ;
							( ACW->ACW_HORA2 >= cHoraIni .And. ACW->ACW_HORA2 <= cHoraFim  ) .Or. ;
							( cHoraIni >= ACW->ACW_HORA1 .And. cHoraIni <= ACW->ACW_HORA2  ) .Or. ;
							( cHoraFim >= ACW->ACW_HORA1 .And. cHoraFim <= ACW->ACW_HORA2 ) )

						lRet      := ( ACW->ACW_TIPO == "2" )
						lContinua := .F.
						nRecnoACW := ACW->( Recno() )
						Exit
					EndIf

					ACW->( dbSkip() )
				EndDo
			#ENDIF

		Else
			lRet      := ( ACW->ACW_TIPO == "2" )
			lContinua := .F.
		EndIf
	EndIf

	//Ŀ
	// Se nao encontrou regra para o cliente, pesquisa uma regra para o grupo  
	//
	If lContinua

		If !Empty( SA1->A1_GRPVEN )

			//Ŀ
			// Obtem todos os grupos acima na estrutura                                
			//
			aGrupos := {}
			MaCliStrUp( SA1->A1_GRPVEN, @aGrupos )

			//Ŀ
			// ordena os grupos por nivel                                              
			//
			ASort( aGrupos, , , { |x,y| y[2] > x[2] } )

			//Ŀ
			// Percorre todos os grupos de baixo para cima                             
			//
			For nLoop := 1 To Len( aGrupos )

				//Ŀ
				// Persquisa uma restricao para o grupo atual                              
				//
				cSeekACW := xFilial( "ACY" ) + aGrupos[ nLoop, 1 ] + DTOS( dDataAval )

				ACW->( dbSetOrder( 2 ) )
				If ACW->( MsSeek( cSeekACW ) )
					If lHora

						#IFDEF TOP

							//Ŀ
							// Verifica se a restricao encontra-se no horario                          
							//
							cAliasQry := "FAAVRESTR2"

							cQuery := ""
							cQuery += "SELECT ACW.*, R_E_C_N_O_ ACWRECNO FROM " + RetSqlName( "ACW" ) + " ACW "
							cQuery += "WHERE "
							cQuery += "ACW_FILIAL='"   + xFilial( "ACW" )    + "' AND "
							cQuery += "ACW_GRPVEN='"   + aGrupos[ nLoop, 1 ] + "' AND "
							cQuery += "ACW_DATA='"     + DTOS( dDataAval )   + "' AND "

							If nAbrang == 1
								cQuery += "ACW_ABRANG IN ( '1', '3' ) AND "
							ElseIf nAbrang == 2
								cQuery += "ACW_ABRANG IN ( '2', '3' ) AND "
							EndIf

							If lContato
								cQuery += " ( ACW_CODCON='" + cContato + "' OR ACW_CODCON='" + cContNull + "' ) AND "
							EndIf

							cQuery += "( ( ACW_HORA1>='" + cHoraIni     + "' AND "
							cQuery += "ACW_HORA1<='"     + cHoraFim     + "' ) OR "

							cQuery += "( ACW_HORA2>='"   + cHoraIni     + "' AND "
							cQuery += "ACW_HORA2<='"     + cHoraFim     + "' ) OR "

							cQuery += "( '" + cHoraIni + "'>=ACW_HORA1 AND "
							cQuery += "'"   + cHoraIni + "'<=ACW_HORA2 ) OR "
							cQuery += "( '" + cHoraFim + "'>=ACW_HORA1 AND "
							cQuery += "'"   + cHoraFim + "'<=ACW_HORA2 ) ) AND  "

							cQuery += "D_E_L_E_T_<>'*' "
							cQuery += "ORDER BY " + SqlOrder( ACW->( IndexKey() ) )

							cQuery := ChangeQuery( cQuery )

							dbUseArea( .T., "TOPCONN", TcGenQry( ,, cQuery ), cAliasQry, .F., .T. )

							TcSetField( cAliasQry, "ACWRECNO", "N", 10, 0 )

							//Ŀ
							// Verifica o primeiro que atende a situacao                               
							//
							If !( cAliasQry )->( Eof() )
								lRet      := ( ( cAliasQry )->ACW_TIPO == "2" )
								lContinua := .F.
								nRecnoACW := ( cAliasQry )->ACWRECNO
							EndIf

							//Ŀ
							// Fecha a area de trabalho da query                                       
							//
							( cAliasQry )->( dbCloseArea() )

							dbSelectArea( "ACW" )

						#ELSE
							While !ACW->( Eof() ) .And. cSeekACW == ACW->ACW_FILIAL + ACW->ACW_GRPVEN + DTOS( ACW->ACW_DATA )

								//Ŀ
								// Verifica se a restricao encontra-se no horario                          
								//
								If Eval( bContato ) .And. Eval( bAbrang ) .And. ( ( ACW->ACW_HORA1 >= cHoraIni .And. ACW->ACW_HORA1 <= cHoraFim  ) .Or. ;
										( ACW->ACW_HORA2 >= cHoraIni .And. ACW->ACW_HORA2 <= cHoraFim  ) .Or. ;
										( cHoraIni >= ACW->ACW_HORA1 .And. cHoraIni <= ACW->ACW_HORA2  ) .Or. ;
										( cHoraFim >= ACW->ACW_HORA1 .And. cHoraFim <= ACW->ACW_HORA2 ) )

									lRet      := ( ACW->ACW_TIPO == "2" )
									lContinua := .F.
									nRecnoACW := ACW->( Recno() )
									Exit
								EndIf

								ACW->( dbSkip() )
							EndDo
						#ENDIF

					Else
						lRet      := ( ACW->ACW_TIPO == "2" )
						lContinua := .F.
					EndIf

				EndIf

				//Ŀ
				// Se ja encontrou uma restricao, abandona                                 
				//
				If !lContinua
					Exit
				EndIf

			Next nLoop

		EndIf

	EndIf

EndIf

//Ŀ
// Se possui restricao e considera hora, tenta obter um novo horario sem restricao 
//
If !lRet .And. lHora

	If !Empty( nRecnoACW )

		ACW->( MsGoto( nRecnoACW ) )

		//Ŀ
		// Caso nao seja passado horario limite, o limite e' 23:59                         
		//
		cHrLimite := If( ValType( cHrLimite ) == "C", cHrLimite, "23:59" )
		lHoraNew  := .T.

		//Ŀ
		// Calcula o tempo de alocacao                                                     
		//
		nTempo := SubtHoras( dDataAval, cHoraIni, dDataAval, cHoraFim )

		//Ŀ
		// Soma um minuto ao horario final da restricao para encontrar o novo horario ini  
		//
		cHrIniNew := AtSomaHora( ACW->ACW_HORA2, nMinuto )
		cHrFimNew := AtSomaHora( cHrIniNew, nTempo )

		//Ŀ
		// Verifica se e possivel alocar para o dia                                        
		//
		If cHrIniNew > cHrLimite .Or. cHrFimNew > cHrLimite
			lHoraNew := .F.
		EndIf

		If !lHoraNew
			cHrIniNew := cHoraIni
			cHrFimNew := cHoraFim
		EndIf

	EndIf

EndIf

RestArea( aArea )

Return( { lRet, lHoraNew, cHrIniNew, cHrFimNew } )

/*


Ŀ
Funo    MaCliStru  Autor Sergio Silveira         Data 16/05/2002
Ĵ
Descrio  Traz todos os grupos abaixo de um grupo de clientes        
           ( recursiva )                                              
Ĵ
Sintaxe    MaCliStru( ExpC1, @ExpA1, [ ExpN1 ] )                      
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaCliStru( cGrpSup, aGrupos, nLevel )

#IFDEF TOP
	Local cAliasQry := ""
	Local cQuery    := ""
#ELSE
	Local cSeekACY  := ""
	Local nRecAnt   := 0
#ENDIF

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

#IFDEF TOP

	cAliasQry := GetNextAlias()

	cQuery := ""
	cQuery += "SELECT ACY_GRPVEN, ACY_GRPSUP FROM " + RetSqlName( "ACY" ) + " "
	cQuery += "WHERE "
	cQuery += "ACY_FILIAL='" + xFilial( "ACY" ) + "' AND "
	cQuery += "ACY_GRPSUP='" + cGrpSup          + "' AND "
	cQuery += "D_E_L_E_T_<>'*'"

	cQuery := ChangeQuery( cQuery )

	dbUseArea( .T., "TOPCONN", TcGenQry( , , cQuery ), cAliasQry, .F., .T. )

	If Alias() == cAliasQry
		While !( cAliasQry )->( Eof() )
			AAdd( aGrupos, { ( cAliasQry )->ACY_GRPVEN, nLevel } )
			MaCliStru( ( cAliasQry )->ACY_GRPVEN, @aGrupos, @nLevel )
			( cAliasQry )->( dbSkip() )
		EndDo
		dbCloseArea()
		dbSelectArea( "ACY" )
	EndIf

#ELSE

	ACY->( dbSetOrder( 2 ) )
	cSeekACY := xFilial( "ACY" ) + cGrpSup
	If ACY->( MsSeek( cSeekACY ) )

		While !ACY->( Eof() ) .And. ACY->ACY_FILIAL + ACY->ACY_GRPSUP == cSeekACY

			nRecAnt := ACY->( Recno() )

			AAdd( aGrupos, { ACY->ACY_GRPVEN, nLevel } )
			MaCliStru( ACY->ACY_GRPVEN, @aGrupos, @nLevel )

			ACY->( dbSetOrder( 2 ) )
			ACY->( dbGoto( nRecAnt ) )

			ACY->( dbSkip() )

		EndDo

	EndIf

#ENDIF

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    MaCliStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de clientes         
           Funcao de chamada                                          
Ĵ
Sintaxe    MaCliStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpL1 -> Inverte a contagem de niveis no array. Quando     
           .T., a ordem passa a ser de cima para baixo                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaCliStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACY := ACY->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//Ŀ
// Chama a funcao de processamento                              
//
MaPrcStrUp( cGrpAtu, @aGrupos )

//Ŀ
// Inverte a ordem de niveis                                    
//
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACY )
RestArea( aArea )

Return( .T. )

/*


Ŀ
Funo    MaPrcStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de clientes         
           ( processamento )                                          
Ĵ
Sintaxe    MaPrcStrUp( ExpC1, @ExpA1, [ ExpN1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaPrcStrUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACY  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

ACY->( dbSetOrder( 1 ) )
cSeekACY := xFilial( "ACY" ) + cGrpAtu
If ACY->( MsSeek( cSeekACY ) )
	AAdd( aGrupos, { ACY->ACY_GRPVEN, nLevel } )
	MaPrcStrUp( ACY->ACY_GRPSUP, @aGrupos, @nLevel )
EndIf

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    FaIsOnStru Autor Sergio Silveira         Data 30/07/2002  
Ĵ
Descrio Verifica se um grupo de clientes esta contido na estrutura de 
          outro grupo de clientes                                       
Ĵ
Sintaxe   ExpL1 := FaIsOnStru( ExpC1, ExpC2 )                           
Ĵ
ParametrosExpC1: Grupo pai                                              
          ExpC2: Grupo filho                                            
Ĵ
Retorno   ExpL1: Validacao : .T. contido, .F. nao contido               
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/

Function FaIsOnStru( cGrpPai, cGrpFilho )

Local aStruUp  := {}
Local lRetorno := .F.

//Ŀ
// Carrega a estrutura que esta acima do filho                  
//
MaCliStrUp( cGrpFilho, @aStruUp )

//Ŀ
// Verifica se o pai esta acima ou e igual ao filho             
//
lRetorno := !Empty( AScan( aStruUp, { |x| x[1] == cGrpPai } ) )

Return( lRetorno )
/*

Ŀ
Funo    MADeletDCF Autor Fernando Joly/Alex EgydioData21.11.2002
Ĵ
Descrio  Estorno da Execucao de servicos do WMS                     
Ĵ
Parametros ExpC1 - 1 = Exclui os registros no DCF referentes aos itens
                       do pedido de venda. OBS: Deve estar posicionado
                       no registro do SC9 correspondente.             
                   2 = Exclusao da execucao de servicos atraves das   
                       rotinas de estorno do DLGA150 e WMSA330. OBS:  
                       Deve estar posicionado no registro do DCF.     
           ExpN1 - Status desejado p/estorno da execucao de servico.  
           ExpL1 - .T. = Ativa o processamento da funcao DlgA220Esto  
           ExpL2 - .T. = Estorna todos os documentos com referencia a 
                         carga ou documento original.                 
Ĵ
 Retorno                                                              
ٱ
*/
Function MADeletDCF(cAcao,nStatDCF,lProcessa,lEstSrvAut,aDocOri)
Local aAreaAnt		:= GetArea()
Local aRegSDB		:= {}
Local cAliasNew		:= ''
Local cIndSDB		:= ''
Local nIndex		:= 0
Local lQuery		:= .F.
Local cQuery		:= ''
Local cDocto		:= ''
Local cSerie		:= ''
Local cCarga		:= ''
Local cServic		:= ''
Local cProduto		:= ''
Local cCliFor		:= ''
Local cLoja			:= ''
Local cSeekDCF		:= ''
Local cSeekSDB		:= ''
Local cRetPE		:= ''
Local lRet			:= .F.
Local lRetPE		:= .F.
Local lDelDoc		:= .F.
Local lDLGA150D		:= .F.
Local lDocOri		:= .F.
Local lWmsQySDB		:= .F.
Local nPosDCF		:= 0
Local nQuant		:= 0
Local nCntFor		:= 0
Local cStatExec		:= SuperGetMV('MV_RFSTEXE', .F., '1') //-- DB_STATUS indincando Atividade Executada
Local cStatAuto		:= SuperGetMV('MV_RFSTAUT', .F., 'A') //-- DB_STATUS indincando Atividade Automatica
Local cStatManu		:= SuperGetMV('MV_RFSTMAN', .F., 'M') //-- DB_STATUS indincando Atividade Manual
Local dDataFec		:= CToD('')
DEFAULT cAcao		:= '1'
DEFAULT nStatDCF	:= 0
DEFAULT lProcessa	:= .F.
DEFAULT lEstSrvAut	:= .F.
DEFAULT aDocOri		:= {}

If	cAcao == '1'
	//-- So exclui se houver Servico de WMS preenchido e integracao com WMS
	If !Empty(SC9->C9_SERVIC) .And. IntDL(SC9->C9_PRODUTO)
		dDataFec	:= DToS(WmsData())
		cDocto		:= PadR(SC9->C9_PEDIDO,Len(DCF->DCF_DOCTO))
		cSerie		:= PadR(SC9->C9_ITEM  ,Len(DCF->DCF_SERIE))
		cCarga		:= PadR(SC9->C9_CARGA ,Len(DCF->DCF_CARGA))
		cServic		:= PadR(SC9->C9_SERVIC,Len(DCF->DCF_SERVIC))
		cProduto	:= PadR(SC9->C9_PRODUTO,Len(DCF->DCF_CODPRO))
		cCliFor		:= PadR(SC9->C9_CLIENTE,Len(DCF->DCF_CLIFOR))
		cLoja		:= PadR(SC9->C9_LOJA,Len(DCF->DCF_LOJA))
		nQuant		:= SC9->C9_QTDLIB
		//-- Ponto de entrada WMSQYSDB para complemento do filtro do arquivo SDB
		lWmsQySDB  := ExistBlock('WMSQYSDB')
		If	WmsCarga(cCarga)
			DbSelectArea('DCF')
			DbSetOrder(4) //-- DCF_FILIAL+DCF_SERVIC+DCF_CARGA+DCF_UNITIZ
			If (lRet:=MsSeek(cSeekDCF:=xFilial('DCF')+cServic+cCarga, .F.))
				While DCF->( !Eof() .And. DCF->DCF_FILIAL+DCF->DCF_SERVIC+DCF->DCF_CARGA == cSeekDCF )
					If	DCF->DCF_CODPRO == cProduto .And. ;
						If(Rastro(cProduto) .And. !Empty(DCF->DCF_LOTECT), DCF->DCF_LOTECT == SC9->C9_LOTECTL, .T.) .And. ;
						If(Rastro(cProduto,'S') .And. !Empty(DCF->DCF_NUMLOT), DCF->DCF_NUMLOT == SC9->C9_NUMLOTE, .T.) //-- Reforco da chave de Indice
						//-- Se faturou toda a carga, marcar todos os itens do SDB referente a esta carga como FATURADO
						//-- Obs: Se parte da carga foi faturada nao altero o status do SDB
						RecLock('DCF', .F., .T.)
						DCF->DCF_QUANT := (DCF->DCF_QUANT-nQuant)
						If	DCF->(FieldPos('DCF_QTSEUM'))>0
							DCF->DCF_QTSEUM := ConvUm(cProduto,DCF->DCF_QUANT,0,2)
						EndIf
						MsUnlock()
						If QtdComp(DCF->DCF_QUANT) <= QtdComp(0)
							If !(DCF->DCF_STSERV=='1')
								cAliasNew := 'SDB'
								cIndSDB   := ''
								cQuery    := ''
								nIndex    := 0
								lQuery    := .F.
								#IFDEF TOP
									lQuery := .T.
									cAliasNew := GetNextAlias()
									cQuery := " SELECT DB_FILIAL,DB_CARGA,DB_SERVIC,DB_PRODUTO,DB_ATUEST,DB_STATUS,SDB.R_E_C_N_O_ SDBRECNO"
									cQuery += " FROM " + RetSqlName('SDB')+" SDB"
									cQuery += " WHERE DB_FILIAL = '"+xFilial("SDB")+"'"
									cQuery += " AND DB_CARGA    = '"+cCarga+"'"
									cQuery += " AND DB_SERVIC   = '"+cServic+"'"
									cQuery += " AND DB_PRODUTO  = '"+cProduto+"'"
									cQuery += " AND DB_ATUEST   = 'N'"
									cQuery += " AND DB_DATA    > '"+dDataFec+"'"
									If	lWmsQySDB
										cRetPE := ExecBlock('WMSQYSDB',.F.,.F.,{cQuery})
										If ValType(cRetPE)=='C'
											cQuery := cRetPE
										EndIf
									EndIf
									cQuery += " AND SDB.D_E_L_E_T_ = ' '"
									cQuery += " ORDER BY DB_FILIAL, DB_CARGA"
									cQuery := ChangeQuery(cQuery)
									DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cQuery),cAliasNew,.F.,.T.)
								#ELSE
									cIndSDB := CriaTrab(NIL,.F.)
									cQuery := "DB_FILIAL  == '"+xFilial("SDB")+"' .And. "
									cQuery += "DB_CARGA   == '"+cCarga+"' .And. "
									cQuery += "DB_SERVIC  == '"+cServic+"' .And. "
									cQuery += "DTOS(DB_DATA) > '"+dDataFec+"' .And. "
									cQuery += "DB_PRODUTO == '"+cProduto+"' .And. "
									cQuery += "DB_ATUEST  == 'N'"
									If	lWmsQySDB
										cRetPE := ExecBlock('WMSQYSDB',.F.,.F.,{cQuery})
										If ValType(cRetPE)=='C'
											cQuery := cRetPE
										EndIf
									EndIf
									IndRegua(cAliasNew,cIndSDB,'DB_FILIAL+DB_CARGA',,cQuery,'Selecionando Registros...')
									nIndex := RetIndex()
									DbSetIndex(cIndSDB+OrdBagExt())
									DbSetOrder(nIndex+1)
									DbGotop()
								#ENDIF
								While (cAliasNew)->(!Eof())
									If	lQuery
										SDB->(DbGoto((cAliasNew)->SDBRECNO))
									EndIf
									RecLock('SDB',.F.)
									SDB->DB_ESTORNO := 'S'
									SDB->DB_STATUS  := 'F'
									MsUnLock()
									(cAliasNew)->(DbSkip())
								EndDo
								If	lQuery
									DbSelectarea(cAliasNew)
									DbCloseArea()
								Else
									If	File(cIndSDB+OrdBagExt())
										Ferase(cIndSDB+OrdBagExt())
									EndIf
								EndIf
							EndIf
							RecLock('DCF', .F., .T.)
							dbDelete()
							MsUnlock()
							//-- Retira referencia a carga original
							WmsDocOri('3',,,cCarga)
						EndIf
					EndIf
					DCF->(dbSkip())
				EndDo
			EndIf
		Else
			DbSelectArea('DCF')
			DbSetOrder(2) //-- FILIAL+SERVIC+DOCTO+SERIE+CLIFOR+LOJA+CODPRO
			If (lRet:=MsSeek(cSeekDCF:=xFilial('DCF')+cServic+cDocto+cSerie+cCliFor+cLoja+cProduto,.F.))
				While DCF->( !Eof() .And. DCF->DCF_FILIAL+DCF->DCF_SERVIC+DCF->DCF_DOCTO+DCF->DCF_SERIE+DCF->DCF_CLIFOR+DCF->DCF_LOJA+DCF->DCF_CODPRO == cSeekDCF )
					//-- Se faturou todo o documento, marcar todos os itens do SDB referente a este documento como FATURADO
					//-- Obs: Se parte do documento foi faturado nao altero o status do SDB
					RecLock('DCF', .F., .T.)
					DCF->DCF_QUANT := (DCF->DCF_QUANT-nQuant)
					If	DCF->(FieldPos('DCF_QTSEUM'))>0
						DCF->DCF_QTSEUM := ConvUm(cProduto,DCF->DCF_QUANT,0,2)
					EndIf
					MsUnlock()
						If	QtdComp(DCF->DCF_QUANT) <= QtdComp(0)
						If !(DCF->DCF_STSERV=='1')
							cAliasNew := 'SDB'
							cIndSDB   := ''
							cQuery    := ''
							nIndex    := 0
							lQuery    := .F.
							#IFDEF TOP
								lQuery := .T.
								cAliasNew := GetNextAlias()
								cQuery := " SELECT DB_FILIAL,DB_PRODUTO,DB_DOC,DB_SERIE,DB_CLIFOR,DB_LOJA,DB_SERVIC,DB_ATUEST,DB_STATUS,SDB.R_E_C_N_O_ SDBRECNO"
								cQuery += " FROM " + RetSqlName('SDB')+" SDB"
								cQuery += " WHERE DB_FILIAL    = '"+xFilial("SDB")+"'"
								cQuery += " AND DB_PRODUTO     = '"+cProduto+"'"
								cQuery += " AND DB_DOC         = '"+cDocto+"'"
								cQuery += " AND DB_SERIE       = '"+cSerie+"'"
								cQuery += " AND DB_CLIFOR      = '"+cCliFor+"'"
								cQuery += " AND DB_LOJA        = '"+cLoja+"'"
								cQuery += " AND DB_SERVIC      = '"+cServic+"'"
								cQuery += " AND DB_ATUEST      = 'N'"
								cQuery += " AND DB_DATA    > '"+dDataFec+"'"
								If	lWmsQySDB
									cRetPE := ExecBlock('WMSQYSDB',.F.,.F.,{cQuery})
									If ValType(cRetPE)=='C'
										cQuery := cRetPE
									EndIf
								EndIf
								cQuery += " AND SDB.D_E_L_E_T_ = ' '"
								cQuery += " ORDER BY DB_FILIAL,DB_PRODUTO,DB_DOC,DB_SERIE,DB_CLIFOR,DB_LOJA,DB_SERVIC"
								cQuery := ChangeQuery(cQuery)
								DbUseArea(.T.,'TOPCONN',TCGENQRY(,,cQuery),cAliasNew,.F.,.T.)
							#ELSE
								cIndSDB := CriaTrab(NIL,.F.)
								cQuery := "DB_FILIAL  == '"+xFilial("SDB")+"' .And. "
								cQuery += "DB_PRODUTO == '"+cProduto+"' .And. "
								cQuery += "DB_DOC     == '"+cDocto+"' .And. "
								cQuery += "DB_SERIE   == '"+cSerie+"' .And. "
								cQuery += "DB_CLIFOR  == '"+cCliFor+"' .And. "
								cQuery += "DB_LOJA    == '"+cLoja+"' .And. "
								cQuery += "DTOS(DB_DATA) > '"+dDataFec+"' .And. "
								cQuery += "DB_SERVIC  == '"+cServic+"' .And. "
								cQuery += "DB_ATUEST  == 'N'"
								If	lWmsQySDB
									cRetPE := ExecBlock('WMSQYSDB',.F.,.F.,{cQuery})
									If ValType(cRetPE)=='C'
										cQuery := cRetPE
									EndIf
								EndIf
								IndRegua(cAliasNew,cIndSDB,'DB_FILIAL+DB_PRODUTO+DB_DOC+DB_SERIE+DB_CLIFOR+DB_LOJA+DB_SERVIC',,cQuery,'Selecionando Registros...')
								nIndex := RetIndex()
								DbSetIndex(cIndSDB+OrdBagExt())
								DbSetOrder(nIndex+1)
								DbGotop()
							#ENDIF
							While (cAliasNew)->(!Eof())
								If	lQuery
									SDB->(DbGoto((cAliasNew)->SDBRECNO))
								EndIf
								RecLock('SDB',.F.)
								SDB->DB_ESTORNO := 'S'
								SDB->DB_STATUS  := 'F'
								MsUnLock()
								(cAliasNew)->(DbSkip())
							EndDo
							If	lQuery
								DbSelectarea(cAliasNew)
								DbCloseArea()
							Else
								If	File(cIndSDB+OrdBagExt())
									Ferase(cIndSDB+OrdBagExt())
								EndIf
							EndIf
						EndIf
						RecLock('DCF', .F., .T.)
						dbDelete()
						MsUnlock()
						//-- Retira a referencia ao documento original
						WmsDocOri('4',cDocto,cSerie)
					EndIf
					DCF->(dbSkip())
				EndDo
			EndIf
		EndIf
	EndIf
//-- Exclusao da execucao de servicos atraves das rotinas de estorno do DLGA150 e WMSA330.
//-- OBS: Deve estar posicionado no registro do DCF.
ElseIf cAcao == '2'
	//-- Verifica status do servico
	If	! Empty(nStatDCF)
		If	! DlA150ChkSt(DCF->DCF_STSERV,nStatDCF)
			RestArea(aAreaAnt)
			Return(.F.)
		EndIf
	EndIf
	If	WmsChkSDB('2',aRegSDB)
		lRet := WmsExeDCF('3',,aRegSDB)
		RestArea(aAreaAnt)
		Return(lRet)
	Else
		If	SuperGetMV('MV_WMSVLDE',.F.,.T.)
			//-- No estorno de um servico de saida, o status do endereco Origem (De onde o Produto SAIU) deve
			//-- ser analisado:
			//-- Se o status do endereco Origem estiver 1-ocupado  , o saldo nao podera retornar pq ira ultrapassar a capacidade total
			//-- Se o status do endereco Origem estiver 3-bloqueado, o saldo nao podera retornar para esse endereco
			//-- Validacao do estorno
			If !WmsVldExc('1',DCF->DCF_CARGA,DCF->DCF_DOCTO,DCF->DCF_SERIE,DCF->DCF_SERVIC,DCF->DCF_CODPRO,DCF->DCF_CLIFOR,DCF->DCF_LOJA,DCF->DCF_ORIGEM)
				//-- Gera enderecamento na impossibilidade do estorno do apanhe
				If	SuperGetMV('MV_WMSREDI',.F.,.F.) .And. Aviso('SIGAWMS','Gera Servico de Enderecamento?', {'Sim','Nao'})==1
					WmsExeDCF('3')
				EndIf
				RestArea(aAreaAnt)
				Return(.F.)
			EndIf
		EndIf
		lDLGA150D:= ExistBlock('DLGA150D')
		lDocOri	:= WmsDocOri('1')	//-- Verifica se habilita estorno dos itens do dcf com referencia ao documento original
		nPosDCF	:= DCF->(Recno())
		cDocto	:= DCF->DCF_DOCTO
		cSerie	:= DCF->DCF_SERIE
		cCarga	:= DCF->DCF_CARGA
		If	lDocOri .And. Empty(DCF->DCF_DOCORI)
			lDelDoc := .T.
		Else
			lDelDoc := .F.
		EndIf
		lRet := .T.
		//-- Ponto de Entrada DLGA150D (Antes do Estorno do Servico)
		//-- Parametros Passados:
		//-- PARAMIXB[1] = Produto
		//-- PARAMIXB[2] = Local
		//-- PARAMIXB[3] = Documento
		//-- PARAMIXB[4] = Serie
		//-- PARAMIXB[5] = Recno no DCF
		If lDLGA150D
			lRetPE := ExecBlock('DLGA150D', .F., .F., {DCF->DCF_CODPRO, DCF->DCF_LOCAL, cDocto, cSerie, nPosDCF})
			If	ValType(lRetPE)=='L'
				lRet := lRetPE
			EndIf
		EndIf
	
		If	lRet
			lRet := DLA220Esto(.F.,lProcessa)

			If	lRet .And. lEstSrvAut
				If	lDelDoc
					If	WmsCarga(cCarga)
						If	aScan(aDocOri,{|x|x[3]==cCarga})==0
							AAdd(aDocOri,{'','',cCarga})
						EndIf
					Else
						If	aScan(aDocOri,{|x|x[1]+x[2]==cDocto+cSerie})==0
							AAdd(aDocOri,{cDocto,cSerie,''})
						EndIf
					EndIf
				EndIf
			EndIf
		EndIf
	EndIf
ElseIf cAcao == '3'
	For nCntFor := 1 To Len(aDocOri)
		//-- Estorna todos os documentos com referencia a carga ou documento original
		WmsDocOri('2',aDocOri[nCntFor,1],aDocOri[nCntFor,2],aDocOri[nCntFor,3],lDLGA150D,nStatDCF)
	Next
EndIf
RestArea(aAreaAnt)
Return lRet

/*


Ŀ
Funo    FtVldQtVen Autor Henry Fila              Data 17/01/2003  
Ĵ
Descrio Verifica se uma quantidade de venda de um produto esta sendo  
          vendida com seu lote minimo                                   
Ĵ
Sintaxe   ExpL1 := FtVldQtVen( ExpC1, ExpC2,ExpL1 )                     
Ĵ
ParametrosExpC1: Produto                                                
          ExpC2: Quantidade                                             
          ExpL3: Mostra help ou nao                                     
Ĵ
Retorno   ExpL1: Validacao : .T. valido , .F. nao valido                
Ĵ
Uso        Materiais/Distribuicao/Logistica                             
Ĵ
 AtualizACQes sofridas desde a Construcao Inicial.                       
Ĵ
 Programador   Data    BOPS   Motivo da Alteracao                     
Ĵ
                                                                      
ٱ


*/
Function FtVldQtVen(cProduto,nQtde,lHelp,cTipo)

Local lRet     := .T.
Local aArea    := GetArea()
Local aAreaSB1 := SB1->(GetArea())

DEFAULT lHelp := .T.
DEFAULT cTipo := "N"

If SB1->(FieldPos("B1_LOTVEN")) > 0

	SB1->(dbSetOrder(1))
	If SB1->(MsSeek(xFilial("SB1")+cProduto))
		If cTipo == "N" .And. SB1->B1_LOTVEN <> 0 .And. SB1->B1_LOTVEN > nQtde
			If lHelp
				Help(" ",1,"FTQTDMIN")
			Endif
			lRet := .F.
			If ExistBlock( "FTQTDMIN" )
				lRet := ExecBlock( "FTQTDMIN", .F., .F. )
			EndIf
		Endif
	Endif
Endif

RestArea(aAreaSB1)
Restarea(aArea)

Return(lRet)

/*


Ŀ
Funo    MaVenStrUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de vendedores       
           Funcao de chamada                                          
Ĵ
Sintaxe    MaVenStrUp( ExpC1, @ExpA1, [ ExpL1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpL1 -> Inverte a contagem de niveis no array. Quando     
           .T., a ordem passa a ser de cima para baixo                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaVenStrUp( cGrpAtu, aGrupos, lInverte )

Local aArea    := GetArea()
Local aAreaACA := ACA->( GetArea() )

lInverte := If( ValType( lInverte ) == "L", lInverte, .F. )

//Ŀ
// Chama a funcao de processamento                              
//
MaPrcRepUp( cGrpAtu, @aGrupos )

//Ŀ
// Inverte a ordem de niveis                                    
//
If lInverte
	ASort( aGrupos, , , { |x,y| x[ 2 ] > y[ 2 ] } )
	AEval( aGrupos, { |x,y| x[ 2 ] := y } )
EndIf

RestArea( aAreaACA )
RestArea( aArea )

Return( .T. )

/*


Ŀ
Funo    MaPrcRepUp Autor Sergio Silveira         Data 19/07/2002
Ĵ
Descrio  Traz todos os grupos acima de um grupo de vendedores       
           ( processamento )                                          
Ĵ
Sintaxe    MaPrcRepUp( ExpC1, @ExpA1, [ ExpN1 ] )                     
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros ExpC1 -> Grupo a pesquisar                                 
           ExpA1 -> Array contendo os grupos. Deve ser passado por    
              referencia e alimentado pela funcao                     
                 Estrutura : 1 - Grupo ( C )                          
                             2 - Nivel do grupo ( N )                 
           ExpN1 -> Nivel atual. Este parametro nao deve ser passado  
           na chamada inicial, pois e passado quando a funcao chama   
           ela mesma ( recursividade )                                
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/

Function MaPrcRepUp( cGrpAtu, aGrupos, nLevel )

Local cSeekACA  := ""

If ValType( nLevel ) <> "N"
	nLevel := 0
EndIf

//Ŀ
// Incrementa o contador de niveis                              
//

nLevel++

ACA->( dbSetOrder( 1 ) )
cSeekACA := xFilial( "ACA" ) + cGrpAtu
If ACA->( dbSeek( cSeekACA ) )
	AAdd( aGrupos, { ACA->ACA_GRPREP, nLevel } )
	MaPrcRepUp( ACA->ACA_GRPSUP, @aGrupos, @nLevel )
EndIf

//Ŀ
// Decrementa o contador de niveis                              
//
nLevel--

Return()

/*


Ŀ
Funo    Ma440Compl Autor Henry Fila              Data 24/11/2003
Ĵ
Descrio  Verifica se eh complemento de precos e possui item liberado
Ĵ
Sintaxe    Ma440Compl()                                               
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function Ma440Compl()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())

If SC5->C5_TIPO $ "CIP"
	SC9->(dbSetOrder(2))
	If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
		lRet := .F.
	Endif

	If lRet
		If !Empty(SC6->C6_NOTA)
			lRet := .F.
		Endif
	Endif
Else
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)


/*


Ŀ
Funo    MaTesLZero Autor Henry Fila              Data 24/11/2003
Ĵ
Descrio  Verifica se eh quantidade zerada e possui item liberado    
Ĵ
Sintaxe    Ma440Compl()                                               
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function MaTesLZero()

Local lRet  := .T.
Local aArea := GetArea()
Local aAreaSC9 := SC9->(GetArea())

SC9->(dbSetOrder(2))
If SC9->(MsSeek(xFilial("SC9")+SC5->C5_CLIENTE+SC5->C5_LOJACLI+SC5->C5_NUM+SC6->C6_ITEM))
	lRet := .F.
Endif

RestArea(aAreaSC9)
RestArea(aArea)

Return(lRet)

/*


Ŀ
Funo     FatLoad   Autor Marco Bianchi           Data 18/10/2007
Ĵ
Descrio  Funcoes a serem executadas na entrada do modulo Faturamento
Ĵ
Sintaxe    FatLoad()                                                  
Ĵ
Retorno    Nenhum                                                     
Ĵ
Parametros Nenhum                                                     
Ĵ
   DATA    Programador   Manutencao Efetuada                         
Ĵ
                                                                     
ٱ


*/
Function FatLoad()

//Ŀ
// Depuracao de reservas                                   
//
a430Auto()

//Ŀ
//Criacao de um template de proposta comercial 
//para integracao,com Microsoft Word.          
//
If FindFunction("R600TWrd")
	R600TWrd()
End    

If cPaisLoc $ "COL"
	CIIUCOL()
EndIf

//Ŀ
// Realiza Bloqueio automatico de Inventario com base no parametro MV_BLQINVA 
//
If (FindFunction("MATA271_V") .And. MATA271_V() >= 20120120)
	MATA271(.T.)
EndIf
        

Return

/*


ͻ
Programa  A410LibBen Autor  Andre Anjos          Data   05/12/08   
͹
Descricao  Libera o saldo empenhado para o item de PV referente a      
			  remessa de beneficiamento quando ha lote e;ou localizacao.  
͹
Parametro  nEvento: Evento que esta sendo processado.				   
			  	1- Analise de saldo disponivel.							   
			  	2- Estorno de liberacao.								   
			  cAlias: Alias onde se encontra o empenho.				   
			  nRecno: Recno do registro de empenho.					   
			  nQtd1: Quantidade a ser restaurada 1UM.					   
			  nQtd2: Quantidade a ser restaurada 2UM.					   
͹
Retorno	  nRet: Quantidade do empenho baixado.						   
͹
Uso        FATXFUN                                   				   
ͼ


*/
Function A410LibBen(nEvento,cAlias,nRecno,nQtd1,nQtd2)
Local aArea 	:= GetArea()
Local nRet 		:= 0
Local aTravas 	:= {}
Local nBaixa 	:= 0
Local cCpo1 	:= Substr(cAlias,2,2) + "_QUANT"
Local cCpo2 	:= Substr(cAlias,2,2) + "_QTSEGUM"
Local cCpoOrig := Substr(cAlias,2,2) + If(cAlias == "SDC","_QTDORIG","_QTDEORI")
Local cCpoProd := Substr(cAlias,2,2) + If(cAlias == "SDC","_PRODUTO","_COD")
Local cCpoLoc  := Substr(cAlias,2,2) + "_LOCAL"
Local nOperac	:= If(nEvento == 1,-1,1)

dbSelectArea(cAlias)
dbGoTo(nRecno)

Default nQtd2 := If(&(cCpo2)>0,nQtd1/(&(cCpo1)/&(cCpo2)),0)
nRet := &(cCpo1)

//Prepara seek nas tabelas de saldos
SB2->(dbSetOrder(1))
SB8->(dbSetOrder(3))
SBF->(dbSetOrder(1))

If nEvento == 1 .And. nQtd1 > &(cCpo1)
	nQtd1 := &(cCpo1)
	nQtd2 := &(cCpo2)
ElseIf nEvento == 2 .And. nQtd1 > &(cCpoOrig)
	nQtd1 := &(cCpoOrig)
	nQtd2 := ConvUM(&(cCpoProd),nQtd1,0,2)
EndIf 		

Begin Transaction
	If cAlias == "SDC"
		dbSelectArea("SD4")
		dbSetOrder(1)
		If dbSeek(xFilial("SD4")+SDC->(DC_PRODUTO+DC_OP+DC_TRT+DC_LOTECTL+DC_NUMLOTE))
			RecLock("SD4",.F.)
			Replace D4_QUANT With D4_QUANT + (nQtd1 * nOperac)
			Replace D4_QTSEGUM With D4_QTSEGUM + (nQtd2 * nOperac)
			MsUnLock()
		EndIf
		SBF->(dbSeek(xFilial("SB2")+SDC->(DC_LOCAL+DC_LOCALIZ+DC_PRODUTO+DC_NUMSERI+DC_LOTECTL+DC_NUMLOTE)))
		GravaBFEmp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
	EndIf
	
	SB2->(dbSeek(xFilial("SB2")+SD4->(D4_COD+D4_LOCAL)))
	GravaB2Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
	If !Empty(SD4->(D4_LOTECTL+D4_NUMLOTE))
		SB8->(dbSeek(xFilial("SB2")+SD4->(D4_COD+D4_LOCAL+D4_LOTECTL+If(Rastro(D4_COD,"S"),D4_NUMLOTE,""))))
		GravaB8Emp("+",(nQtd1*nOperac),"F",.F.,(nQtd2*nOperac))
	EndIf
	
	dbSelectArea(cAlias)
	RecLock(cAlias,.F.)
	Replace &(cCpo1) With &(cCpo1) + (nQtd1 * nOperac)
	Replace &(cCpo2) With &(cCpo2) + (nQtd2 * nOperac)
	MsUnLock()
End Transaction
		
RestArea(aArea)
Return nRet

/*


ͻ
Programa  FatAtuEmpNAutor  Andre Anjos          Data   28/05/09   
͹
Descricao  Funcao utilizada para fazer o controle de preenchimento do 
           campo B2_QEMPN nas atualizacoes de itens de pedido de venda
           (SC6 posicionado no item desejado).						  
͹
Parametros cSinal: sinal da operacao								  
͹
Uso        FATXFUN, MATA450 E MATA521								  
ͼ


*/
Function FatAtuEmpN(cSinal,lEstorn,cAliasSC9,lSeekSC6)
Local aArea       := GetArea()
Local aAreaSB2    := SB2->(GetArea())
Local lA650QLibPV := FindFunction("A650QLibPV")
Local lAtuSGJ     := .F.
Local nQtdAtEmpN  := 0
Local nQtdDif	  := 0
DEFAULT lEstorn   := .F.
DEFAULT cAliasSC9 := "SC9"
DEFAULT lSeekSC6  := .F.

//Posiciona SC6 caso necessario
If lSeekSC6 .And. !(xFilial("SC6")==SC6->C6_FILIAL .And.;
		SC6->C6_NUM==(cAliasSC9)->C9_PEDIDO .And.;
		SC6->C6_ITEM==(cAliasSC9)->C9_ITEM .And.;
		SC6->C6_PRODUTO==(cAliasSC9)->C9_PRODUTO)
	dbSelectArea("SC6")
	dbSetOrder(1)
	MsSeek(xFilial("SC6")+(cAliasSC9)->C9_PEDIDO+(cAliasSC9)->C9_ITEM+(cAliasSC9)->C9_PRODUTO)
EndIf

SB2->(dbSetOrder(1))

If !Empty(SC6->(C6_NUMOP+C6_ITEMOP))
	SC2->(dbSetOrder(1))
	SC2->(dbSeek(xFilial("SC2")+SC6->(C6_NUMOP+C6_ITEMOP)))
	If !SB2->(dbSeek(xFilial("SB2")+SC2->(C2_PRODUTO+C2_LOCAL)))
		CriaSB2(SC2->C2_PRODUTO,SC2->C2_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC2->C2_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn,cAliasSC9),0),cSinal,SC2->C2_TPOP)
	EndIf
ElseIf SC6->(FieldPos("C6_NUMSC")) > 0 .And. !Empty(SC6->(C6_NUMSC+C6_ITEMSC))
	SC1->(dbSetOrder(1))
	SC1->(dbSeek(xFilial("SC1")+SC6->(C6_NUMSC+C6_ITEMSC)))
	If !SB2->(dbSeek(xFilial("SB2")+SC1->(C1_PRODUTO+C1_LOCAL)))
		CriaSB2(SC1->C1_PRODUTO,SC1->C1_LOCAL)
	EndIf
	If !lEstorn
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,A650QLibPV(),0),cSinal,SC1->C1_TPOP)
	Else
		A650AtEmpN(If(lA650QLibPV,A650QLibPV(lEstorn),0),cSinal,SC1->C1_TPOP)
	EndIf
ElseIf SC6->C6_OP $ "03/05/06"
	SB2->(dbSeek(xFilial("SB2")+SC6->(C6_PRODUTO+C6_LOCAL)))
	If !lEstorn
		nQtdAtEmpN := A650QLibPV()
		lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
		If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ .And. Localiza(SC6->C6_PRODUTO) .And. cSinal=="+"
			nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
			// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
			If QtdComp(nQtdDif) < QtdComp(0)
				nQtdAtEmpN += nQtdDif
			EndIf
      	EndIf
		A650AtEmpN(SC6->(C6_QTDVEN-C6_QTDENT-C6_QTDRESE) - If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	Else
		If lA650QLibPV
			nQtdAtEmpN := A650QLibPV(lEstorn)
			lAtuSGJ	:= SuperGetMV("MV_PVCOMOP",.F.,.F.) .And. FindFunction("ALIASINDIC") .And. AliasIndic("SGJ")
			If !SuperGetMv("MV_LIBACIM") .And. !lAtuSGJ
				nQtdDif := ( SC6->(C6_QTDVEN-C6_QTDENT) - nQtdAtEmpN )
				// Indica liberacao acima do saldo do pedido e nao grava o excesso liberado em B2_QEMPN
				If QtdComp(nQtdDif) < QtdComp(0)
					nQtdAtEmpN += nQtdDif
				EndIf
			EndIf
		EndIf
		A650AtEmpN(If(lA650QLibPV,nQtdAtEmpN,0),cSinal,SC6->C6_TPOP)
	EndIf
EndIf				
RestArea(aAreaSB2)
RestArea(aArea)
Return

/*


ͻ
Programa  FatCredToolsAutor  Faturamento          Data   28/05/09 
͹
Descricao  Funcao utilizada para fazer o analise de credito via 	  
           intellector da tools										  
͹
Parametros nValor: Valor acumulado de cada item do pedido de venda	  
͹
Uso        FATXFUN e MATA450										  
ͼ


*/
Function FatCredTools(cCodCli, cLojaCli, nVlItAcum, nVlTitAbe, nVlTitAtras)

Local cMvTolPoVe	:= ALLTRIM(SuperGetMv("MV_TOLPOVE", .F.,""))   //Politica de venda para integracao com Intellector
Local cMvTolTiVe	:= ALLTRIM(SuperGetMv("MV_TOLTIVE", .F.,""))   //Tipo de politica de venda para integracao com Intellector
Local cMvTolLayo	:= ALLTRIM(SuperGetMv("MV_TOLLAYO", .F.,""))   //Layout da politica para integracao com Intellector

Local nMvCrdTole	:= SuperGetMV("MV_CRDTOLE", .F., 1)			//Valor de tolerancia para liberacao de limite de credito
Local oRetYMF		:= NIL											//Objeto do tipo LJCDadosRetYMF
Local lRetorno		:= .F.											//Retorno da funcao

//Faz a analise de credito via Tools				
oRetYMF	:= CrdXExecYMF(cMvTolPoVe  , cMvTolTiVe ,cMvTolLayo  ,cCodCli ,;
 						  cLojaCli, nVlTitAbe ,nMvCrdTole 	,nVlItAcum	  ,;
 						  nVlTitAtras)

//Limite de credito aprovado						
lRetorno :=  (ValType(oRetYMF) == "O" .AND. oRetYMF:lAprovado)

Return lRetorno
/*


ͻ
Programa  FtIsP10R13Autor  Vendas CRM           Data   10/03/10   
͹
Desc.     Indica se o Protheus esta em um release acima da versao 10  
          Release 1.3                                                 
͹
Uso       FATA070                                                     
ͼ


*/
Function FtIsP10R13()

Local lRet 		:= .T.
Local lVersao10	:= Left(GetVersao(.F.),3) == "P10"

//Ŀ
//Se nao for versao 10, significa que o Protheus ja se encontra
//em uma versao superior, acima do release indicado.           
//
If lVersao10
	If GetRpoRelease() >= "R1.3"
		lRet := .T.
	Else
		lRet := .F.
	EndIf
EndIf

Return lRet

/*


Ŀ
Funo    AC8Exclui  Autor  Vendas CRM             Data 21/06/10  
Ĵ
Descrio Exclusao do Contato amarrado a uma entidade.             	  
ٱ
Parametros cCodCon: codigo do contato a ser validado    			  
           nRecAc8: recno da tabela AC8.                			  
ٱ


*/
Function AC8Exclui(cCodCon,nRecAc8)

Local aAreaAC8   := AC8->(GetArea())
Local lRet 		 := .T.							// Retorno da funcao - TRUE exclusao OK, FALSE exclusao NEGADA
Local nBusca     := 0 
Local nRecnoSM0  := SM0->(RecNo())
Local cFilAtu	 := SM0->M0_CODFIL
Local aSM0CodFil := {}     
Local cEntida    := ""
Local cCodEnt    := ""
Local lTemIndice := .F.

DbSelectArea("AC8")
DbGoTo(nRecAc8)

cEntida   := AC8->AC8_ENTIDA
cCodEnt   := Alltrim(AC8->AC8_CODENT)

// Preenche um array com as filiais
DbSelectArea("SM0")
DbGoTop()
Do While ! Eof()
	If SM0->M0_CODIGO == cEmpAnt
		AAdd(aSM0CodFil, cFilAtu)
	Endif
	dbSkip()
End	
DbGoto(nRecnoSM0)

//Ŀ
//Verifica se existe algum atendimento para o contato na tabela de TELEMARKETING
//
dbSelectArea("SIX")
dbSetOrder(1)
If dbSeek("SUC7") .And. Alltrim(SIX->CHAVE) == "UC_FILIAL+UC_CODCONT+UC_ENTIDAD+UC_CHAVE"
	lTemIndice:=.T.
EndIf

If lTemIndice
	DbSelectArea("SUC")
	DbSetOrder(7)  
	aFiliais := If(FWModeAccess("SUC",3) == "E" .AND. FWModeAccess("AC8",3) == "C", aClone(aSM0CodFil), {xFilial()})
	For nBusca := 1 To Len(aFiliais)
	   	If DbSeek(aFiliais[nBusca]+cCodCon+cEntida+cCodEnt)
	   		Help(" ",1,"TMKNDELREL")
		   	lRet := .F. 
			Exit
		EndIf
	Next
	lTemIndice:=.F.				
EndIf

If lRet
	//Ŀ
	//Verifica se existe algum atendimento para o contato na tabela de TELEVENDAS
	//
	dbSelectArea("SIX")
	dbSetOrder(1)
	If dbSeek("SUAB") .And. Alltrim(SIX->CHAVE) == "UA_FILIAL+UA_CODCONT+UA_CLIENTE+UA_LOJA"
		lTemIndice:=.T.
	EndIf
	
	If lTemIndice
		DbSelectArea("SUA")
		DbSetOrder(11)
		aFiliais := If(FWModeAccess("SUA",3) == "E" .AND. FWModeAccess("AC8",3) == "C", aClone(aSM0CodFil), {xFilial()})
		For nBusca := 1 To Len(aFiliais)
		   	If DbSeek(aFiliais[nBusca]+cCodCon+cCodEnt)
	   			Help(" ",1,"TMKNDELREL")
			   	lRet := .F. 
				Exit
			EndIf
		Next			
		lTemIndice:=.F.				
	EndIf
EndIf	

If lRet
//Ŀ
//Verifica se existe algum atendimento para o contato na tabela de TELECOBRANCA
//
   	dbSelectArea("SIX")
	dbSetOrder(1)
	IF dbSeek("ACF7") .And. Alltrim(SIX->CHAVE) == "ACF_FILIAL+ACF_CODCON+ACF_CLIENT+ACF_LOJA" 
			lTemIndice:=.T.
	EndIf

	If lTemIndice
		DbSelectArea("ACF")
		DbSetOrder(7)
		aFiliais := If(FWModeAccess("ACF",3) == "E" .AND. FWModeAccess("AC8",3) == "C", aClone(aSM0CodFil), {xFilial()})
		For nBusca := 1 To Len(aFiliais)
		   	If DbSeek(aFiliais[nBusca]+cCodCon+cCodEnt)
		   		Help(" ",1,"TMKNDELREL")
			   	lRet := .F. 
				Exit
			EndIf
		Next 
		lTemIndice:=.F.				
	EndIf			
EndIf	

If lRet
	//Ŀ
	// Verifica se existe Atendimento para o contato ADE            
	//
   	dbSelectArea("SIX")
	dbSetOrder(1)
	If dbSeek("ADEN") .And. Alltrim(SIX->CHAVE) == "ADE_FILIAL+ADE_CODCON+ADE_ENTIDA+ADE_CHAVE"
	   lTemIndice:=.T.
	EndIf
		
	If lTemIndice
		DbSelectArea("ADE")
		DbSetOrder(23)
		aFiliais := If(FWModeAccess("ADE",3) == "E" .AND. FWModeAccess("AC8",3) == "C", aClone(aSM0CodFil), {xFilial()})
		For nBusca := 1 To Len(aFiliais)
		   	If DbSeek(aFiliais[nBusca]+cCodCon+cEntida+cCodEnt)
	   			Help(" ",1,"TMKNDELADE")
			   	lRet := .F. 
				Exit
			EndIf
		Next
		lTemIndice:=.F.				
	EndIf					
EndIf	
            
RestArea(aAreaAC8)

Return(lRet)
/*


ͻ
Programa  BlPVLFat  Autor  Microsiga            Data   04/18/11   
͹
Desc.                                                                 
͹
Uso       FATXFUN - So para atender legislao de Alagoas             
ͼ


*/
Function BlPVLFat(cCli,cLoja,lPvBloq)
Local lBlqPv     := .F. // Pedido no bloqueado
Local lLibPv   := IsInCallStack("FT210PROC") .Or. IsInCallStack("MA215PROC")
Local lContrICM:= .F. 
Local aSvAreaA1:= SA1->(GetArea())
Local aSvAreaC6:= {}
Local cQueryD2 := ""
Local cQueryC9 := ""  
Local cAliasD2 := GetNextAlias()
Local cAliasC9 := GetNextAlias()
Local nValLim := SuperGetMv("MV_LIMFTAL",,0)
Local cDtIni := StrZero(Year(dDataBase),4) + StrZero(Month(dDataBase),2) +  "01" // primeiro dia do mes database
Local cDtFim := DtoS(CtoD("01" + "/" + StrZero(IIF(Month(dDataBase)==12,1,Month(dDataBase) + 1),2) + "/" + StrZero(Year(dDataBase),4)) - 1) // ultimo dia do mes database
Local nTotFat := 0
Local nValPed := 0
Local InX     := 0
Local nPosVlr := IIf(!lLibPv,aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_VALOR"}),0)
Local nPosTES := IIf(!lLibPv,aScan(aHeader,{|x| Alltrim(Upper(x[2])) == "C6_TES"}),0)

Default lPvBloq := .F.

lPvBloq := IIf(lLibPv,.F.,lPvBloq) // Pela rotina(FATA210) de liberacao sempre considera como no bloqueado

//Ŀ
//Verifica se o cliente  contribuinte de ICMS. Mesmo tratamento feito no MATXFIS 
//
SA1->(dbSetOrder(1))
If SA1->(MsSeek(xFilial("SA1")+cCli+cLoja))
	If AllTrim(SuperGetMv("MV_ESTADO")) == AllTrim(SA1->A1_EST)
		lContrICM := IIf(Empty(SA1->A1_INSCR).Or."ISENT"$SA1->A1_INSCR.Or."RG"$SA1->A1_INSCR.Or.(SA1->(FieldPos("A1_CONTRIB")) > 0 .And. SA1->A1_CONTRIB == "2"),.F.,.T.)
		//Tratamento para considerar como contribuinte do ICMS Produtor Rural com inscrio Rural
		If !Empty(SA1->A1_INSCRUR) .And. "L" $ SA1->A1_TIPO .And. (SA1->(FieldPos("A1_CONTRIB")) > 0 .And. SA1->A1_CONTRIB <> "1")
			lContrICM := .F.
		EndIf	
		If !lContrICM .And. nValLim > 0 .And. !lPvBloq
			//Ŀ
			//Totaliza os pedidos liberados para faturameto dentro do mes corrente, conforme o cliente solicitado.
			//
			cQueryC9 := " SELECT SUM((C9_QTDLIB * C9_PRCVEN)) TOTAL "
			cQueryC9 += "   FROM " + RetSqlName("SC9")
			cQueryC9 += " WHERE D_E_L_E_T_ = '' "
			cQueryC9 += "   AND C9_FILIAL = '" + xFilial("SC9") + "' "
			cQueryC9 += "   AND C9_NFISCAL = '' "
			cQueryC9 += "   AND C9_DATALIB BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryC9 += "   AND C9_CLIENTE = '" + cCli + "' "
			cQueryC9 += "   AND C9_LOJA = '" + cLoja + "' "
			
			If Select(cAliasC9) > 0 
				dbSelectArea(cAliasC9)
			   dbCloseArea()
			EndIf
					        
			cQueryC9 := ChangeQuery( cQueryC9 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryC9), cAliasC9, .T., .T. )
							
			(cAliasC9)->TOTAL
						
			//Ŀ
			//Totaliza as notas fiscais emitida dentro do mes corrente, conforme o cliente solicitado.
			//
			cQueryD2 := " SELECT SUM(D2_TOTAL) TOTAL "
			cQueryD2 += "   FROM " + RetSqlName("SD2")
			cQueryD2 += "  WHERE D_E_L_E_T_ = '' "
			cQueryD2 += "     AND D2_FILIAL = '" + xFilial("SD2") + "' "
			cQueryD2 += "     AND D2_EMISSAO BETWEEN '" + cDtIni + "' AND '" + cDtFim + "' "
			cQueryD2 += "     AND D2_CLIENTE = '" + cCli + "' "
			cQueryD2 += "     AND D2_LOJA = '" + cLoja + "' "
			
			If Select(cAliasD2) > 0 
				dbSelectArea(cAliasD2)
			   dbCloseArea()
			EndIf
					        
			cQueryD2 := ChangeQuery( cQueryD2 )
			dbUseArea( .T., "TOPCONN", TcGenQry(,,cQueryD2), cAliasD2, .T., .T. )
			
			nTotFat := (cAliasC9)->TOTAL + (cAliasD2)->TOTAL
			
			//Ŀ
			//Fecha as duas tabelas
			//
			(cAliasC9)->(dbCloseArea())
			(cAliasD2)->(dbCloseArea())
			
			If nTotFat > nValLim
				lBlqPv := .T.
			Else
				If lLibPv // Liberao, verifica direto na tabela SC6
					aSvAreaC6:= SC6->(GetArea())
					SC6->(dbSetOrder(1))
					SC6->(dbSeek(xFilial("SC6")+SC5->C5_NUM))
					While SC6->(!Eof()) .And. SC5->C5_NUM == SC6->C6_NUM
						If Posicione("SF4",1,xFilial("SF4")+SC6->C6_TES,"F4_DUPLIC") == "S"
							nValPed += SC6->C6_VALOR
						EndIf
						SC6->(dbSkip())
					EndDo
					RestArea(aSvAreaC6)
				Else
					For InX := 1 To Len(aCols)
						If !(aCols[InX,Len(aHeader)+1]) .And. (Posicione("SF4",1,xFilial("SF4")+aCols[InX][nPosTES],"F4_DUPLIC") == "S")
							nValPed += aCols[InX][nPosVlr]
						EndIf
					Next InX
				EndIf
				If (nTotFat + nValPed) > nValLim
					lBlqPv := .T.
				EndIf
			EndIf
			
			If lBlqPv .And. !(IsInCallStack("MA215PROC"))
				 VerBlqReg("BLQAL", 0, "", "", "")
			EndIf
		Else
			lBlqPv := lPvBloq
		EndIf
	EndIf
EndIf

RestArea(aSvAreaA1)

Return lBlqPv
/*


ͻ
Programa  RhInssPat Autor  Vendas CRM           Data   12/01/12   
͹
Desc.     Rotina para calculo do INSS Patronal chamada pelo mdulo de 
          RH                                                          
Ĵ
ObservacaocPeriodo -> Ms e Ano recebido do parmetro				  
          cFilProc-> Filial de processamento da rotina				  
			 l13Sal  -> Indica se  clculo de 13 salario               
          cPeriodo13-> Periodo inicial e final para calculo do 13sal  
          												  	 	      
͹
Uso        Vendas CRM                                                 
ͼ


*/ 
Function RhInssPat(cPeriodo,cFilProc,l13Sal,cPeriodo13)

Local cQuery 		:= ""
Local cQueryD1 		:= ""
Local cQueryCG1		:= ""                                                               	
Local cAliasQry 	:= GetNextAlias()
Local cAliasSD1		:= GetNextAlias() 
Local cQryCG1		:= GetNextAlias()
Local nPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. !Empty(cPeriodo13), AT("/",cPeriodo13),0)
Local cPerIni13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,1,nPerIni13-1)),"")
Local cPerFim13		:= IiF (ValType(cPeriodo13)=="C" .And. nPerIni13 > 0, AllTrim(SubStr(cPeriodo13,nPerIni13+1,(Len(cPeriodo13)))),"") 
Local dPerFim13		:= IiF (!Empty(cPerFim13),CTOD("01"+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)),CTOD(""))
Local dPerIni		:= IiF (!l13Sal,CTOD("01"+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)), CTOD("01"+"/"+SUBSTR(cPerIni13,1,2)+"/"+SUBSTR(cPerIni13,5,6)))
Local dPerFim		:= IiF (!l13Sal,CTOD(StrZero(F_ULTDIA(dPerIni),2)+"/"+SUBSTR(cPeriodo,1,2)+"/"+SUBSTR(cPeriodo,5,6)),CTOD(StrZero(F_ULTDIA(dPerFim13),2)+"/"+SUBSTR(cPerFim13,1,2)+"/"+SUBSTR(cPerFim13,5,6)))
Local aArea			:= GetArea()
Local aCFOPs		:= XFUNCFRec()  
Local cArquivo      := ""
Local cChave        := ""
Local cIniDes		:= SuperGetMv("MV_DESFOL",,"201208") //Periodo de inicio do cliente na desonerao Ms+Ano   se for fazer colocar o param no updfat23
Local cCFIND		:= SuperGetMv("MV_CFIND",,"") //CFOPs das vendas dos produtos industrializados pela empresa
Local cNFOrig 		:= ""
Local cSerOrig		:= ""
Local nIndex        := 0 
Local nFatBrut		:= 0 
Local nFatLiq		:= 0 
Local nFatRec		:= 0
Local nFatExp		:= 0
Local nPosFis		:= 0
Local nPosDev		:= 0
Local nPosExp       := 0  
Local nTotLiqDev    := 0  
Local nFatLiqExp    := 0  
Local nX            := 0
Local nTotDev       := 0
Local nTot	        := 0
Local nImpostos     := 0
Local aTotFis		:= {}
Local aTotFisDev	:= {} 
Local aCampos		:= {}
Local aFatDes		:= {} 
Local lB5VerInd		:= .F.   // Indica se o campo B5_VERIND existe, caso exista para ser desonerado devera conter o cfop no parmetro "MV_CFIND"
Local lB5CodAtiv	:= .F. 
Local cIndex2  		:= ""
Local cIndexD1		:= ""
Local lComplD1 		:= .F.
Local nRecAtuSD1	:= 0 
Local lDtIniCG1		:= .F. 
Local lCodAtiVld 	:= .F. 
Local aCG1			:= {} 
Local cTempTab		:= ""
Local cChaveInd		:= ""
Local cArqIdx		:= ""
Local lTmpCG1		:= .F.
Local lAgreg		:= .F. 
Local lFiscal		:= IsIncallStack("SpedPisCof")

Default cPeriodo 	:= ""
Default cPeriodo13	:= ""
Default cFilProc	:= cFilAnt
Default l13Sal		:= .F. 

lB5VerInd := SB5->(FieldPos('B5_VERIND')) > 0
lB5CodAtiv:= SB5->(FieldPos('B5_CODATIV')) > 0
lDtIniCG1 := Iif(AliasInDic("CG1"),CG1->(FieldPos('CG1_DTINI')) > 0,.F.) //Verifica se existe Data inicial do cdigo de atividade contido na tabela CG1

If cPaisLoc == "BRA"
	#IFDEF TOP			
		If SB5->(FieldPos('B5_INSPAT')) > 0 .AND. lB5CodAtiv

			cQuery += " SELECT D2_DOC, D2_SERIE, D2_COD, D2_TIPO, D2_TOTAL, D2_VALIPI, D2_ICMSRET, D2_CF, D2_EMISSAO, D2_NFORI, D2_SERIORI, " 
			cQuery += " D2_VALFRE, D2_SEGURO, D2_DESPESA, D2_VALBRUT, D2_VALICM, B5_CODATIV, B5_INSPAT, B5_VERIND, F4_AGREG " 
			cQuery += " FROM " + RetSqlName( "SD2" ) + " SD2 "
			cQuery += " INNER JOIN " + RetSQLName("SB5") +" SB5 ON "			
			cQuery += " SB5.B5_FILIAL = '" + xFilial("SB5") + "' AND "
			cQuery += " SB5.B5_COD = SD2.D2_COD AND "
			cQuery += " SB5.B5_CODATIV <> ' ' AND "
			cQuery += " SB5.D_E_L_E_T_ = ' ' "
			cQuery += " INNER JOIN " + RetSQLName("SF4") +" SF4 ON "			
			cQuery += " SF4.F4_FILIAL = '" + xFilial("SF4") + "' AND "
			cQuery += " SF4.F4_CODIGO = SD2.D2_TES AND "
			cQuery += " SF4.D_E_L_E_T_ = ' ' "
			cQuery += " WHERE "
			cQuery += " SD2.D2_FILIAL = '" + xFilial("SD2") + "' AND "
			cQuery += " SD2.D2_TIPO IN ('N','C','I','P')  AND "
			cQuery += " SD2.D2_EMISSAO BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
			cQuery += " SD2.D_E_L_E_T_ = ' ' "
			cQuery += " ORDER BY SD2.D2_FILIAL, SD2.D2_COD "
					
			cQuery := ChangeQuery(cQuery)
			dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasQry,.T.,.T.)
		
			//Ŀ
			//Verifico os cdigos de atividade que possuem data de validade maior do que
			//o perodo de processamneto.                                               
			//
			If lDtIniCG1
				cQueryCG1 := " SELECT CG1_FILIAL, CG1_CODIGO, CG1_DTFIM, CG1_DTINI, CG1_ALIQ "
				cQueryCG1 += " FROM " + RetSqlName( "CG1" ) + " "
				cQueryCG1 += " WHERE "
		   		cQueryCG1 += " CG1_FILIAL = '" + xFilial("CG1") + "' "
				cQueryCG1 += " AND CG1_DTFIM >= '" + DTOS(dPerFim) +"' AND CG1_DTINI <= '" + DTOS(dPerIni) + "' "
				cQueryCG1 += " AND CG1_DTINI <> ' ' OR CG1_CODIGO = '99999999'"
				cQueryCG1 += " AND D_E_L_E_T_ = ' ' "
				cQueryCG1 += " ORDER BY CG1_FILIAL, CG1_CODIGO, CG1_DTFIM " 
				
				cQueryCG1 := ChangeQuery(cQueryCG1)
		   		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQueryCG1),cQryCG1,.T.,.T.)

				If !(cQryCG1)->(Eof())
					//Ŀ
					// Cria arquivo de dados temporrio 
					//
					cTempTab  := CriaTrab(Nil,.F.)
					COPY TO &cTempTab
					Iif(Select(cQryCG1)>0,(cQryCG1)->(dbCloseArea()),Nil)
					dbUseArea(.T.,,cTempTab,cQryCG1,.T.,.T.)
					cArqIdx   := cTempTab+OrdBagExt()
					cChaveInd := "CG1_FILIAL+CG1_CODIGO+CG1_DTFIM"
					dbCreateIndex(cArqIdx,cChaveInd,{||&cChaveind},.T.)
					cTempTab  := cTempTab+GetDbExtension()
					(cQryCG1)->(dbSetIndex(cArqIdx))
					lTmpCG1   := .T.
				EndIf

			EndIf

			While !(cAliasQry)->( Eof() )
				lAgreg := .F.
				If Alltrim((cAliasQry)->D2_CF)$ aCFOPs[1] .And. !Alltrim((cAliasQry)->D2_CF)$ aCFOPs[2]
					lAgreg := (cAliasQry)->F4_AGREG=="I"	//Se for ICMS+Mer, subtrai o valor do ICMS do D2_VALBRUT
					If !(Alltrim((cAliasQry)->D2_TIPO)== "I") .Or. (Alltrim((cAliasQry)->D2_TIPO)== "I" .And.(cAliasQry)->D2_ICMSRET > 0)
						nFatBrut+= (cAliasQry)->D2_VALBRUT //Variavel que retornar o valor bruto das notas(considera frete seguro e despesa) 
						nFatLiq +=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA   //Variavel que retornar o valor liquido das notas 
						aAdd(aFatDes,{(cAliasQry)->D2_DOC,(cAliasQry)->D2_SERIE,(cAliasQry)->D2_TIPO,(cAliasQry)->D2_EMISSAO,(cAliasQry)->D2_TOTAL +; 
									(cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, (cAliasQry)->D2_NFORI,(cAliasQry)->D2_SERIORI, (cAliasQry)->D2_CF})
					EndIf 
					//p
					//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
					//|pois se no estiver, no ser validado com cod de atividade. 		  					  
					//Poder existir mais de um cdigo de atividade com datas de validade distintas              
					//p
				   	lCodAtiVld := .F. 
				   	If lDtIniCG1 .And. lTmpCG1
				   		If (cQryCG1)->(dbSeek(xFilial("CG1")+(cAliasQry)->B5_CODATIV))
							While !(cQryCG1)->(Eof()) .And. (cQryCG1)->CG1_CODIGO == (cAliasQry)->B5_CODATIV
								If (cQryCG1)->CG1_DTINI <= (cAliasQry)->D2_EMISSAO .AND. ((cQryCG1)->(CG1_DTFIM) >= (cAliasQry)->D2_EMISSAO .OR. (cAliasQry)->B5_CODATIV == '99999999')
									 lCodAtiVld := .T. 
									 Exit 
						   		EndIf 
								(cQryCG1)->(dbSkip())
							EndDo
						EndIf
					Else
						lDtIniCG1 := .F.
					EndIf
					//Ŀ
					//Tratamento para complemento de ICMS-ST e IPI                                                                                 		
					//Somo o valor do imposto no valor bruto pois  um complemento da NF Original, que na gerao n teve este imposto.	        
					//Somando esse valor no valbrut para calculo da deson, ele considera esse valor apenas como excluso e no como b. de calculo  
					//
		   			If lDtIniCG1
			   			If (Alltrim((cAliasQry)->D2_TIPO)== "I" .And.(cAliasQry)->D2_ICMSRET > 0) .Or. Alltrim((cAliasQry)->D2_TIPO)== "P" .And. lCodAtiVld  
						   	If (cAliasQry)->B5_INSPAT == "1"
						   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
						   		If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							   		If nPosFis == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0})
									Else
										aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
									EndIf
								EndIf	
						   	EndIf                                                                         			   	
						ElseIf !Alltrim((cAliasQry)->D2_TIPO)== "I" .And. lCodAtiVld  
							If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .AND. ((cAliasQry)->B5_INSPAT == "1")
							    If lB5VerInd
								    If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $ cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
										//Ŀ
										//Soma os valores por codigo de atividade no array aTotFis
										//[1] Cdigo de atividade                                 
										//[2] Valor Bruto por cdigo atividade                    
										//[3]Valor Bruto Exportao por cdigo de atividade      
										//[4] Valor liq + frete + seguro + despesa                
										//
										nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
										If nPosFis == 0
											aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0),(cAliasQry)->D2_VALIPI })
										Else
											aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT
											aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
											aTotFis[nPosFis][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
										EndIf
									EndIf
								Else 
									nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
									If nPosFis == 0
										aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0),(cAliasQry)->D2_VALIPI })
									Else
										aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT
										aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
										aTotFis[nPosFis][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
									EndIf
								EndIf	 		
							//Ŀ
							//Verifico a exportaes que possuem codigo de atividade e
							//atribuo a posio 3 do array                            
							//
							ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7"
								nFatExp+= (cAliasQry)->D2_VALBRUT
								nFatLiqExp+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
								If (cAliasQry)->B5_INSPAT == "1"
									If lB5VerInd
										If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
											nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
											If nPosExp == 0
												aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0), (cAliasQry)->D2_VALIPI})
											Else
												aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
												aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
												aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
												aTotFis[nPosExp][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
												aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
											EndIf
										EndIf	
									Else
										nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
										If nPosExp == 0
											aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0), (cAliasQry)->D2_VALIPI})
										Else
											aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
											aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
											aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
											aTotFis[nPosExp][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
											aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
										EndIf
									EndIf	
								EndIf	
							EndIf
						EndIf
					Else
						If (Alltrim((cAliasQry)->D2_TIPO)== "I" .And.(cAliasQry)->D2_ICMSRET > 0) .Or. Alltrim((cAliasQry)->D2_TIPO)== "P"   
							   	If (cAliasQry)->B5_INSPAT == "1"
							   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
							   		If STOD((cAliasQry)->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
								   		If nPosFis == 0
											aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_TOTAL,0,0})
										Else
											aTotFis[nPosFis][2]+=(cAliasQry)->D2_TOTAL 
										EndIf
									EndIf	
							   	EndIf                                                                         			   	
							ElseIf !Alltrim((cAliasQry)->D2_TIPO)== "I"
								If SubStr((cAliasQry)->D2_CF,1,1) <> "7" .AND. (cAliasQry)->B5_INSPAT == "1"
								    If lB5VerInd
									    If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
											//Ŀ
											//Soma os valores por codigo de atividade no array aTotFis
											//[1] Cdigo de atividade                                 
											//[2] Valor Bruto por cdigo atividade                    
											//[3]Valor Bruto Exportao por cdigo de atividade      
											//[4] Valor liq + frete + seguro + despesa                
											//
											nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
											If nPosFis == 0
												aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0),(cAliasQry)->D2_VALIPI })
											Else
												aTotFis[nPosFis][2]+=(cAliasQry)->D2_VALBRUT
												aTotFis[nPosFis][4]+=(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
												aTotFis[nPosFis][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
											EndIf
										EndIf
									Else 
										nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
										If nPosFis == 0
											aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT, 0,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0),(cAliasQry)->D2_VALIPI})
										Else
											aTotFis[nPosFis][2]+= (cAliasQry)->D2_VALBRUT
											aTotFis[nPosFis][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
											aTotFis[nPosFis][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
										EndIf
									EndIf	 		
								//Ŀ
								//Verifico a exportaes que possuem codigo de atividade e
								//atribuo a posio 3 do array                            
								//
								ElseIf SubStr((cAliasQry)->D2_CF,1,1) == "7"
									nFatExp+= (cAliasQry)->D2_VALBRUT
									nFatLiqExp+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
									If (cAliasQry)->B5_INSPAT == "1"
										If lB5VerInd
											If (((cAliasQry)->B5_VERIND == "1" .And. AllTrim((cAliasQry)->D2_CF) $cCFIND) .OR. (cAliasQry)->B5_VERIND <> "1")
												nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
												If nPosExp == 0
													aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0), (cAliasQry)->D2_VALIPI})
												Else
													aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
													aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
													aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
													aTotFis[nPosExp][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
													aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
												EndIf
											EndIf	
										Else
											nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasQry)->B5_CODATIV)})
											If nPosExp == 0
												aAdd(aTotFis,{(cAliasQry)->B5_CODATIV,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_VALBRUT,(cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA, Iif(lAgreg,(cAliasQry)->D2_VALICM,0), (cAliasQry)->D2_VALIPI})
											Else
												aTotFis[nPosExp][2]+= (cAliasQry)->D2_VALBRUT
												aTotFis[nPosExp][3]+= (cAliasQry)->D2_VALBRUT
												aTotFis[nPosExp][4]+= (cAliasQry)->D2_TOTAL + (cAliasQry)->D2_VALFRE + (cAliasQry)->D2_SEGURO + (cAliasQry)->D2_DESPESA
												aTotFis[nPosExp][5]+= Iif(lAgreg,(cAliasQry)->D2_VALICM,0)
												aTotFis[nPosExp][6]+= (cAliasQry)->D2_VALIPI
											EndIf
										EndIf	
									EndIf	
								EndIf
							EndIf
						EndIf	 
					EndIf							 	 
				(cAliasQry)->(dbSkip())	
			EndDo 
			(cAliasQry)->(dbCloseArea())
		EndIf
		
	#ELSE
		//Ŀ
		//Cria o arquivo de trabalho caso o campo B5_INSPAT exista.	
		//Para criao do mesmo aplicar o UPDFAT23						
		//
		If SB5->(FieldPos('B5_INSPAT')) > 0 .AND. lB5CodAtiv
			cIndex2 := CriaTrab(NIL,.F.)
			cKey	:= 'D2_DOC, D2_SERIE, D2_COD '
			cFilter := 'D2_FILIAL == "'+ xFilial("SD2") +'" .And. (Dtos(D2_EMISSAO) >= "'+Dtos(dPerIni)+'" .And. Dtos(D2_EMISSAO) <= "'+Dtos(dPerFim)+'")'
			cFilter += '.And. D2_TIPO $ ("N|C|I|P") '
			
			dbSelectArea("SD2") 	 			 			 
			IndRegua("SD2",cIndex2,cKey,,cFilter,)
			nIndex := RetIndex("SD2")
			 
			dbSetIndex(cIndex2+OrdBagExt())
			dbSetOrder(nIndex+1)                                                    
			dbGotop()
		
			While !SD2->( Eof() )
				lAgreg := .F.
				If Alltrim(SD2->D2_CF)$ aCFOPs[1] .And. !Alltrim(SD2->D2_CF)$ aCFOPs[2]
					lAgreg := Posicione("SF4",1,xFilial("SF4")+SD2->D2_TES,"F4_AGREG")=="I"	//Se for ICMS+Mer, subtrai o valor do ICMS do D2_VALBRUT
					If !(Alltrim(SD2->D2_TIPO)== "I") .Or. (Alltrim(SD2->D2_TIPO)== "I" .And. SD2->D2_ICMSRET > 0)
						nFatBrut+=SD2->D2_VALBRUT
						nFatLiq +=SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO +	SD2->D2_DESPESA
						aAdd(aFatDes,{SD2->D2_DOC,SD2->D2_SERIE,SD2->D2_TIPO,DTOS(SD2->D2_EMISSAO),SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO +; 
										SD2->D2_DESPESA, SD2->D2_NFORI,SD2->D2_SERIORI, SD2->D2_CF})  
					EndIf					
				 	//p
					//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
					//|pois se no estiver, no ser validado com cod de atividade. 		  					  
					//Poder existir mais de um cdigo de atividade com datas de validade distintas              
					//p
					cCodAtiv := Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_CODATIV")
				   	If lDtIniCG1 .And. !Empty(cCodAtiv)
						lCodAtiVld := .F. 
						dbSelectArea("CG1")
						CG1->(dbSetOrder(1))
						If dbSeek(xFilial("CG1")+cCodAtiv)
							While !Eof() .And. CG1->CG1_CODIGO == cCodAtiv 
								aAdd(aCG1,{CG1->CG1_DTINI,CG1->CG1_DTFIM})
								CG1->(dbSkip())
							EndDo
							If Len(aCG1)>0
								aSort(aCG1,,,{|x,y| x[1] > y[1]}) // ultimo cadastro do cdigo de atividade	
								For Nx:= 1 to Len(aCG1)
									If Dtos(aCG1[nX][1]) <= SD2->D2_EMISSAO .And. Dtos(aCG1[nx][2]) >= SD2->D2_EMISSAO 
								    	lCodAtiVld := .T.
								    	Exit
								    EndIf	
								 Next nX
							EndIf	
						EndIf
					EndIf
				 	//Ŀ
					//Tratamento para complemento de ICMS-ST e IPI                                                                                 		
					//Somo o valor do imposto no valor bruto pois  um complemento da NF Original, que na gerao n teve este imposto.	        
					//Somando esse valor no valbrut para calculo da deson, ele considera esse valor apenas como excluso e no como b. de calculo  
					//
					If lDtIniCG1
						If (Alltrim(SD2->D2_TIPO)== "I" .And. SD2->D2_ICMSRET > 0) .Or. Alltrim(SD2->D2_TIPO)== "P" .And. lCodAtiVld 
							If !Empty(cCodAtiv) .AND. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1"
						   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
						   		If STOD(SD2->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							   		If nPosFis == 0
										aAdd(aTotFis,{cCodAtiv,SD2->D2_TOTAL,0,0})
									Else
										aTotFis[nPosFis][2]+=SD2->D2_TOTAL 
									EndIf
								EndIf	
							EndIf	   
						ElseIf !(Alltrim(SD2->D2_TIPO)== "I") .And. lCodAtiVld 
							If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1")
								//Ŀ
								//Soma os valores por codigo de atividade no array aTotFis
								//[1] Cdigo de atividade                                 
								//[2] Valor Bruto por cdigo atividade                    
								//[3] Valor Bruto Exportao por cdigo de atividade      
								//[4] Valor liq + frete + seguro + despesa                
								//  
								If lB5VerInd
									If ((Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") <> "1")
										If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, 0 ,SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0)})
											Else
												aTotFis[nPosFis][2]+= SD2->D2_VALBRUT
												aTotFis[nPosFis][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
												aTotFis[nPosFis][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
											EndIf
										EndIf
									EndIf
								Else
									If !Empty(cCodAtiv)	
										nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
										If nPosFis == 0
											aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, 0 ,SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0)})
										Else
											aTotFis[nPosFis][2]+= SD2->D2_VALBRUT
											aTotFis[nPosFis][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
											aTotFis[nPosFis][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
										EndIf
									EndIf
								EndIf		
							//Ŀ
							//Verifico a exportaes que possuem codigo de atividade e
							//atribuo a posio 3 do array                            
							//
							ElseIf SubStr(SD2->D2_CF,1,1) == "7"
								nFatExp+= SD2->D2_VALBRUT // Total geral de exportao
								nFatLiqExp+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
								If(Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1") 
									If lB5VerInd
										If ((Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") <> "1")
											If !Empty(cCodAtiv)	
												nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
												If nPosExp == 0
													aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT,SD2->D2_VALBRUT, SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0), SD2->D2_VALIPI})
												Else
													aTotFis[nPosExp][2]+= SD2->D2_VALBRUT
													aTotFis[nPosExp][3]+= SD2->D2_VALBRUT
													aTotFis[nPosExp][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
													aTotFis[nPosExp][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
													aTotFis[nPosExp][6]+= SD2->D2_VALIPI
												EndIf
											EndIf
										EndIf
									Else
										If !Empty(cCodAtiv)	
											nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosExp == 0
												aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, SD2->D2_VALBRUT, SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0), SD2->D2_VALIPI})
											Else
												aTotFis[nPosExp][2]+= SD2->D2_VALBRUT
												aTotFis[nPosExp][3]+= SD2->D2_VALBRUT
												aTotFis[nPosExp][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
												aTotFis[nPosExp][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
												aTotFis[nPosExp][6]+= SD2->D2_VALIPI
											EndIf
										EndIf
									EndIf		
								EndIf					
							EndIf    
						EndIf
					Else
						If (Alltrim(SD2->D2_TIPO)== "I" .And. SD2->D2_ICMSRET > 0) .Or. Alltrim(SD2->D2_TIPO)== "P"
							If !Empty(cCodAtiv) .AND. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1"
						   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
						   		If STOD(SD2->D2_EMISSAO) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							   		If nPosFis == 0
										aAdd(aTotFis,{cCodAtiv,SD2->D2_TOTAL,0,0})
									Else
										aTotFis[nPosFis][2]+=SD2->D2_TOTAL 
									EndIf
								EndIf	
						   	EndIf	   
						ElseIf !(Alltrim(SD2->D2_TIPO)== "I")
							If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1")
								//Ŀ
								//Soma os valores por codigo de atividade no array aTotFis
								//[1] Cdigo de atividade                                 
								//[2] Valor Bruto por cdigo atividade                    
								//[3] Valor Bruto Exportao por cdigo de atividade      
								//[4] Valor liq + frete + seguro + despesa                
								//  
								If lB5VerInd
									If ((Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") <> "1")
										If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, 0 ,SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0)})
											Else
												aTotFis[nPosFis][2]+= SD2->D2_VALBRUT
												aTotFis[nPosFis][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
												aTotFis[nPosFis][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
											EndIf
										EndIf
									EndIf
								Else
									If !Empty(cCodAtiv)	
										nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
										If nPosFis == 0
											aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, 0 ,SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0)})
										Else
											aTotFis[nPosFis][2]+= SD2->D2_VALBRUT
											aTotFis[nPosFis][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
											aTotFis[nPosFis][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
										EndIf
									EndIf
								EndIf		
							//Ŀ
							//Verifico a exportaes que possuem codigo de atividade e
							//atribuo a posio 3 do array                            
							//
							ElseIf SubStr(SD2->D2_CF,1,1) == "7"
								nFatExp+= SD2->D2_VALBRUT // Total geral de exportao
								nFatLiqExp+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
								If(Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_INSPAT") == "1") 
									If lB5VerInd
										If ((Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD2->D2_COD,"B5_VERIND") <> "1")						 	
											If !Empty(cCodAtiv)	
												nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
												If nPosExp == 0
													aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, SD2->D2_VALBRUT, SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0), SD2->D2_VALIPI})
												Else
													aTotFis[nPosExp][2]+= SD2->D2_VALBRUT
													aTotFis[nPosExp][3]+= SD2->D2_VALBRUT
													aTotFis[nPosExp][4]+= SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
													aTotFis[nPosExp][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
													aTotFis[nPosExp][6]+= SD2->D2_VALIPI
												EndIf
											EndIf
										EndIf
									Else
										If !Empty(cCodAtiv)	
											nPosExp := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosExp == 0
												aAdd(aTotFis,{cCodAtiv,SD2->D2_VALBRUT, SD2->D2_VALBRUT, SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA, Iif(lAgreg,SD2->D2_VALICM,0), SD2->D2_VALIPI})
											Else
												aTotFis[nPosExp][2]+= SD2->D2_VALBRUT
												aTotFis[nPosExp][3]+= SD2->D2_VALBRUT
												aTotFis[nPosExp][4]+=SD2->D2_TOTAL + SD2->D2_VALFRE + SD2->D2_SEGURO + SD2->D2_DESPESA
												aTotFis[nPosExp][5]+= Iif(lAgreg,SD2->D2_VALICM,0)
												aTotFis[nPosExp][6]+= SD2->D2_VALIPI
											EndIf
										EndIf
									EndIf		
								EndIf					
							EndIf
						EndIf	    
					EndIf	
				EndIf		
				SD2->(dbSkip())
			EndDo
			Ferase(cIndex2+OrdBagExt())	// Exclui o arquivo de trabalho
		EndIf
		dbSelectArea("SD2")
		RetIndex("SD2")
		dbClearFilter()
		
	#ENDIF
   
//Ŀ
//Processamento das notas de devoluo
//
   
	#IFDEF TOP			
		If SB5->(FieldPos('B5_INSPAT')) > 0 .AND. lB5CodAtiv
			cQueryD1 := " SELECT D1_DOC, D1_SERIE, D1_COD, D1_TIPO, D1_TOTAL, D1_VALDESC, D1_CF, D1_EMISSAO,D1_DTDIGIT, D1_NFORI, D1_SERIORI, D1_FORNECE, D1_LOJA, D1_ITEMORI, "
			cQueryD1 += " D1_VALDESC, D1_VALFRE, D1_SEGURO, D1_DESPESA, D1_VALIPI, D1_ICMSRET, B5_CODATIV, B5_INSPAT, B5_VERIND " 
			cQueryD1 += " FROM " + RetSqlName( "SD1" ) + " SD1 "
			cQueryD1 += " INNER JOIN " + RetSQLName("SB5") +" SB5 ON "			
			cQueryD1 += " SB5.B5_FILIAL = '" + xFilial("SB5") + "' AND "
			cQueryD1 += " SB5.B5_COD = SD1.D1_COD AND "
			cQueryD1 += " SB5.B5_CODATIV <> ' ' AND "
			cQueryD1 += " SB5.D_E_L_E_T_ = ' ' "
			cQueryD1 += " WHERE "
			cQueryD1 += " SD1.D1_FILIAL = '"  + xFilial("SD1") + "' AND "
			cQueryD1 += " SD1.D1_TIPO IN ('D','C','I','P') AND "
		    cQueryD1 += " SD1.D1_DTDIGIT BETWEEN '"+DTOS(dPerIni)+"' AND '"+DTOS(dPerFim)+"' AND " 
			cQueryD1 += " SD1.D_E_L_E_T_ = ' ' "
			cQueryD1 += " ORDER BY SD1.D1_FILIAL, SD1.D1_COD, SD1.D1_DOC, SD1.D1_SERIE "	
			
			cQueryD1 := ChangeQuery( cQueryD1 )
			dbUseArea( .T., "TOPCONN", TcGenQry( ,,cQueryD1 ), cAliasSD1, .F., .T. )		
		
			While !(cAliasSD1)->(Eof())
				lComplD1 := .F.
				If !(cAliasSD1)->D1_TIPO $ "D|N"
					cNFOrig  := Posicione("SD1",1,xFilial("SD1")+ (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI,"D1_NFORI")
					cSerOrig := Posicione("SD1",1,xFilial("SD1")+ (cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI,"D1_SERIORI")
					lComplD1 := .T.
				EndIf	  
				SD2->(dbSetOrder(3))
				If Iif(!lComplD1, SD2->(dbSeek(xFilial("SD2")+(cAliasSD1)->D1_NFORI + (cAliasSD1)->D1_SERIORI+ (cAliasSD1)->D1_FORNECE + (cAliasSD1)->D1_LOJA + (cAliasSD1)->D1_COD + (cAliasSD1)->D1_ITEMORI)),;
					SD2->(dbSeek(xFilial("SD2")+cNFOrig+cSerOrig)))
					If (Alltrim(SD2->D2_CF)$ aCFOPs[1] .And. !Alltrim(SD2->D2_CF)$ aCFOPs[2]) .And. SD2->D2_EMISSAO >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
					   	// Tratamento para no considerar ICMS normal Considera somente ICMS-ST
					    If !(Alltrim((cAliasSD1)->D1_TIPO)== "I") .Or. (Alltrim((cAliasSD1)->D1_TIPO)== "I" .And. (cAliasSD1)->D1_ICMSRET > 0)
							//L
							//Se for ICMS ST no somo o D1_ICMSRET, o valor ja esta no D1_TOTAL
							//L
						    If (Alltrim((cAliasSD1)->D1_TIPO)== "I" .And. (cAliasSD1)->D1_ICMSRET > 0)
						    	nTotDev	+= ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA +; 
						    				(cAliasSD1)->D1_VALIPI 
						    	nTotLiqDev += ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA - (cAliasSD1)->D1_ICMSRET  
						    	aAdd(aFatDes,{(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_TIPO,(cAliasSD1)->D1_DTDIGIT,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,;
							  			(cAliasSD1)->D1_NFORI,(cAliasSD1)->D1_SERIORI, (cAliasSD1)->D1_CF})
						    Else
						    	nTotDev	+= ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA +; 
						    				(cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devoluo (considera frete seguro e despesa)
							    nTotLiqDev += ((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA
						    	aAdd(aFatDes,{(cAliasSD1)->D1_DOC,(cAliasSD1)->D1_SERIE,(cAliasSD1)->D1_TIPO,(cAliasSD1)->D1_DTDIGIT,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC) + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA,;
						  					(cAliasSD1)->D1_NFORI,(cAliasSD1)->D1_SERIORI, (cAliasSD1)->D1_CF})			  
						    EndIf			
						EndIf
						//p
						//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
						//|pois se no estiver, no ser validado com cod de atividade. 		  					  
						//Poder existir mais de um cdigo de atividade com datas de validade distintas              
						//p
					  	lCodAtiVld := .F.
					   	If lDtIniCG1 .And. lDtIniCG1
					   		If (cQryCG1)->(dbSeek(xFilial("CG1")+(cAliasSD1)->B5_CODATIV))
								While !(cQryCG1)->(Eof()) .And. (cQryCG1)->CG1_CODIGO == (cAliasSD1)->B5_CODATIV
									If (cQryCG1)->CG1_DTINI <= (cAliasSD1)->D1_DTDIGIT .AND. (cQryCG1)->(CG1_DTFIM) >= (cAliasSD1)->D1_DTDIGIT
										 lCodAtiVld := .T. 
										 Exit 
							   		EndIf 
									(cQryCG1)->(dbSkip())
								EndDo
							EndIf
                        Else
                        	lDtIniCG1 := .F.
						EndIf
	  				 	//d
						//Se for complemento de ICMS ST ou complemento de IPI na devoluo, adiciono o valor somente no valor bruto do ATOTFIS, 
						// pois como impostos nao vo para desonerao, subtraio apenas no valor bruto do cod de atividade.			       	 
						//d
						If lDtIniCG1
							If (Alltrim((cAliasSD1)->D1_TIPO)== "I" .And.(cAliasSD1)->D1_ICMSRET > 0) .Or. Alltrim((cAliasSD1)->D1_TIPO)== "P" .And. lCodAtiVld
							   If (cAliasSD1)->B5_INSPAT == "1"
							   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
								   		If nPosFis == 0
											aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0})
										Else
											aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL 
										EndIf
									EndIf	
							  	EndIf
							ElseIf !Alltrim((cAliasSD1)->D1_TIPO)== "I" .And. lCodAtiVld
								If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (cAliasSD1)->B5_INSPAT == "1"					
							 	//Ŀ
								//Soma os valores por codigo de atividade no array aTotFisDev 
								//[1] Cdigo de atividade                                 	   
								//[2] Valor Bruto devoluo por cdigo atividade              
								//[3] Valor Bruto devoluo de Exportao por cd de atividade
								//[4] Valor devoluo liq + frete + seguro + despesa     	   
								// 
									If lB5VerInd
										If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
											If nPosFis == 0
												aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																			(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																			(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA})
											Else
												aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
												aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
											EndIf
										EndIf
									Else 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
										If nPosFis == 0
											aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																		(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																		(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA})
										Else
											aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
											aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
										EndIf
									EndIf
								//Ŀ
								//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
								//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
								//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
								//
								ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
									If (cAliasSD1)->B5_INSPAT == "1" 
										If lB5VerInd 
											If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
												nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
												If nPosFis == 0
													aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
													 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
													 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				0})									
												Else
													aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
													aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
																		
												EndIf
											EndIf 
										Else
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
											If nPosFis == 0
												aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
												 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
												 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
												 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),0})
												 			   
											Else
												aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
												aTotFisDev[nPosFis][3]+=(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET
																	
											EndIf
										EndIf			
									EndIf
								EndIf  
							EndIf
						Else
							If (Alltrim((cAliasSD1)->D1_TIPO)== "I" .And.(cAliasSD1)->D1_ICMSRET > 0) .Or. Alltrim((cAliasSD1)->D1_TIPO)== "P" 
							   If (cAliasSD1)->B5_INSPAT == "1"
							   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
							   		If STOD((cAliasSD1)->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
								   		If nPosFis == 0
											aAdd(aTotFis,{(cAliasSD1)->B5_CODATIV,-(cAliasSD1)->D1_TOTAL,0,0})
										Else
											aTotFis[nPosFis][2]-=(cAliasSD1)->D1_TOTAL 
										EndIf
									EndIf	
							  	EndIf
							ElseIf !Alltrim((cAliasSD1)->D1_TIPO)== "I" 
								If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (cAliasSD1)->B5_INSPAT == "1"					
							 	//Ŀ
								//Soma os valores por codigo de atividade no array aTotFisDev 
								//[1] Cdigo de atividade                                 	   
								//[2] Valor Bruto devoluo por cdigo atividade              
								//[3] Valor Bruto devoluo de Exportao por cd de atividade
								//[4] Valor devoluo liq + frete + seguro + despesa     	   
								// 
									If lB5VerInd
										If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
											If nPosFis == 0
												aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																			(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																			(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA})
											Else
												aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
												aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
											EndIf
									  	EndIf
									Else 
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
										If nPosFis == 0
											aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA+ (cAliasSD1)->D1_VALIPI +; 
																		(cAliasSD1)->D1_ICMSRET),0,(cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC +; 
																		(cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA})
										Else
											aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
											aTotFisDev[nPosFis][4]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA)						 
										EndIf
									EndIf
								//Ŀ
								//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
								//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
								//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
								//
								ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
									If (cAliasSD1)->B5_INSPAT == "1" 
										If lB5VerInd 
											If (((cAliasSD1)->B5_VERIND == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. (cAliasSD1)->B5_VERIND <> "1")						 	
												nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
												If nPosFis == 0
													
													aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
													 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
													 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				0})
												Else
													aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
													aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																			(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
																		
												EndIf
											EndIf 
										Else
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim((cAliasSD1)->B5_CODATIV)})
											If nPosFis == 0
												aAdd(aTotFisDev,{(cAliasSD1)->B5_CODATIV,((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +;
													 				(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE + (cAliasSD1)->D1_SEGURO +; 
													 				(cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET),;
													 				0})
											Else
												aTotFisDev[nPosFis][2]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)
												aTotFisDev[nPosFis][3]+=((cAliasSD1)->D1_TOTAL - (cAliasSD1)->D1_VALDESC + (cAliasSD1)->D1_VALFRE +; 
																		(cAliasSD1)->D1_SEGURO + (cAliasSD1)->D1_DESPESA + (cAliasSD1)->D1_VALIPI + (cAliasSD1)->D1_ICMSRET)						
											  					
											EndIf
										EndIf
									EndIf
								EndIf  
							EndIf	
						EndIf		
					EndIf		
				EndIf					
		        (cAliasSD1)->(dbSkip())
			EndDo
			(cAliasSD1)->(dbCloseArea())
		EndIf

		If Select(cQryCG1) > 0
			(cQryCG1)->(dbClearIndex())
			(cQryCG1)->(dbCloseArea())
			Ferase(cTempTab)
			Ferase(cArqIdx)
		EndIf  

		RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)   
	#ELSE

	If SB5->(FieldPos('B5_INSPAT')) > 0 .AND. lB5CodAtiv
		cIndexD1  := CriaTrab(NIL,.F.)
		cKeyD1    := 'D1_DOC, D1_SERIE, D1_COD, D1_NFORI, D1_SERIORI, D1_FORNECE, D1_LOJA, D1_ITEMORI  '
		cFilterD1 := 'D1_FILIAL == "'+ xFilial("SD1") +'" .And. (Dtos(D1_DTDIGIT) >= "'+Dtos(dPerIni)+'" .And. Dtos(D1_DTDIGIT) <= "'+Dtos(dPerFim)+'")'
		cFilterD1 += '.And. D1_TIPO  $ ("D|C|I|P") '
		
		dbSelectArea("SD1") 	 			 			 
		IndRegua("SD1",cIndexD1,cKeyD1,,cFilterD1,)
		nIndexD1 := RetIndex("SD1")
		dbSetIndex(cIndexD1+OrdBagExt())
		dbSetOrder(nIndexD1+1)
		dbGotop()

		While !SD1->( EOF() )
			lComplD1 := .F.
			If !SD1->D1_TIPO $ "D|N"
				nRecAtuSD1 := SD1->(RECNO())
				cNFOrig  := Posicione("SD1",1,xFilial("SD1")+ SD1->D1_NFORI + SD1->D1_SERIORI,"D1_NFORI")
				cSerOrig := Posicione("SD1",1,xFilial("SD1")+ SD1->D1_NFORI + SD1->D1_SERIORI,"D1_SERIORI")
				lComplD1 := .T.
			EndIf	  
			SD2->(dbSetOrder(3))
			If Iif(!lComplD1, SD2->(dbSeek(xFilial("SD2")+SD1->D1_NFORI + SD1->D1_SERIORI + SD1->D1_FORNECE + SD1->D1_LOJA + SD1->D1_COD + SD1->D1_ITEMORI)),;
					SD2->(dbSeek(xFilial("SD2")+cNFOrig+cSerOrig)))
				If (Alltrim(SD2->D2_CF)$ aCFOPs[1] .And. !Alltrim(SD2->D2_CF)$ aCFOPs[2]) .And. SD2->D2_EMISSAO >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4)) 
					If !(Alltrim(SD1->D1_TIPO)== "I") .Or. (Alltrim(SD1->D1_TIPO)== "I" .And. SD1->D1_ICMSRET > 0)
						//L
						//Se for ICMS ST no somo o D1_ICMSRET, o valor ja esta no D1_TOTAL
						//L
						If (Alltrim(SD1->D1_TIPO)== "I" .And. SD1->D1_ICMSRET > 0)
							nTotDev	+= (SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA +; 
										SD1->D1_VALIPI)	//variavel que ira acumular o valo total de Notas de devoluo 	
							nTotLiqDev += SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA - SD1->D1_ICMSRET  //variavel que ira acumular o valo total Liq de Notas de devoluo utilizado para gerar base de calculo tipo 2 RH
							aAdd(aFatDes,{SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_TIPO,DTOS(SD1->D1_DTDIGIT),(SD1->D1_TOTAL - SD1->D1_VALDESC) +SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA,;
						  				SD1->D1_NFORI,SD1->D1_SERIORI,SD1->D1_CF})
						Else
							nTotDev	+= (SD1->D1_TOTAL - SD1->D1_VALDESC) + SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA +; 
						    				SD1->D1_VALIPI + SD1->D1_ICMSRET //variavel que ira acumular o valo total de Notas de devoluo (considera frete seguro e despesa)
						    nTotLiqDev += SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA //variavel que ira acumular o valo total Liq de Notas de devoluo utilizado para gerar base de calculo tipo 2 RH
						    aAdd(aFatDes,{SD1->D1_DOC, SD1->D1_SERIE, SD1->D1_TIPO,DTOS(SD1->D1_DTDIGIT),(SD1->D1_TOTAL - SD1->D1_VALDESC) +SD1->D1_VALFRE + SD1->D1_SEGURO + SD1->D1_DESPESA,;
						  				SD1->D1_NFORI,SD1->D1_SERIORI,SD1->D1_CF})
		  
					    EndIf			 	 
					EndIf
					//p
					//Verifico se a data da emisso do item, est entre algum cdigo de atividade valido,        |
					//|pois se no estiver, no ser validado com cod de atividade. 		  					  
					//Poder existir mais de um cdigo de atividade com datas de validade distintas              
					//p
					cCodAtiv := Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_CODATIV")
				  	If lDtIniCG1 .And. !Empty(cCodAtiv)
				  		lCodAtiVld := .F.
						dbSelectArea("CG1")
						CG1->(dbSetOrder(1))
						If dbSeek(xFilial("CG1")+cCodAtiv)
							While !Eof() .And. CG1->CG1_CODIGO == cCodAtiv 
								aAdd(aCG1,{CG1->CG1_DTINI,CG1->CG1_DTFIM})
								CG1->(dbSkip())
							EndDo
							If Len(aCG1)>0
								aSort(aCG1,,,{|x,y| x[1] > y[1]}) // ultimo cadastro do cdigo de atividade	
								For Nx:= 1 to Len(aCG1)
									If !Empty(aCG1[nX][1]) .And. Dtos(aCG1[nX][1]) <= SD1->D1_DTDIGIT .And. Dtos(aCG1[nx][2]) >= SD1->D1_DTDIGIT 
								    	lCodAtiVld := .T.
								    	Exit
								    EndIf	
								Next nX
							EndIf	
						EndIf
					EndIf
					//d
					//Se for complemento de ICMS ST ou complemento de IPI na devoluo, adiciono o valor somente no valor bruto do ATOTFIS, 
					// pois como impostos nao vo para desonerao, subtraio apenas no valor bruto do cod de atividade.			       	 
					//d
					If lDtIniCG1 
						If (Alltrim(SD1->D1_TIPO)== "I" .And. SD1->D1_ICMSRET > 0) .Or. Alltrim(SD1->D1_TIPO)== "P" .And. lCodAtiVld
							If !Empty(cCodAtiv) .AND. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1"
						   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
						   		If STOD(SD1->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							   		If nPosFis == 0
										aAdd(aTotFis,{cCodAtiv,-SD1->D1_TOTAL,0,0})
									Else
										aTotFis[nPosFis][2]-=SD1->D1_TOTAL 
									EndIf
								EndIf	
						   EndIf 
						ElseIf !Alltrim(SD1->D1_TIPO)== "I" .And. lCodAtiVld
							If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1")
								If lB5VerInd 
									If ((Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") <> "1")						 							
										If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFisDev,{cCodAtiv,(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET),0,;
																			(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA)})
											Else
												aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET)
												aTotFisDev[nPosFis][4]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA)
											EndIf
										EndIf
									EndIf
								Else
									If !Empty(cCodAtiv)	
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
										If nPosFis == 0
											aAdd(aTotFisDev,{cCodAtiv,(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET),0,;
																		(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA)})
										Else
											aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET)
											aTotFisDev[nPosFis][4]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA)
										EndIf
									EndIf		
								EndIf	
							//Ŀ
							//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
							//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
							//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
							//
							ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
								If(Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1") 
									If lB5VerInd
										If ((Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") <> "1")						 	
											If !Empty(cCodAtiv)	
												nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
												If nPosFis == 0
													aAdd(aTotFisDev,{cCodAtiv, SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA+ SD1->D1_VALIPI + SD1->D1_ICMSRET,; 
																SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET,;
																SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO + SD1->D1_DESPESA})
												Else
													aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA)
													aTotFisDev[nPosFis][3]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA)
												   
												EndIf
											EndIf
										EndIf	
									Else
										If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFisDev,{cCodAtiv, SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA+ SD1->D1_VALIPI + SD1->D1_ICMSRET,; 
															SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
															SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET,;
															SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO + SD1->D1_DESPESA})
											Else
												aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA)
												aTotFisDev[nPosFis][3]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA)
											
											EndIf
										EndIf
									EndIf		
								EndIf
							EndIf 
						EndIf
					Else	
						If (Alltrim(SD1->D1_TIPO)== "I" .And. SD1->D1_ICMSRET > 0) .Or. Alltrim(SD1->D1_TIPO)== "P" 
						   If !Empty(cCodAtiv) .AND. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1"
						   		nPosFis := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
						   		If STOD(SD1->D1_DTDIGIT) >= CTOD("01"+"/"+SUBSTR(cIniDes,5,6)+"/"+SUBSTR(cIniDes,1,4))
							   		If nPosFis == 0
										aAdd(aTotFis,{cCodAtiv,-SD1->D1_TOTAL,0,0})
									Else
										aTotFis[nPosFis][2]-=SD1->D1_TOTAL 
									EndIf
								EndIf	
						   EndIf 
						ElseIf !Alltrim(SD1->D1_TIPO)== "I" 
							If SubStr(SD2->D2_CF,1,1) <> "7" .AND. (Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1")
								If lB5VerInd 
									If ((Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") <> "1")						 							
								  		If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFisDev,{cCodAtiv,(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET),0,;
																			(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA)})
											Else
												aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET)
												aTotFisDev[nPosFis][4]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																			SD1->D1_DESPESA)
											EndIf
										EndIf
									EndIf
								Else
									If !Empty(cCodAtiv)	
										nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
										If nPosFis == 0
											aAdd(aTotFisDev,{cCodAtiv,(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET),0,;
																		(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA)})
										Else
											aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +	SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET)
											aTotFisDev[nPosFis][4]+=(SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																		SD1->D1_DESPESA)
										EndIf
									EndIf		
								EndIf	
							//Ŀ
							//Verifico as devolues de exportaes que possuem codigo de atividade e 	  
							//atribuo a posio 3 do array aTotFisDev. Tambm ser tratado itens de      |
							//| export por cod de ativ na posio 2 do aTotFisDev(Soma tot por cod ativ)  
							//
							ElseIf SubStr(SD2->D2_CF,1,1) == "7" 
								If(Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_INSPAT") == "1") 
									If lB5VerInd
										If ((Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") == "1" .And. AllTrim(SD2->D2_CF) $cCFIND) .OR. Posicione("SB5",1,xFilial("SB5")+SD1->D1_COD,"B5_VERIND") <> "1")						 	
											If !Empty(cCodAtiv)	
												nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
												If nPosFis == 0
													aAdd(aTotFisDev,{cCodAtiv, SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA+ SD1->D1_VALIPI + SD1->D1_ICMSRET,; 
																SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
																SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET, 0})
												Else
													aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA)
													aTotFisDev[nPosFis][3]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
																SD1->D1_SEGURO + SD1->D1_DESPESA)
													
												EndIf
											EndIf
										EndIf	
									Else
										If !Empty(cCodAtiv)	
											nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(cCodAtiv)})
											If nPosFis == 0
												aAdd(aTotFisDev,{cCodAtiv, SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA+ SD1->D1_VALIPI + SD1->D1_ICMSRET,; 
															SD1->D1_TOTAL - SD1->D1_VALDESC + SD1->D1_VALFRE + SD1->D1_SEGURO +; 
															SD1->D1_DESPESA + SD1->D1_VALIPI + SD1->D1_ICMSRET,0})
											Else
												aTotFisDev[nPosFis][2]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA)
												aTotFisDev[nPosFis][3]+=(SD1->D1_TOTAL - SD1->D1_VALDESC+ SD1->D1_VALFRE +; 
															SD1->D1_SEGURO + SD1->D1_DESPESA)
											
											EndIf
										EndIf
									EndIf		
								EndIf
							EndIf 
						EndIf
					EndIf	
				EndIf		
			EndIf	
			If lComplD1
	        	dbGoTo(nRecAtuSD1)
	      	EndIf    			
	     	SD1->(dbSkip())
		EndDo      
		FErase(cIndexD1+OrdBagExt())
	EndIf          
	RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)        
	dbSelectArea("SD1") 
	RetIndex("SD1")
	
	#ENDIF
	//Ŀ
	//A estrutura da tabela temporria foi criada de acordo com Registro P100 (Contribuio Previdenciria sobre a Receita Bruta) 
	//-
	//Ŀ
	//Cria a estrutura do arquivo de trabalho 
	//
	aAdd(aCampos,{"TOTALLIQ"	,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL LIQUIDO
	aAdd(aCampos,{"TOTAL"		,"N",TAMSX3("D2_TOTAL")[1],2})		// TOTAL BRUTO
	aAdd(aCampos,{"TOTLIQDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUO
	aAdd(aCampos,{"TOTALDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL DEVOLUO
	aAdd(aCampos,{"TOTLIQEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAO
	aAdd(aCampos,{"TOTALEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})	    // TOTAL EXPORTAO
	aAdd(aCampos,{"CODATV"	,"C",If(lB5CodAtiv,(TAMSX3("B5_CODATIV")[1]),8)}) // CODIGO ATIVIDADE
	aAdd(aCampos,{"TOTCODAT"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE BRUTO
   	aAdd(aCampos,{"TCODATLQ"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL CODIGO ATIVIDADE LIQUIDO
	aAdd(aCampos,{"TCATVDEV"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DEV CODIGO ATIVIDADE
	aAdd(aCampos,{"TCATVEXP" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TCATVDVEX" 	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL DE DEVOLUES DE EXPORTAES POR CODIGO DE ATIVIDADE
	aAdd(aCampos,{"TCDEVEXP"	,"N",TAMSX3("D2_TOTAL")[1],2})     // TOTAL COD ATIV - DEVOLUO - EXPRTAO
	
	//Ŀ
	//Cria o arquivo de trabalho
	//	
	cTrab := CriaTrab(aCampos)
	cIndTemp1:=Substr(cTrab,1,7)+"1"
	dbUseArea(.T.,,cTrab,"TRBFAT",.F.,.F.)
	IndRegua("TRBFAT",cIndTemp1,"CODATV")
	DbSetIndex(cIndTemp1+OrdBagExt())
	TRBFAT->(dbGoTop())
	
	If Len(aTotFis)== 0	.And. Len(aTotFisDev)== 0	 
		If (nFatBrut + nTotDev + nFatExp) > 0
			RecLock("TRBFAT", .T.)	
			TRBFAT->TOTALLIQ	:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL		:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes 
		    TRBFAT->(MsUnlock())
		EndIf    
    ElseIf Len(aTotFis)> 0	
		For nx:= 1 to Len(aTotFis)
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ	:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL		:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes 
			// Totais por cdigo de atividade
			TRBFAT->CODATV		:= aTotFis[nx][1] 		// Cdigo de atividade
			TRBFAT->TOTCODAT	:= aTotFis[nx][2] 		// Valor total BRUTO do cdigo de atividade
			TRBFAT->TCODATLQ	:= aTotFis[nx][4] 		// Valor total LIQ do cdigo de atividade
			// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
			nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1])})
			If nPosFis > 0
				TRBFAT->TCATVDEV:= aTotFisDev[nPosFis][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
		    Else
		        TRBFAT->TCATVDEV:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFis[nx][3] // Total Exportao por Cdigo de atividade(Saida) 
		    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
		    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFis[nx][1])})
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
		    Else 
			   TRBFAT->TCATVDVEX	:= 0
		    EndIf
		    //aTotFis[nX][5] - ICMS - Soma os valores do ICMS ao valor lquido, pois se a TES estiver configurada F4_AGREG=I o valor do ICMS  asomado ao valor bruto.
		    //aTotFis[nX][6] - IPI das Exportacoes - deduzir dos impostos pois o campo TCATVEXP ja tem IPI.
		    //Tratamento p/ nao deduzir 2 vezes o valor do IPI nas exportacoes. 
		    nImpostos := (TRBFAT->TOTCODAT - (TRBFAT->TCODATLQ + aTotFis[nX][5] + IIf(Len(aTotFis[nX])==6,aTotFis[nX][6],0)))
			If lFiscal
				TRBFAT->TCDEVEXP := (TRBFAT->TOTCODAT - (TRBFAT->TCATVDEV + TRBFAT->TCATVEXP + TRBFAT->TCATVDVEX + nImpostos))// Total por Cdigo de atividade - devoluo - exportao
			Else
				TRBFAT->TCDEVEXP := (TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVDVEX - nImpostos)// Total por Cdigo de atividade - devoluo - exportao			
			EndIf	
			TRBFAT->(MsUnlock())
		Next(nX)
		//Ŀ
		//Verifico se houve alguma devoluo que no foi processada no array atotfis(sada)
		//Este caso acontee se existe apenas devoluo com cod de atividade para o perodo
		//pois a NF original j foi processada em ms anterior.                            
		//
		If Len(aTotFisDev)> 0	
			For nX:= 1 to Len(aTotFisDev)
				nPosFisDev := aScan(aTotFis,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})	 
				// Se o codigo de atividade no foi encontrado no atotfis e possui no atotfisdev
				// Inclui uma linha com a devoluo com cod atividade
				If nPosFisDev == 0
					nImpostos := 0
					RecLock("TRBFAT", .T.)
					TRBFAT->TOTALLIQ	:= nFatLiq    			// valor total Liquido geral das notas
					TRBFAT->TOTAL		:= nFatBrut    			// valor total BRUTO geral das notas
					
				    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
				    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues
		
				    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
				    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes 
					// Totais por cdigo de atividade
					TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Cdigo de atividade
					TRBFAT->TOTCODAT	:= 0					// Valor total do cdigo de atividade
					TRBFAT->TCODATLQ	:= 0				 	// Valor total LIQ do cdigo de atividade
					// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
					nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
						TRBFAT->TCATVDEV:= aTotFisDev[nPosDev][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
				    Else
				        TRBFAT->TCATVDEV:= 0
				    EndIf
				    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportao por Cdigo de atividade(Saida) 
				    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
				    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
					If nPosDev > 0
				    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
				    Else 
					   TRBFAT->TCATVDVEX	:= 0
				    EndIf
				    nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ
				    
			    	// Tratamento efetuado para no retornar valor negativo, pois a base de clculo nunca poder ser negativa (S033)
				    If lFiscal
						nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP + TRBFAT->TCATVDVEX - nImpostos  // Total por Cdigo de atividade - devoluo - exportao 
					Else
						nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVDVEX - nImpostos  // Total por Cdigo de atividade - devoluo - exportao - dev exportao - impostos
					EndIf	
				 
				    If nTot > 0
				    	TRBFAT->TCDEVEXP := nTot
				    Else 
				    	TRBFAT->TCDEVEXP := 0
				    EndIf		   		
					TRBFAT->(MsUnlock()) 

		    	EndIf
			Next nX
		EndIf	
	ElseIf Len(aTotFisDev)> 0 
	//Ŀ
	//Tratamento para caso haja apenas devoluo no periodo.
	//
		For nx:= 1 to Len(aTotFisDev) 
			nImpostos := 0
			RecLock("TRBFAT", .T.)
			TRBFAT->TOTALLIQ	:= nFatLiq    			// valor total Liquido geral das notas
			TRBFAT->TOTAL		:= nFatBrut    			// valor total BRUTO geral das notas
			
		    TRBFAT->TOTLIQDEV 	:= nTotLiqDev 			// Valor total Liquido de devolues
		    TRBFAT->TOTALDEV 	:= nTotDev 				// Valor total de devolues

		    TRBFAT->TOTLIQEXP 	:= nFatLiqExp 			// Valor total Liquido de exportaes 
		    TRBFAT->TOTALEXP 	:= nFatExp 				// Valor total de exportaes 
			// Totais por cdigo de atividade
			TRBFAT->CODATV		:= aTotFisDev[nx][1] 	// Cdigo de atividade
			TRBFAT->TOTCODAT	:= 0	   				// Valor total do cdigo de atividade
			TRBFAT->TCODATLQ	:= 0 	   				// Valor total LIQ DEVOLUCAO do cdigo de atividade
			// Verifica se existe alguma nota de devoluo para o cdigo de atividade posicionado.
			nPosFis := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosFis > 0
				TRBFAT->TCATVDEV:= aTotFisDev[nPosFis][4]// Nota de devoluo (tem que ser o valor liq, pois para desoner no inclui impostos quando tem cod atividade)
		    Else
		        TRBFAT->TCATVDEV:= 0
		    EndIf
		    TRBFAT->TCATVEXP		:= aTotFisDev[nx][3] // Total Exportao por Cdigo de atividade(Saida) 
		    // Verifica se existe alguma nota de devoluo de exportao para o cdigo de atividade posicionado.
		    nPosDev := aScan(aTotFisDev,{|x| Alltrim(x[1]) == Alltrim(aTotFisDev[nx][1])})
			If nPosDev > 0
		    	TRBFAT->TCATVDVEX	:= aTotFisDev[nPosDev][3]// Nota de devoluo de exportao 
		    Else 
			   TRBFAT->TCATVDVEX	:= 0
		    EndIf
		    nImpostos := TRBFAT->TOTCODAT - TRBFAT->TCODATLQ	
			// Tratamento efetuado para no retornar valor negativo, pois a base de clculo nunca poder ser negativa
		     If lFiscal
				nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVEXP + TRBFAT->TCATVDVEX - nImpostos  // Total por Cdigo de atividade - devoluo - exportao - impostos
			Else
				nTot := TRBFAT->TOTCODAT - TRBFAT->TCATVDEV - TRBFAT->TCATVDVEX - nImpostos  // Total por Cdigo de atividade - devoluo - dev exportao - impostos
			EndIf	
		
		    If nTot > 0
		    	TRBFAT->TCDEVEXP := nTot
		    Else 
		    	TRBFAT->TCDEVEXP := 0
		    EndIf		   		
			
			TRBFAT->(MsUnlock())
		Next(nX)
	EndIf	
EndIf

RestArea(aArea)
Return("TRBFAT")//Retorna o arquivo de trabalho  
                                               
/*


ͻ
Programa  RhInssLog Autor  Microsiga            Data   09/05/12   
͹
Desc.      Gera o arquivo de Log do periodo informado com o total das 
           de saida e devoluo                                       
͹
Uso       aFatDes - Array contendo os itens para alimentar o arq de   
          			 trabalho									       
          cPeriodo - Periodo de apurao das Notas					   
          cFilProc - Filial de Processamento						   
          l13Sal   - Gerao de arquivo de 13 salario      	              
ͼ


*/

Static Function RhInssLog(aFatDes, cPeriodo, cFilProc, l13Sal)

Local cNomeArq	:= "FAT" 
Local cArq13Sal	:= "13Sal" 
Local cArqBkp	:= "" 
Local nx		:= 0 
Local aEstru	:= {} 
Local cExtAux	:= GetDBExtension()

aAdd(aEstru,{"NumNF"		,"C",TAMSX3("D2_DOC")[1],2})	
aAdd(aEstru,{"Serie"		,"C",TAMSX3("D2_SERIE")[1],2})
aAdd(aEstru,{"Tipo"			,"C",TAMSX3("D2_TIPO")[1],2})
aAdd(aEstru,{"DataNF"		,"C",TAMSX3("D2_DTDIGIT")[1],2})
aAdd(aEstru,{"CFOP" 		,"C",TAMSX3("D2_CF")[1],2})
aAdd(aEstru,{"Total"		,"N",TAMSX3("D2_TOTAL")[1],2}) 
aAdd(aEstru,{"NFOri"		,"C",TAMSX3("D2_DOC")[1],2})	
aAdd(aEstru,{"SerieOri"		,"C",TAMSX3("D2_SERIE")[1],2})

//Verifica se o arquivo j existe e deleta o mesmo
cArqBkp:= "FAT"+cExtAux
 	If File(cArqBkp)
	Ferase(cArqBkp)
Endif
//Ŀ
//Cria o arquivo de trabalho
//	
dbcreate(cNomeArq+cExtAux,aEstru, __LocalDriver)
dbUseArea(.T.,__LocalDriver,cNomeArq,cNomeArq) 	                	
IndRegua(cNomeArq,cNomeArq,"NumNF")

FAT->(dbGoTop())
For nx:= 1 to Len(aFatDes)
	RecLock(cNomeArq, .T.)	
	FAT->NUMNF		:= aFatDes[nX][1]    
	FAT->SERIE		:= aFatDes[nx][2] 	
	FAT->TIPO		:= aFatDes[nx][3] 	
 	FAT->DATANF		:= aFatDes[nx][4] 	 	
	FAT->TOTAL		:= aFatDes[nx][5] 	
	FAT->NFORI		:= aFatDes[nx][6] 	
	FAT->SERIEORI	:= aFatDes[nx][7]
	FAT->CFOP		:= aFatDes[nx][8] 	 	

	FAT->(MsUnlock())
Next(nX)
FAT->(dbCloseArea())

//Ŀ
//Verifico se o arquivo a ser gerado  referente ao decimo terceiro salrio
//
If !l13Sal
	If file(cNomeArq+cFilProc+"DES"+CPERIODO+cExtAux) // verifico se j existe um arquivo com o nome a ser gerado
		FErase(cNomeArq+cFilProc+"DES"+CPERIODO+cExtAux) // Deleta o arquivo
		FRename(cNomeArq+cExtAux,cNomeArq+cFilProc+"DES"+CPERIODO+cExtAux) // Renomeia o arquivo	
	Else
		FRename(cNomeArq+cExtAux,cNomeArq+cFilProc+"DES"+CPERIODO+cExtAux)
	EndIf
Else
	If file(cNomeArq+cFilProc+"DES"+cArq13Sal+cExtAux) // verifico se j existe um arquivo com o nome a ser gerado
		FErase(cNomeArq+cFilProc+"DES"+cArq13Sal+cExtAux) // Deleta o arquivo
		FRename(cNomeArq+cExtAux,cNomeArq+cFilProc+"DES"+cArq13Sal+cExtAux) // Renomeia o arquivo	
	Else
		FRename(cNomeArq+cExtAux,cNomeArq+cFilProc+"DES"+cArq13Sal+cExtAux)
	EndIf
EndIf

Return


